{
  "hash": "15dc257a03b9891f34dfa5b8e1d2647d",
  "result": {
    "engine": "knitr",
    "markdown": "---\nexecute: \n  freeze: auto\nfig-width: 5\nfig-asp: 0.75\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n\n\n# Case studies {#sec-case-studies}\n\n## Mapping stunting and underwieght risk in Ghana {#sec-ghana}\n\nMalnutrition remains a critical public health issue in many low- and middle-income countries, particularly affecting children under five years of age. It can have long-term consequences on physical growth, cognitive development, and susceptibility to disease. Monitoring childhood nutritional status is essential for evaluating the effectiveness of health interventions and informing policy decisions.\n\nTwo widely used anthropometric indicators derived from child growth measurements are:\n\n-   Height-for-Age Z-score (HAZ): A measure of stunting, which reflects chronic malnutrition. Children with a HAZ below -2 standard deviations from the WHO growth reference median are considered stunted, indicating long-term nutritional deprivation or repeated infections.\n\n-   Weight-for-Age Z-score (WAZ): A composite indicator of underweight, capturing both acute and chronic malnutrition. Children with WAZ below -2 are considered underweight. This measure is commonly used in population-based surveys because it is relatively easy to collect and interpret.\n\nThese Z-scores are calculated by comparing individual anthropometric measurements to the WHO Child Growth Standards, which were developed based on data from healthy children under optimal environmental and nutritional conditions [@who2006].\n\nGeostatistical models applied to HAZ and WAZ, or to the prevalence of stunting and underweight derived from these scores, can help answer critical questions such as: *Where is the burden of malnutrition highest? How does it relate to socioeconomic or environmental factors? And which areas should be prioritized for targeted nutritional interventions?*\n\nIn this case study, we analyse HAZ and WAZ as continuous outcomes to assess the spatial variation in child malnutrition across Ghana and its association with socioeconomic and demographic covariates.\n\n### Exploratory analysis\n\nWe begin by loading the necessary R packages and the `malnutrition` dataset. This geostatistical dataset is derived from the 2014 Ghana Demographic and Health Survey (DHS) [@ghanaDHS2014], which provides nationally representative data on child health and nutrition. The dataset includes anthropometric measurements, household characteristics, and georeferenced sampling cluster coordinates, making it suitable for spatial analysis of child malnutrition.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load packages\nlibrary(RiskMap)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(patchwork)\n\n# Load the data\ndata(malnutrition)\n```\n:::\n\n\n\n\n\n\n\n\nThe explanatory variables considered in this analysis are `age` and `wealth`. Figure @fig-maln-expl displays scatterplots of the two nutritional outcomes (`HAZ` and `WAZ`) against age, alongside boxplots stratified by the three levels of the `wealth` variable.\n\nTo explore the relationship between age and nutritional status, the code below applies locally estimated scatterplot smoothing (LOESS) to highlight potential non-linear trends. In addition, we fit linear splines using the function `pmax()` to model a change in slope at specified knots—2 months for HAZ and 1 month for WAZ. These change points were selected heuristically based on visual inspection of the LOESS curves.\n\nAs shown in Figure @fig-maln-expl, the linear splines (green dashed lines) closely follow the LOESS fits (solid red lines), indicating that the piecewise linear models provide an adequate approximation of the age-nutrition relationship.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Filter complete cases for relevant variables\nmal <- malnutrition %>%\n  filter(!is.na(HAZ), !is.na(WAZ), !is.na(age), !is.na(wealth))\n\n# Fit spline model for HAZ with knot at 2 months\nmod_haz <- lm(HAZ ~ age + pmax(age - 2, 0), data = mal)\n\n# Fit spline model for WAZ with knot at 1 month\nmod_waz <- lm(WAZ ~ age + pmax(age - 1, 0), data = mal)\n\n# Prediction grid for HAZ\nnewdat_haz <- data.frame(age = seq(min(mal$age), max(mal$age), length.out = 200)) \nnewdat_haz$fit <- predict(mod_haz, newdata = newdat_haz)\n\n# Prediction grid for WAZ\nnewdat_waz <- data.frame(age = seq(min(mal$age), max(mal$age), length.out = 200)) \nnewdat_waz$fit <- predict(mod_waz, newdata = newdat_waz)\n\n# Plot HAZ vs Age\np1 <- ggplot(mal, aes(x = age, y = HAZ)) +\n  geom_point(alpha = 0.3) +\n  geom_smooth(method = \"loess\", colour = \"red\", se = FALSE) +\n  geom_line(data = newdat_haz, aes(x = age, y = fit), \n            colour = \"green\", linetype = \"dashed\", linewidth = 1.2) +\n  labs(title = \"HAZ vs Age\", x = \"Age (months)\", y = \"HAZ\") +\n  theme_minimal()\n\n# Plot WAZ vs Age\np2 <- ggplot(mal, aes(x = age, y = WAZ)) +\n  geom_point(alpha = 0.3) +\n  geom_smooth(method = \"loess\", colour = \"red\", se = FALSE) +\n  geom_line(data = newdat_waz, aes(x = age, y = fit), \n            colour = \"green\", linetype = \"dashed\", linewidth = 1.2) +\n  labs(title = \"WAZ vs Age\", x = \"Age (months)\", y = \"WAZ\") +\n  theme_minimal()\n\n# Boxplots for HAZ and WAZ by wealth\np3 <- ggplot(mal, aes(x = factor(wealth), y = HAZ)) +\n  geom_boxplot(fill = \"lightblue\") +\n  labs(title = \"HAZ by Wealth Group\", x = \"Wealth (1 = Poor, 3 = Rich)\", y = \"HAZ\") +\n  theme_minimal()\n\np4 <- ggplot(mal, aes(x = factor(wealth), y = WAZ)) +\n  geom_boxplot(fill = \"lightgreen\") +\n  labs(title = \"WAZ by Wealth Group\", x = \"Wealth (1 = Poor, 3 = Rich)\", y = \"WAZ\") +\n  theme_minimal()\n\n# Combine plots\n(p1 | p2) / (p3 | p4)\n```\n\n::: {.cell-output-display}\n![Exploratory analysis of HAZ and WAZ by age and wealth. The red lines correspond to LOESS smoothed curves and the green lines to linear splines with change points at 2 months (HAZ) and 1 month (WAZ) of age. Boxplots show variation by household wealth group.](05_case-studies_files/figure-pdf/fig-maln-expl-1.pdf){#fig-maln-expl fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n\n\nWe begin by fitting a non-spatial model to assess whether there is residual spatial correlation that remains after accounting for the effects of age and wealth. Let $Y_{ij}$ represent either the HAZ or WAZ score for the $j$-th child in the $i$-th cluster. The model takes the following form:\n\n$$\nY_{ij} = \\beta_0 + \\beta_1 a_{ij} + \\beta_2 \\max\\{a_{ij} - c, 0\\} + \\beta_3 w_i + Z_i + U_{ij},\n$$ {#eq-model-haz-waz}\n\nwhere $a_{ij}$ denotes the age in months of child $j$ in cluster $i$, and $w_i$ is the wealth score associated with cluster $i$; as previously stated, the change point $c$ of the linear spline is set to 2 months for HAZ and 1 month for WAZ. The term $Z_i$ is a Gaussian random effect with mean zero and variance $\\tau^2$, capturing between-cluster variation not explained by the covariates. The error term $U_{ij}$ represents child-specific residual variation and is assumed to be Gaussian with mean zero and variance $\\omega^2$.\n\nTo fit this model, we create a cluster ID variable based on the sampling coordinates and include it as a random intercept in the `lmer` function to incorporate the term $Z_i$.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create ID for the location\nmalnutrition <- malnutrition %>%\n  group_by(lng, lat) %>%\n  mutate(loc_id = cur_group_id()) %>%\n  ungroup()\n```\n:::\n\n\n\n\n\n\n\n\nWe then fit the models using the `lmer` function.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lme4)\nhaz_lmer <- \nlmer(HAZ ~ age + pmax(age - 2, 0) + wealth + (1 | loc_id), data = malnutrition)\n\nsummary(haz_lmer)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLinear mixed model fit by REML ['lmerMod']\nFormula: HAZ ~ age + pmax(age - 2, 0) + wealth + (1 | loc_id)\n   Data: malnutrition\n\nREML criterion at convergence: 8593.6\n\nScaled residuals: \n    Min      1Q  Median      3Q     Max \n-4.6407 -0.5992  0.0154  0.6098  5.6443 \n\nRandom effects:\n Groups   Name        Variance Std.Dev.\n loc_id   (Intercept) 0.06939  0.2634  \n Residual             1.39362  1.1805  \nNumber of obs: 2671, groups:  loc_id, 410\n\nFixed effects:\n                 Estimate Std. Error t value\n(Intercept)      -0.39571    0.08170  -4.844\nage              -0.77185    0.04471 -17.265\npmax(age - 2, 0)  0.88486    0.06698  13.211\nwealth            0.38630    0.03611  10.699\n\nCorrelation of Fixed Effects:\n            (Intr) age    p(-2,0\nage         -0.654              \npmax(g-2,0)  0.521 -0.932       \nwealth      -0.616 -0.034  0.038\n```\n\n\n:::\n\n```{.r .cell-code}\nwaz_lmer <- \n  lmer(WAZ ~ age + pmax(age - 1, 0) + wealth + (1 | loc_id), data = malnutrition)\nsummary(waz_lmer)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLinear mixed model fit by REML ['lmerMod']\nFormula: WAZ ~ age + pmax(age - 1, 0) + wealth + (1 | loc_id)\n   Data: malnutrition\n\nREML criterion at convergence: 7997.3\n\nScaled residuals: \n    Min      1Q  Median      3Q     Max \n-6.5967 -0.5816  0.0098  0.6312  5.7860 \n\nRandom effects:\n Groups   Name        Variance Std.Dev.\n loc_id   (Intercept) 0.05625  0.2372  \n Residual             1.11823  1.0575  \nNumber of obs: 2668, groups:  loc_id, 410\n\nFixed effects:\n                 Estimate Std. Error t value\n(Intercept)      -0.50444    0.08951  -5.636\nage              -0.72230    0.09615  -7.512\npmax(age - 1, 0)  0.73510    0.10754   6.835\nwealth            0.27359    0.03238   8.450\n\nCorrelation of Fixed Effects:\n            (Intr) age    p(-1,0\nage         -0.765              \npmax(g-1,0)  0.716 -0.989       \nwealth      -0.494 -0.036  0.037\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nOf particular interest in the summary of the fitted models above are the estimates of the variances associated with the random effects: $\\tau^2$ for the cluster-level terms $Z_i$, and $\\omega^2$ for the child-specific residuals $U_{ij}$. The estimates suggest that $\\omega^2$ is more than twenty times larger than $\\tau^2$, indicating that the majority of the unexplained variation occurs at the individual child level rather than between clusters. This has important implications for interpretation: any subsequent mapping of the prevalence of stunting or underweight should acknowledge the high degree of within-cluster variability as a limitation. In particular, predictions at unsampled locations may be subject to substantial uncertainty driven by this fine-scale heterogeneity.\n\n### Assessing residual spatial correlation and model fitting\n\nWe next explore the residual spatial correlation through the empirical variogram. Hence, we extract the estimate of the random effects from @eq-model-haz-waz and input these into the `s_variogram` function that generates the empirical variogram.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract random effects for HAZ and WAZ and combine them\nre <- data.frame(\n  loc_id = as.numeric(rownames(ranef(haz_lmer)$loc_id)),\n  Z_hat_haz = ranef(haz_lmer)$loc_id[,1],\n  Z_hat_waz = ranef(waz_lmer)$loc_id[,1]\n)\n\n# Extract one row per location with coordinates\nloc_coords <- malnutrition %>%\n  select(loc_id, lng, lat) %>%\n  distinct()\n\n# Merge coordinates into random effects\nre <- left_join(re, loc_coords, by = \"loc_id\")\n\n# Convert to sf and transform into UTM\nlibrary(sf)\nre <- st_as_sf(re, coords = c(\"lng\",\"lat\"), crs = 4326)\nre <- st_transform(re, crs = propose_utm(re))\n\n# Variogram for HAZ\nvar_haz <- s_variogram(re, \"Z_hat_haz\", scale_to_km = TRUE,\n                       n_permutation = 1000)\nvar_waz <- s_variogram(re, \"Z_hat_waz\", scale_to_km = TRUE,\n                       n_permutation = 1000)\nlibrary(patchwork)\n\n# Create ggplot objects\np_haz <- plot_s_variogram(var_haz, plot_envelope = TRUE) + \n  ggtitle(\"HAZ\")\n\np_waz <- plot_s_variogram(var_waz, plot_envelope = TRUE) + \n  ggtitle(\"WAZ\")\n\np_haz + p_waz\n```\n\n::: {.cell-output-display}\n![Empirical variograms for HAZ and WAZ based on the estimated random effects from @eq-model-haz-waz.](05_case-studies_files/figure-pdf/fig-maln-vari-1.pdf){#fig-maln-vari fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n\n\n@fig-maln-vari shows the variogram for both HAZ and WAZ. In both cases, we observe that is residual spatial correlation in the data that is not explained by either age or the wealth index. We next extend the model in @eq-model-haz-waz to address this issue.\n\nFor our geostatistical analysis of HAZ and WAZ, we consider the following model:\n\n$$\nY_{ij} = \\beta_0 + \\beta_1 a_{ij} + \\beta_2 \\max\\{a_{ij} - c, 0\\} + \\beta_3 w_i + S(x_i) + U_{ij},\n$$\n\nwhere $S(x)$ is a zero-mean, stationary, and isotropic Gaussian process with variance $\\sigma^2$ and an exponential correlation function with scale parameter $\\phi$. In this geostatistical extension, we replace the cluster-level random effect $Z_i$ from @eq-model-haz-waz with the spatial process $S(x_i)$. The random effect $Z_i$ was previously used in the Binomial mixed model to account for unexplained variation between clusters. It is also possible to include both $S(x_i)$ and $Z_i$ in the model, so that the total unexplained variation between clusters is decomposed into a spatially structured component, $S(x_i)$, and an unstructured component, $Z_i$. However, this approach is not recommended in the initial model specification, as it may lead to identifiability issues. It can be considered later in the analysis if justified by model diagnostics.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Remove missing data from the WAZ outcome\nmalnutrition <- malnutrition[complete.cases(malnutrition[,\"WAZ\"]),]\n\n# Converting the data-frame into an sf object\nmalnutrition_sf <- st_as_sf(malnutrition, coords = c(\"lng\", \"lat\"), crs = 4326)\nmalnutrition_sf <- st_transform(malnutrition_sf, crs = propose_utm(malnutrition_sf))\n\n# Maximum likelihood estimation for the HAZ and WAZ outcomes\nhaz_fit <- \nglgpm(HAZ ~ age + pmax(age - 1, 0) + wealth + gp(),\n      data=malnutrition_sf, family = \"gaussian\")\n\nwaz_fit <- \n  glgpm(HAZ ~ age + pmax(age - 1, 0) + wealth + gp(),\n        data=malnutrition_sf, family = \"gaussian\") \n```\n:::\n\n\n\n\n\n\n\n\nWe then summarize the fit of models.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(haz_fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCall:\nglgpm(formula = HAZ ~ age + pmax(age - 1, 0) + wealth + gp(), \n    data = malnutrition_sf, family = \"gaussian\")\n\nLinear geostatistical model\nLink: identity \nInverse link function = x \n \n'Lower limit' and 'Upper limit' are the limits of the 95% confidence level intervals\n\nRegression coefficients\n                   Estimate Lower limit Upper limit     StdErr  z.value p.value\n(Intercept)      -0.2158950  -0.4338747   0.0020848  0.1112162  -1.9412 0.05223\nage              -1.3073560  -1.4135715  -1.2011404  0.0541926 -24.1243 < 2e-16\npmax(age - 1, 0)  1.2288215   1.1496224   1.3080207  0.0404085  30.4100 < 2e-16\nwealth            0.3520544   0.3319696   0.3721393  0.0102476  34.3550 < 2e-16\n                    \n(Intercept)      .  \nage              ***\npmax(age - 1, 0) ***\nwealth           ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n                        Estimate Lower limit Upper limit\nMeasuremment error var.   1.4371      1.4254      1.4489\n\nSpatial Gaussian process\nMatern covariance parameters (kappa=0.5)\n                      Estimate Lower limit Upper limit\nSpatial process var.  0.069453    0.061423      0.0785\nSpatial corr. scale  36.529380   30.187727     44.2032\nVariance of the nugget effect fixed at 0\n\nLog-likelihood: -1859.246\nAIC: 3732.491\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(waz_fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCall:\nglgpm(formula = WAZ ~ age + pmax(age - 1, 0) + wealth + gp(), \n    data = malnutrition_sf, family = \"gaussian\")\n\nLinear geostatistical model\nLink: identity \nInverse link function = x \n \n'Lower limit' and 'Upper limit' are the limits of the 95% confidence level intervals\n\nRegression coefficients\n                   Estimate Lower limit Upper limit     StdErr  z.value\n(Intercept)      -0.4580088  -0.6499668  -0.2660509  0.0979395  -4.6764\nage              -0.7295504  -0.8235412  -0.6355596  0.0479554 -15.2131\npmax(age - 1, 0)  0.7421647   0.6720850   0.8122443  0.0357556  20.7566\nwealth            0.2254477   0.2076797   0.2432157  0.0090655  24.8689\n                   p.value    \n(Intercept)      2.919e-06 ***\nage              < 2.2e-16 ***\npmax(age - 1, 0) < 2.2e-16 ***\nwealth           < 2.2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n                        Estimate Lower limit Upper limit\nMeasuremment error var.   1.1253      1.1161      1.1346\n\nSpatial Gaussian process\nMatern covariance parameters (kappa=0.5)\n                      Estimate Lower limit Upper limit\nSpatial process var.  0.049912    0.043750      0.0569\nSpatial corr. scale  35.836303   28.815346     44.5679\nVariance of the nugget effect fixed at 0\n\nLog-likelihood: -1530.593\nAIC: 3075.187\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nThe spatial component of the models reveals a moderate degree of spatial structure in the HAZ and WAZ outcomes. For HAZ, the estimated spatial variance is approximately 0.069, while the individual-level radom effect's variance is substantially larger at around 1.437. For WAZ, the spatial variance is estimated at 0.050, compared to the variance of the individual-level radom effect's variance of 1.125. In both models, as already observed when fitting Binomial mixed models, this indicates that the majority of the residual variation is due to individual-level noise or unstructured heterogeneity rather than spatially structured effects. The relative contribution of the spatial process to the total unexplained variation is therefore relatively small. Nevertheless, geostatistical analysis remains valuable also in this context. Even when spatial effects explain only a modest proportion of the variation, the model still enables spatial prediction of the average spatial pattern for the outcome of interest across the study area. This is useful for identifying areas where child malnutrition is systematically higher or lower, guiding targeted interventions and informing resource allocation. We explore these implications further in the next section on geostatistical prediction for HAZ and WAZ.\n\n### Prediction and assessment of model calibration\n\nStunting and underweight are standard indicators used to assess child malnutrition. A child is defined as \\textit{stunted} if their height-for-age $z$-score (HAZ) is below $-2$ standard deviations from the median of the WHO Child Growth Standards, i.e., HAZ \\< -2. Similarly, a child is considered \\textit{underweight} if their weight-for-age $z$-score (WAZ) falls below $-2$, i.e., WAZ \\< -2 [@sdg2201meta2025]. These thresholds are based on the World Health Organization (WHO) growth reference standards, which provide a normative basis for assessing nutritional status in children under five years of age [@who_underweight2024].\n\nWe now define the predictive targets for stunting and underweight prevalence in terms of the adopted geostatistical model. Both indicators correspond to the probability that a child's z-score falls below $-2$, that is, $Y(x) < -2$, where $Y(x)$ denotes either the HAZ or WAZ score at location $x$. Under the model specification, the prevalence is therefore defined as\n\n$$\nT(x) = P\\left\\{ Y(x) < -2 \\,\\middle|\\, S(x) \\right\\} = \\Phi\\left( -\\frac{\\mu + S(x) + 2}{\\omega} \\right),\n$$ {#eq-prev-maln}\n\nwhere $\\Phi(\\cdot)$ is the cumulative distribution function of the standard normal distribution, $\\mu$ is the linear predictor including the effects of covariates at individual- and cluster-level (as defined by the coefficients $\\beta_1$ to $\\beta_3$ of @eq-model-haz-waz) as well as the intercept, and $\\omega^2$ is the variance of the individual-level residual term. In @eq-prev-maln, we condition on $S(x)$ because this allows us to define both stunting an underweight prevalence as a spatially varying predictive target.\n\nTo implement this in `RiskMap`, we begin by generating a predictive grid over the study region. In this case, we use a regular grid with 10 km by 10 km resolution. We then draw predictive samples of the spatial effect $S(x)$ at each grid location, conditional on the observed data. For the `age` variable, we fix it at 2 months for HAZ and 1 month for WAZ, respectively. The `wealth` variable is set to its lowest value of 1. These choices are made to visualize the predictive target for the subgroup of children most at risk of stunting and underweight, as identified through exploratory analysis and the estimated regression coefficients. The code below illustrates this procedure.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Boundaries of Ghana\nlibrary(rgeoboundaries)\nghana <- geoboundaries(country = \"Ghana\", adm_lvl = \"adm0\")\nghana <- st_transform(ghana, st_crs(malnutrition_sf))\n\nghana_grid <- create_grid(ghana, spat_res = 10)\n\nn_pred <- nrow(st_coordinates(ghana_grid))\n\n# Prediction of S(x) and covariates effects over the grid for\n\n# HAZ\nhaz_pred_grid <- pred_over_grid(haz_fit,\n                                grid_pred = ghana_grid,\n                                predictors = data.frame(\n                                  # Setting age to 2 months\n                                  age = rep(2, n_pred),\n                                  # Setting wealth to 1 (least wealthy)\n                                  wealth = rep(1, n_pred)\n                                ))\n# WAZ\nwaz_pred_grid <- pred_over_grid(waz_fit,\n                                grid_pred = ghana_grid,\n                                predictors = data.frame(\n                                  # Setting age to 1 month\n                                  age = rep(1, n_pred),\n                                  # Setting wealth to 1 (least wealthy)\n                                  wealth = rep(1, n_pred)\n                                ))\n```\n:::\n\n\n\n\n\n\n\n\nWe then use the `pred_target_grid` function to generate predictive summaries of stunting and underweight prevalence, as defined in @eq-prev-maln. To quantify uncertainty in the predictions, we report the coefficient of variation, which provides a standardized measure of relative uncertainty across the prediction grid.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Prediction of stunting prevalence\nsd_ind_haz <- sqrt(coef(haz_fit)$sigma2_me)\nstunting_prev <-\npred_target_grid(haz_pred_grid,\n                 f_target = list(prev = function(x) pnorm((-2-x)/sd_ind_haz)),\n                 pd_summary = list(mean = mean,\n                                       cv = function(x) sd(x)/mean(x)))\n\n# Prediction of underweight prevalence\nsd_ind_waz <- sqrt(coef(waz_fit)$sigma2_me)\nunderw_prev <-\n  pred_target_grid(waz_pred_grid,\n                   f_target = list(prev = function(x) pnorm((-2-x)/sd_ind_waz)),\n                   pd_summary = list(mean = mean,\n                                     cv = function(x) sd(x)/mean(x)))\n```\n:::\n\n\n\n\n\n\n\n\nFinally, we visualize the results in the map shown in @fig-maln-pred. The maps reveal a clear hotspot for both stunting and underweight, with predicted prevalence values reaching approximately $45\\%$ and $24\\%$, respectively. Notably, this same region also exhibits lower predictive uncertaint, measured by the coefficient of variation, compared to other areas in Ghana.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set up a 2x2 layout\nlayout(matrix(1:4, nrow = 2, byrow = TRUE))\npar(mar = c(4, 4, 4, 5))  # Adjust margins\n\n# Top row: stunting\nplot(stunting_prev, which_target = \"prev\", which_summary = \"mean\",\n     main = \"Stunting: Predictive Mean\")\nplot(stunting_prev, which_target = \"prev\", which_summary = \"cv\",\n     main = \"Stunting: Coefficient of Variation\")\n\n# Bottom row: underweight\nplot(underw_prev, which_target = \"prev\", which_summary = \"mean\",\n     main = \"Underweight: Predictive Mean\")\nplot(underw_prev, which_target = \"prev\", which_summary = \"cv\",\n     main = \"Underweight: Coefficient of Variation\")\n```\n\n::: {.cell-output-display}\n![Predictive mean and coefficient of variation for stunting and underweight prevalence estimates. The top row shows predictions for stunting, while the bottom row corresponds to underweight. For each indicator, the left panel shows the predictive mean and the right panel the coefficient of variation.](05_case-studies_files/figure-pdf/fig-maln-pred-1.pdf){#fig-maln-pred fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n\n\nTo assess the predictive performance and calibration of our geostatistical models for HAZ and WAZ, we perform a cross-validation exercise using the `assess_pp` function. Cross-validation is conducted by repeatedly splitting the data into training and testing sets, ensuring that prediction locations are at least 5 km away from the nearest training point. Specifically, we set `n_size = 100` prediction locations for the test set, impose a minimum distance constraint of 5 km (`min_dist = 5`), and repeat the process over 10 test sets randomly drawn under those conditions (`iter = 10`) using `method=\"regularized\"` as the sampling method.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# HAZ\nassess_haz <-\nassess_pp(list(HAZ = haz_fit),\n          n_size = 100,\n          min_dist = 5,\n          iter = 10,\n          method = \"regularized\")\n\n# WAZ\nassess_waz <-\n  assess_pp(list(WAZ = waz_fit),\n            n_size = 100,\n            min_dist = 5,\n            iter = 10,\n            method = \"regularized\")\n```\n:::\n\n\n\n\n\n\n\n\nWe note that for a Gaussian linear geostatistical model, the `assess_pp` function does not compute the average non-randomized probability integral transform (AnPIT, introduced in @sec-anpit), as this measure is specifically designed for count outcomes. Instead, it employs the standard probability integral transform (PIT), defined as $\\text{PIT}(y) = F_{M}(y)$, where $F_{M}(y)$ is the cumulative distribution function of the predictive distribution evaluated at the observed value $y$. The PIT transforms the observed outcomes in the test set such that, if the model is well-calibrated, these transformed values should follow a uniform distribution. Deviations from uniformity indicate potential issues with calibration and predictive accuracy.\n\n@fig-maln-pit shows the results of the cross-validation exercise visualized through PIT curves for HAZ and WAZ. Similarly to the way we have interpreted the AnPIT curves, the PIT curves indicate good calibration when they lie close to the identity line, meaning the predictive distributions accurately reflect the observed variability in the test sets. The results shown in @fig-maln-pit demonstrate that, for all ten test sets and for both HAZ and WAZ, the PIT curves closely align with the identity line, confirming that the models are well-calibrated and provide reliable uncertainty quantification.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generate PIT plots\np_haz <- plot_AnPIT(assess_haz, mode = \"all\")\np_waz <- plot_AnPIT(assess_waz, mode = \"all\")\n\n# Arrange side-by-side\nlibrary(gridExtra)\ngrid.arrange(p_haz, p_waz, ncol = 2)\n```\n\n::: {.cell-output-display}\n![Assessment of the models calibration. The left panel shows the probability integral transform (PIT) curve for HAZ, and the right panel for WAZ. In both panels, the red dahsed line corresponds to the identity line.](05_case-studies_files/figure-pdf/fig-maln-pit-1.pdf){#fig-maln-pit fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n\n\n### Summary and conclusions\n\nThis case study demonstrated the utility of geostatistical modeling for mapping child malnutrition in Ghana using continuous anthropometric measurements, namely HAZ and WAZ Z-scores. By modeling these outcomes directly, we were able to define stunting and underweight prevalence as predictive probabilities based on threshold exceedance (e.g., HAZ \\< -2), rather than by dichotomizing the data prior to analysis. This approach allowed us to retain the full information content of the measurements and to produce spatially resolved predictions of prevalence along with associated uncertainty estimates. Readers interested in a more in-depth treatment of this modeling strategy are referred to @kyomuhangi2021, which discusses the loss of information and degradation in predictive performance that can result from dichotomizing continuous outcomes in geostatistical settings.\n\nMore broadly, this case study illustrated how geostatistical models can be used to analyze individual-level outcomes while accounting for both child-level and household-level covariates. Aggregation of data across individuals, such as using average HAZ or WAZ scores per location, is not required and can in fact introduce several complications. In particular, the number of children per cluster varies, which implies that an analysis based on cluster-level averages would require a heteroscedastic specification for the residual term to appropriately reflect varying precision across locations. Ignoring this could lead to unreliable predictive inferences.\n\nIn conclusion, this analysis showed that neither dichotomization nor aggregation is necessary in geostaistical analysis. Instead, geostatistical models should be fitted to individual-level continuous outcomes, and suitable predictive targets and summaries of uncertainty can then be derived from the fitted model.\n\n## Mapping malaria in Malawi\n\nIn this section, we demonstrate how to conduct a geostatistical analysis using Malaria Indicator Survey (MIS) data accessed through the `malariaAtlas` R package [@malariaAtlas]. This package provides streamlined access to a curated repository of georeferenced malaria data, including prevalence surveys and associated metadata, making it a valuable resource for spatial epidemiological studies. The primary aim here is to illustrate how relevant environmental covariates can be obtained via Google Earth Engine and incorporated into a geostatistical model for prevalence mapping. Although the analysis is not guided by a specific research question, its value lies in showcasing the full workflow and technical aspects introduced in previous chapters, including data preparation, covariate extraction, exploratory analysis, model fitting, and spatial prediction of disease prevalence.\n\n### Downloading prevalence and raster data\n\nThis section illustrates how to access and visualize Malaria Indicator Survey data using the `malariaAtlas` R package, focusing on *Plasmodium falciparum* prevalence in Malawi for the year 2006. We walk through the steps to extract survey data, obtain country boundaries, and produce a basic map of raw prevalence data.\n\nWe begin by loading the necessary packages and initializing the Earth Engine API via the `rgee` package.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load libraries\nlibrary(malariaAtlas)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(sf)\nlibrary(rgee)\nlibrary(terra)\nlibrary(rgeoboundaries)\nlibrary(grid)\n\n# Initialize Earth Engine\nee_Initialize()\n```\n:::\n\n\n\n\n\n\n\n\nWe then use `rgeoboundaries` to obtain Malawi’s administrative boundary and extract P. falciparum prevalence survey data from the `malariaAtlas` package for surveys conducted in or overlapping the year 2006.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get Malawi boundary\nmlw_admin0_sf <- geoboundaries(country = \"Malawi\", adm_lvl = \"adm0\")\nmlw_admin0_ee <- sf_as_ee(mlw_admin0_sf)\n\n# Download PfPR survey data\nmlw_pfpr <- getPR(country = \"Malawi\", species = \"Pf\") %>%\n  filter(year_start <= 2006 & year_end >= 2006) %>%\n  filter(!is.na(longitude) & !is.na(latitude))\n\n# Convert to sf object\nmlw_sf <- st_as_sf(mlw_pfpr, coords = c(\"longitude\", \"latitude\"), crs = 4326)\n\n# Convert to UTM \nmlw_crs <- propose_utm(mlw_sf)\nmlw_sf <- st_transform(mlw_sf, crs = mlw_crs)\n\n# Remove columns with all NAs\nmlw_sf <- mlw_sf[, colSums(!is.na(mlw_sf)) > 0]\n```\n:::\n\n\n\n\n\n\n\n\nThe following map displays the raw prevalence data at each survey location. The size and color of each point reflect the estimated malaria prevalence (pr) at that location.\n\n\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Compute prevalence\n# Compute observed prevalence\nmlw_sf$pr <- mlw_sf$positive / mlw_sf$examined\n\n# Plot raw PfPR data with uniform point size and no axis labels\nggplot() +\n  geom_sf(data = mlw_admin0_sf, fill = \"white\", color = \"black\") +\n  geom_sf(data = mlw_sf, aes(color = pr), size = 1, alpha = 0.8) +\n  scale_color_viridis_c(name = \"PfPR\") +\n  theme_minimal() +\n  ggtitle(\"Malaria Prevalence in Malawi (2006)\") +\n  theme(\n    legend.position = \"right\",\n    axis.title = element_blank(),\n    axis.text = element_blank(),\n    axis.ticks = element_blank()\n  )\n\n```\n\n::: {.cell-output-display}\n![Raw PfPR survey data for Malawi in 2006. Each point represents a georeferenced survey location, with color and size indicating estimated prevalence.](05_case-studies_files/figure-pdf/fig-malawi-raw-map-1.pdf){#fig-malawi-raw-map fig-align='center' fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n\n\nIn the next step we retrieve a suite of environmental covariates that are mechanistically linked to malaria transmission and therefore commonly included in spatial risk-mapping studies. All layers are clipped to the Malawi national boundary and combined into a single multi-band image ready for extraction at the survey points.\n\nThese covariates are summarised in Table @tbl-covariates, which also explains their epidemiological relevance in the context of malaria transmission.\n\n| Covariate | Source | Processing | Relevance |\n|------------------|------------------|------------------|------------------|\n| Precipitation | CHIRPS Daily | Annual mean (mm · day⁻¹) | Determines suitability of breeding sites for *Anopheles* mosquitoes. |\n| Land-surface temperature | MODIS MOD11A2 | Kelvin converted to °C; annual mean | Affects mosquito survival and parasite development rates. |\n| NDVI | MODIS MOD13A2 | Scaled to 0–1; annual mean | Proxy for habitat moisture and vegetation cover. |\n| Elevation | SRTM DEM | 90 m; clipped to country boundary | Integrates climatic variation; highlands tend to have lower transmission. |\n| Relative humidity | ERA5-Land | Derived from temperature and dew-point; annual mean (%) | High humidity increases mosquito survival. |\n| Urbanicity (built-up areas) | MODIS MCD12Q1 | Binary indicator (class 13 = urban) | Urban areas generally have lower risk due to infrastructure and fewer breeding sites. |\n\n: Environmental covariates extracted from Google Earth Engine and their relevance for malaria risk modelling. {#tbl-covariates}\n\nWe point out that in order to compute relative humidity, we first extract hourly estimates of air temperature and dew-point temperature at 2 meters above ground level from the ERA5-Land reanalysis product. These two quantities are then combined using a standard empirical formula derived from the Clausius–Clapeyron relation: $$\n\\text{RH} = 100 \\times \\left( \\frac{e^{\\frac{17.625 \\cdot T_d}{243.04 + T_d}}}{e^{\\frac{17.625 \\cdot T}{243.04 + T}}} \\right)\n$$ where $T_d$ is the dew-point temperature and $T$ is the air temperature, both in degrees Celsius. This yields the mean annual relative humidity over the target region, expressed as a percentage.\n\n@tbl-covariates does not provide an exhaustive list of covariates, and other factors such as soil moisture, land surface water, nighttime temperature, or socio-economic indicators like night-time light intensity and land surface emissivity, which may serve as proxies for human activity, infrastructure, or economic development, could also influence malaria risk. However, to maintain this illustrative analysis simpler, we restrict our attention to a core set of covariates that capture key climatic, ecological, and anthropogenic drivers.\n\nIn the code below, all layers are clipped to the boundary of Malawi and combined into a single multi-band image, ready to be extracted at survey point locations for subsequent modeling.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# -------------------------------\n# STEP 2: Covariates from Earth Engine\n# -------------------------------\nscale_m <- 1000\n\n# Precipitation\nprecip <- ee$ImageCollection(\"UCSB-CHG/CHIRPS/DAILY\")$\n  filterDate(\"2006-01-01\", \"2006-12-31\")$\n  mean()$rename(\"precip\")$clip(mlw_admin0_ee)$toFloat()\n\n# Temperature\nlst <- ee$ImageCollection(\"MODIS/061/MOD11A2\")$\n  filterDate(\"2006-01-01\", \"2006-12-31\")$\n  select(\"LST_Day_1km\")$mean()$\n  multiply(0.02)$subtract(273.15)$rename(\"lst_c\")$\n  clip(mlw_admin0_ee)$toFloat()\n\n# NDVI\nndvi <- ee$ImageCollection(\"MODIS/061/MOD13A2\")$\n  filterDate(\"2006-01-01\", \"2006-12-31\")$\n  select(\"NDVI\")$mean()$\n  multiply(0.0001)$rename(\"ndvi\")$\n  clip(mlw_admin0_ee)$toFloat()\n\n# Elevation\nelev <- ee$Image(\"USGS/SRTMGL1_003\")$\n  rename(\"elev\")$clip(mlw_admin0_ee)$toFloat()\n\n# Humidity from ERA5 (computed from dewpoint and temperature)\nera5 <- ee$ImageCollection(\"ECMWF/ERA5_LAND/HOURLY\")$\n  filterDate(\"2006-01-01\", \"2006-12-31\")$\n  select(c(\"dewpoint_temperature_2m\", \"temperature_2m\"))$\n  mean()$clip(mlw_admin0_ee)\n\ntd <- era5$select(\"dewpoint_temperature_2m\")$subtract(273.15)\nt <- era5$select(\"temperature_2m\")$subtract(273.15)\n\nrh <- td$expression(\n  \"100 * (exp((17.625 * TD)/(243.04 + TD)) / exp((17.625 * T)/(243.04 + T)))\",\n  list(TD = td, T = t)\n)$rename(\"humidity\")$toFloat()\n\n# Use MODIS Land Cover, version 061\nurban_raw <- ee$ImageCollection(\"MODIS/061/MCD12Q1\")$\n  filterDate(\"2006-01-01\", \"2006-12-31\")$\n  first()$select(\"LC_Type1\")$clip(mlw_admin0_ee)\n\n# Urban areas are class 13 in IGBP classification\nbuilt_up <- urban_raw$eq(13)$rename(\"built_up\")$toFloat()\n\n\n\n# Combine all covariates\ncovariates <- precip$\n  addBands(lst)$\n  addBands(ndvi)$\n  addBands(elev)$\n  addBands(rh)$\n  addBands(built_up)\n```\n:::\n\n\n\n\n\n\n\n\nAfter defining the multi-band raster image `covariates` in Google Earth Engine, we download it as a GeoTIFF file using the `ee_as_rast()` function from the `rgee` package. The file is saved temporarily and clipped to the bounding box of Malawi. We then read the raster into R using the `terra`.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# -------------------------------\n# STEP 3: Download Earth Engine raster\n# -------------------------------\nout_file <- file.path(tempdir(), \"malawi_covariates_2006.tif\")\nregion <- mlw_admin0_ee$geometry()$bounds()\n\nrgee::ee_as_rast(\n  image = covariates,\n  region = region,\n  scale = scale_m,\n  dsn = out_file,\n  via = \"drive\"\n)\n\n# Load raster\nr_covs <- rast(out_file)\n\n# -------------------------------\n# STEP 4: Extract covariates at survey locations\n# -------------------------------\nvals <- terra::extract(r_covs, vect(mlw_sf))\nmlw_sf <- bind_cols(mlw_sf, vals[, -1])  # remove ID column\n```\n:::\n\n\n\n\n\n\n\n\nThe following code generates six raster maps, one for each covariate, using ggplot2. We first convert the raster stack to a data frame and then create a separate ggplot object for each variable, ensuring a consistent and clean visual style across all maps. The plots in @fig-covariates-map are arranged in a 2 × 3 grid using the base grid package.\n\n\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# 1. Prepare a data frame\n\nr_df <- as.data.frame(r_covs, xy = TRUE, na.rm = TRUE)\n\n# Rename layers for clarity\nnames(r_df) <- c(\"x\", \"y\",\n                 \"Precipitation\",          \n                 \"Temperature\",            \n                 \"NDVI\",                   \n                 \"Elevation\",              \n                 \"Humidity\",               \n                 \"Urbanicity\")             \n\n# Urbanicity as a factor for a discrete palette\nr_df$Urbanicity <- factor(r_df$Urbanicity,\n                          levels = c(0, 1),\n                          labels = c(\"Rural\", \"Urban\"))\n\n# 2. Build one map per covariate, each with its own colour scale \np_precip <- ggplot(r_df, aes(x, y, fill = Precipitation)) +\n  geom_raster() +\n  scale_fill_gradient(name = \"mm\", low = \"lightblue\", high = \"darkblue\") +\n  coord_equal() + theme_void() + ggtitle(\"Precipitation\")\n\np_temp <- ggplot(r_df, aes(x, y, fill = Temperature)) +\n  geom_raster() +\n  scale_fill_gradient(name = \"°C\", low = \"lemonchiffon\", high = \"red3\") +\n  coord_equal() + theme_void() + ggtitle(\"LST\")\n\np_ndvi <- ggplot(r_df, aes(x, y, fill = NDVI)) +\n  geom_raster() +\n  scale_fill_gradient(name = \" \", low = \"cornsilk\", high = \"darkgreen\") +\n  coord_equal() + theme_void() + ggtitle(\"NDVI\")\n\np_elev <- ggplot(r_df, aes(x, y, fill = Elevation)) +\n  geom_raster() +\n  scale_fill_gradient(name = \"m\", low = \"grey90\", high = \"sienna4\") +\n  coord_equal() + theme_void() + ggtitle(\"Elevation\")\n\np_humid <- ggplot(r_df, aes(x, y, fill = Humidity)) +\n  geom_raster() +\n  scale_fill_gradient(name = \"%\", low = \"white\", high = \"darkcyan\") +\n  coord_equal() + theme_void() + ggtitle(\"Humidity\")\n\np_urban <- ggplot(r_df, aes(x, y, fill = Urbanicity)) +\n  geom_raster() +\n  scale_fill_manual(values = c(\"lightgrey\", \"black\"),\n                    name = \" \") +\n  coord_equal() + theme_void() + ggtitle(\"Urban vs Rural\")\n\n# 3. Arrange the six plots in a 2 × 3 grid using base 'grid'\ngrid.newpage()\npushViewport(viewport(layout = grid.layout(2, 3)))\nvplayout <- function(row, col)\n  viewport(layout.pos.row = row, layout.pos.col = col)\n\nprint(p_precip, vp = vplayout(1, 1))\nprint(p_temp,   vp = vplayout(1, 2))\nprint(p_ndvi,   vp = vplayout(1, 3))\nprint(p_elev,   vp = vplayout(2, 1))\nprint(p_humid,  vp = vplayout(2, 2))\nprint(p_urban,  vp = vplayout(2, 3))\n```\n\n::: {.cell-output-display}\n![Raster maps of environmental covariates extracted from Google Earth Engine for Malawi in 2006. Each panel shows one covariate: precipitation, land surface temperature (LST), vegetation cover (NDVI), elevation, relative humidity, and urbanicity. These layers are used as predictors in the geostatistical modelling of malaria prevalence.](05_case-studies_files/figure-pdf/fig-covariates-map-1.pdf){#fig-covariates-map fig-align='center' fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n\n\n### Exploratory analysis\n\nTo investigate how *Plasmodium falciparum* prevalence varies with environmental conditions, we begin by computing the empirical logit transformation of the observed prevalence at each survey location. Each covariate is then explored in relation to the empirical logit using scatterplots. For continuous covariates, we produce scatter plots with two fitted curves: a LOESS smoother shown in red, and a linear spline model with a single change point shown in blue. The LOESS curve serves as a flexible, nonparametric reference for assessing the general trend in the data. The spline model provides a simple parametric approximation to this trend, with the change point selected based on visual inspection of where the LOESS curve departs from linearity.\n\n\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n\n# 1. Prepare data\nmlw_sf <- mlw_sf %>%\n  mutate(\n    elogit = log((positive + 0.5) / (examined - positive + 0.5)),\n    `Precipitation` = precip,\n    `Temperature (°C)` = lst_c,\n    `NDVI` = ndvi,\n    `Elevation (m)` = elev,\n    `Humidity (%)` = humidity,\n    `Urbanicity` = factor(built_up, levels = c(0, 1), labels = c(\"Rural\", \"Urban\"))\n  )\n\n# 2. Drop geometry and reshape\nplot_data_cont <- mlw_sf %>%\n  select(elogit, `Precipitation`, `Temperature (°C)`, `NDVI`, `Elevation (m)`, `Humidity (%)`) %>%\n  st_drop_geometry() %>%\n  pivot_longer(cols = -elogit, names_to = \"Covariate\", values_to = \"Value\")\n\nplot_data_cat <- mlw_sf %>%\n  select(elogit, Urbanicity) %>%\n  st_drop_geometry()\n\n# 3. Define change points\nknots <- c(\n  \"Precipitation\" = Inf,\n  \"Temperature (°C)\" = 33,\n  \"NDVI\" = Inf,\n  \"Elevation (m)\" = 400,\n  \"Humidity (%)\" = 65\n)\n\n# 4. Create individual continuous plots\nplots <- lapply(split(plot_data_cont, plot_data_cont$Covariate), function(df) {\n  var <- unique(df$Covariate)\n  knot <- knots[[var]]\n  \n  df <- df %>%\n    mutate(\n      linear_part = Value,\n      spline_part = pmax(Value - knot, 0)\n    )\n  \n  ggplot(df, aes(x = Value, y = elogit)) +\n    geom_point(alpha = 0.5, size = 1) +\n    geom_smooth(method = \"loess\", se = FALSE, color = \"red\", linewidth = 1) +\n    geom_smooth(method = \"lm\",\n                formula = y ~ x + pmax(x - knot, 0),\n                se = FALSE, color = \"blue\", linewidth = 1) +\n    labs(x = var, y = NULL) +\n    theme_minimal()\n})\n\n# 5. Add Urbanicity boxplot\np_urban <- ggplot(plot_data_cat, aes(x = Urbanicity, y = elogit)) +\n  geom_boxplot(outlier.size = 0.5) +\n  labs(x = \"Urbanicity\", y = NULL) +\n  theme_minimal()\n\n# 6. Assemble 2 x 3 plot grid\nfinal_plot <- (plots[[1]] | plots[[2]] | plots[[3]]) /\n  (plots[[4]] | plots[[5]] | p_urban) +\n  plot_annotation(title = \"Empirical logit of prevalence vs environmental covariates\")\n\nfinal_plot\n\n```\n\n::: {.cell-output-display}\n![Exploratory plots showing the relationship between the empirical logit of *P. falciparum* prevalence and the chosen environmental covariates. Scatter plots show continuous covariates with LOESS (red) and linear spline (blue) fits. A boxplot is used for the binary urbanicity variable. Change points for splines are based on graphical inspection of the LOESS fitted relationship.](05_case-studies_files/figure-pdf/fig-elogit-vs-covariates-1.pdf){#fig-elogit-vs-covariates fig-align='center' fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n\n\n@fig-elogit-vs-covariates shows the results of this exploratory approach for the relationship between prevalence and covariates. For some variables, such as temperature, elevation, and humidity, there is a clear nonlinear association that is reasonably captured by a single change point. For others, including precipitation and NDVI, the relationship appears approximately linear, and for this reason no change point is used in the spline fit.\n\nUrbanicity is treated separately as a binary covariate and visualized with a boxplot comparing the empirical logit of prevalence between rural and urban settings. The boxplot indicates that, as we expect, the level of prevalence in urban areas is considerable lower than in rural areas.\n\nTo assess the degree of correlation between covariates, we compute the pairwise Pearson correlation coefficients among the continuous environmental variables.\n\n\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(ggcorrplot)\n\n# Select continuous covariates only\ncont_vars <- mlw_sf %>%\n  st_drop_geometry() %>%\n  select(Precipitation = precip,\n         Temperature = lst_c,\n         NDVI = ndvi,\n         Elevation = elev,\n         Humidity = humidity)\n\n# Compute correlation matrix\ncorr_mat <- cor(cont_vars, use = \"complete.obs\")\n\n# Plot correlation matrix\nggcorrplot(corr_mat,\n           method = \"circle\",\n           type = \"lower\",\n           lab = TRUE,\n           lab_size = 3,\n           colors = c(\"blue\", \"white\", \"red\"),\n           title = \"Correlation between covariates\",\n           ggtheme = theme_minimal())\n```\n\n::: {.cell-output-display}\n![Pairwise Pearson correlation matrix between continuous environmental covariates.](05_case-studies_files/figure-pdf/fig-correlation-heatmap-1.pdf){#fig-correlation-heatmap fig-align='center' fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n\n\nThe correlations, shown in Figure @fig-correlation-heatmap, are generally moderate in magnitude, ranging from –0.66 between temperature and precipitation to 0.54 between elevation and relative humidity. These values indicate that collinearity is not a major concern in our model development. Each covariate is likely to provide complementary information about malaria risk, and the absence of strong dependencies also supports the reliability of the scatterplots used to explore their individual relationships with prevalence.\n\nWe also perform a principal component analysis (PCA) on the standardized continuous environmental covariates to assess the potential for reducing dimensionality in our model. The code below shows the implementation of the PCA.\n\n\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(factoextra)\n\n# Prepare only continuous covariates and standardize\npca_data <- mlw_sf %>%\n  st_drop_geometry() %>%\n  select(Precipitation = precip,\n         Temperature = lst_c,\n         NDVI = ndvi,\n         Elevation = elev,\n         Humidity = humidity) %>%\n  scale()\n\n# Perform PCA\npca_result <- prcomp(pca_data)\n\n# Scree plot\nfviz_eig(pca_result, addlabels = TRUE, barfill = \"steelblue\", barcolor = \"grey30\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![Proportion of variance explained by the principal components computed from standardized continuous environmental covariates.](05_case-studies_files/figure-pdf/fig-pca-scree-1.pdf){#fig-pca-scree fig-align='center' fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n\n\nThe scree plot in Figure @fig-pca-scree shows the proportion of variance explained by each principal component. The first principal component (PC1) explains approximately 50% of the total variation, suggesting it captures a substantial environmental gradient across the study region. Although additional components may carry useful information, PC1 stands out as a potential candidate for use in model building as a composite environmental index and spatial predictor of malaria prevalence.\n\n\n\n\n\n\n\n\n::: {#tbl-pca-loadings .cell tbl-cap='Loadings of the first two principal components. Each value indicates the contribution of a standardized covariate to the corresponding component.'}\n::: {.cell-output-display}\n\n\n|Covariate     |  PC1   |  PC2   |\n|:-------------|:------:|:------:|\n|Precipitation | -0.480 | -0.339 |\n|Temperature   | 0.596  | 0.043  |\n|NDVI          | -0.338 | -0.605 |\n|Elevation     | -0.391 | 0.560  |\n|Humidity      | -0.385 | 0.451  |\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nTable @tbl-pca-loadings displays the loadings of the first two principal components. The sign and magnitude of each loading reflect how much each standardized covariate contributes to the corresponding component. PC1 shows strong positive loading for temperature and strong negative loadings for precipitation, humidity, and elevation. This suggests that PC1 represents a gradient from cool, humid, high-elevation areas with more rainfall to hotter, drier lowland regions. NDVI also contributes negatively, implying more vegetation cover in cooler, wetter zones. We can thus interpret PC1 as a general heat-aridity gradient, which well aligns with known ecological drivers of malaria risk.\n\n\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Create raster for PC1\nr_stack_std <- scale(r_covs[[c(\"precip\", \"lst_c\", \"ndvi\", \"elev\", \"humidity\")]])\npc1_weights <- c(-0.480, 0.596, -0.338, -0.391, -0.385)\npc1_rast <- sum(r_stack_std * pc1_weights)\nnames(pc1_rast) <- \"PC1\"\n\n# Extract PC1 values\npc1_vals <- terra::extract(pc1_rast, vect(mlw_sf))\nmlw_sf$PC1 <- pc1_vals[, 2]\n\n# Convert raster to df for ggplot\npc1_df <- as.data.frame(pc1_rast, xy = TRUE, na.rm = TRUE)\nnames(pc1_df) <- c(\"x\", \"y\", \"PC1\")\n\n# --- Create PC1 map plot ---\np_map <- ggplot(pc1_df, aes(x = x, y = y, fill = PC1)) +\n  geom_raster() +\n  scale_fill_viridis_c(option = \"C\") +\n  coord_equal() +\n  theme_void() +\n  ggtitle(\"PC1: Environmental Gradient\")\n\n# --- Create scatterplot with LOESS and spline ---\nknot_pc1 <- 0.75\nscatter_df <- mlw_sf %>%\n  mutate(spline_part = pmax(PC1 - knot_pc1, 0))\n\np_scatter <- ggplot(scatter_df, aes(x = PC1, y = elogit)) +\n  geom_point(alpha = 0.5, size = 1) +\n  geom_smooth(method = \"loess\", se = FALSE, color = \"red\", linewidth = 1) +\n  geom_smooth(method = \"lm\", formula = y ~ x + pmax(x - knot_pc1, 0),\n              se = FALSE, color = \"blue\", linewidth = 1) +\n  theme_minimal() +\n  labs(x = \"PC1\", y = \"Empirical logit\") +\n  ggtitle(\"Empirical logit vs PC1\")\n\n# --- Combine using patchwork ---\n# Also add some margin space\np_map <- p_map + theme(plot.margin = margin(r = 20))\np_scatter <- p_scatter + theme(plot.margin = margin(l = 20))\np_map + p_scatter\n```\n\n::: {.cell-output-display}\n![Left: Spatial distribution of the first principal component (PC1). Right: Empirical logit of malaria prevalence plotted against PC1 with LOESS (red) and linear spline (blue) fits.](05_case-studies_files/figure-pdf/fig-pca1-map-scatter-1.pdf){#fig-pca1-map-scatter fig-align='center' fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n\n\n@fig-pca1-map-scatter displays the map of PC1 alongside its relationship with malaria prevalence. As done previously, to aid interpretation, we fit a LOESS curve (red) to visualise the general trend, and a linear spline (blue) with a change point at 0.75 to capture a simplified parametric relationship. The spline fit suggests a nonlinear association: malaria risk increases with PC1 up to around 0.75, after which it begins to decline. This pattern implies that malaria prevalence is highest in areas with intermediate PC1 values, i.e. environments that are neither too cold and wet nor too hot and arid. In other words, there appears to be an optimal range of environmental conditions, as summarised by PC1, that are most conducive to malaria transmission. Beyond this range, particularly in more heat-arid regions, the risk may decline due to ecological constraints on mosquito survival or parasite development.\n\nIn the next section, we compare two modelling approaches. The first model includes the original environmental covariates using the linear spline specifications identified during our exploratory analysis. The second model replaces these covariates with PC1 alone, treating it as a composite spatial predictor that summarises the dominant environmental gradient in the study area. In both models, we include urbanicity as a separate fixed effect. Urbanicity is excluded from the PCA because it is a binary variable and highly unbalanced, with most survey locations classified as rural. Modelling it separately ensures that its distinct contribution to malaria risk, more linked to infrastructure, housing conditions, and land use, is properly accounted for.\n\n### Model fitting and spatial prediction\n\nIn this section, we fit two geostatistical models to malaria prevalence data from Malawi, comparing the effects of using separate environmental covariates versus summarizing them into a principal component.\n\nThe first model (`mod_all_cov`) includes all environmental covariates as separate predictors. Namely these are precipitation $d_{\\text{prec}}(x)$, NDVI $d_{\\text{ndvi}}(x)$, temperature $d_{\\text{temp}}(x)$, elevation $d_{\\text{elev}}(x)$, humidity $d_{\\text{hum}}(x)$, and urbanicity $d_{\\text{urb}}(x)$. Following from the results of the exploratory analysis, nonlinear effects for temperature, elevation, and humidity are modeled using linear splines with thresholds at 33°C, 400 m, and 65%, respectively. The logit-linear model is:\n\n$$\n\\begin{aligned}\n\\log\\left\\{\\frac{p(x)}{1 - p(x)}\\right\\} =\\; & \n\\beta_0 + \n\\beta_1 d_{\\text{prec}}(x) +\n\\beta_2 d_{\\text{ndvi}}(x) +\n\\beta_3 d_{\\text{temp}}(x) + \\beta_4 \\max\\{d_{\\text{temp}}(x) - 33,\\; 0\\} \\\\\\\\\n& +\n\\beta_5 d_{\\text{elev}}(x) + \\beta_6 \\max\\{d_{\\text{elev}}(x) - 400,\\; 0\\} \\\\\\\\\n& +\n\\beta_7 d_{\\text{hum}}(x) + \\beta_8 \\max\\{d_{\\text{hum}}(x) - 65,\\; 0\\} \\\\\\\\\n& +\n\\beta_9 d_{\\text{urb}}(x) + S(x)\n\\end{aligned}\n$$.\n\nThe second model (`mod_pca`) replaces the continuous covariates with their first principal component $\\text{PC}_1(x)$, allowing for a spline above 0.75. The model becomes:\n\n$$\n\\log\\left\\{\\frac{p(x)}{1-p(x)}\\right\\} = \\beta_0 + \n\\beta_1 \\text{PC}_1(x) + \n\\beta_2 \\max\\{\\text{PC}_1(x) - 0.75,0\\} +\n\\beta_3 d_{\\text{urb}}(x) + S(x)\n$$\n\nThis formulation allows us to assess whether the dimensionality reduction via PCA retains the essential variation in environmental risk while simplifying the model structure.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Model with all the covariates as separate predictors\nmod_all_cov <-\nglgpm(positive ~\n    precip +\n    ndvi +\n    lst_c + pmax(lst_c - 33, 0) +\n    elev + pmax(elev - 400, 0) +\n    humidity + pmax(humidity - 65, 0) +\n    built_up + gp(),\n    den = examined,\n    data = mlw_sf,\n    family = \"binomial\")\n\n# Model with all the covariates (except `built_up`)\n# combined into PC1 which is then used as predictor\nmod_pca <-\n  glgpm(positive ~\n          PC1 + pmax(PC1 - 0.75, 0) +\n          built_up + gp(),\n        den = examined,\n        data = mlw_sf,\n        family = \"binomial\")\n```\n:::\n\n\n\n\n\n\n\n\nAfter fitting the two models, when can then compare the summaries of the fits.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(mod_all_cov)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCall:\nglgpm(formula = positive ~ precip + ndvi + lst_c + pmax(lst_c - \n    33, 0) + elev + pmax(elev - 400, 0) + humidity + pmax(humidity - \n    65, 0) + built_up + gp(), data = mlw_sf, family = \"binomial\", \n    den = examined)\n\nBinomial geostatistical linear model\nLink: canonical (logit) \nInverse link function = 1 / (1 + exp(-x)) \n \n'Lower limit' and 'Upper limit' are the limits of the 95% confidence level intervals\n\nRegression coefficients\n                          Estimate Lower limit Upper limit      StdErr  z.value\n(Intercept)            -4.1484e+01 -5.4098e+01 -2.8871e+01  6.4356e+00  -6.4461\nprecip                  3.6000e-01  2.0822e-01  5.1178e-01  7.7441e-02   4.6487\nndvi                    5.1991e+00  4.3228e+00  6.0754e+00  4.4710e-01  11.6285\nlst_c                   9.9929e-02  6.9301e-02  1.3056e-01  1.5626e-02   6.3948\npmax(lst_c - 33, 0)     3.0237e-01  2.5342e-01  3.5132e-01  2.4973e-02  12.1076\nelev                    1.0984e-02  1.0581e-02  1.1386e-02  2.0527e-04  53.5074\npmax(elev - 400, 0)    -1.1358e-02 -1.1732e-02 -1.0984e-02  1.9088e-04 -59.5030\nhumidity                4.7098e-01  4.4719e-01  4.9476e-01  1.2135e-02  38.8129\npmax(humidity - 65, 0) -6.8110e-01 -7.0309e-01 -6.5912e-01  1.1217e-02 -60.7232\nbuilt_up               -6.8574e-01 -7.4216e-01 -6.2931e-01  2.8788e-02 -23.8200\n                         p.value    \n(Intercept)            1.148e-10 ***\nprecip                 3.340e-06 ***\nndvi                   < 2.2e-16 ***\nlst_c                  1.607e-10 ***\npmax(lst_c - 33, 0)    < 2.2e-16 ***\nelev                   < 2.2e-16 ***\npmax(elev - 400, 0)    < 2.2e-16 ***\nhumidity               < 2.2e-16 ***\npmax(humidity - 65, 0) < 2.2e-16 ***\nbuilt_up               < 2.2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nSpatial Gaussian process\nMatern covariance parameters (kappa=0.5)\n                     Estimate Lower limit Upper limit\nSpatial process var.  0.95284     0.91937      0.9875\nSpatial corr. scale  15.60594    15.02071     16.2140\nVariance of the nugget effect fixed at 0\n\nLog-likelihood: 13.833\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(mod_pca)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCall:\nglgpm(formula = positive ~ PC1 + pmax(PC1 - 0.75, 0) + built_up + \n    gp(), data = mlw_sf, family = \"binomial\", den = examined)\n\nBinomial geostatistical linear model\nLink: canonical (logit) \nInverse link function = 1 / (1 + exp(-x)) \n \n'Lower limit' and 'Upper limit' are the limits of the 95% confidence level intervals\n\nRegression coefficients\n                     Estimate Lower limit Upper limit    StdErr  z.value\n(Intercept)         -0.496575   -0.595285   -0.397866  0.050363  -9.8600\nPC1                  0.258180    0.194448    0.321912  0.032517   7.9399\npmax(PC1 - 0.75, 0) -1.076688   -1.170656   -0.982719  0.047944 -22.4572\nbuilt_up            -0.542019   -0.654257   -0.429781  0.057265  -9.4650\n                      p.value    \n(Intercept)         < 2.2e-16 ***\nPC1                 2.024e-15 ***\npmax(PC1 - 0.75, 0) < 2.2e-16 ***\nbuilt_up            < 2.2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nSpatial Gaussian process\nMatern covariance parameters (kappa=0.5)\n                     Estimate Lower limit Upper limit\nSpatial process var.   2.0008      1.7939      2.2316\nSpatial corr. scale   30.6995     27.8239     33.8724\nVariance of the nugget effect fixed at 0\n\nLog-likelihood: 15.90143\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nIn the output above, we see that, compared to the model using all covariates as separate predictors, the model including only PC1 exhibits both a larger estimated spatial correlation scale and higher spatial variance. This indicates that replacing the original covariates with PC1 captures a smaller proportion of the spatial variation in prevalence, leaving the spatial Gaussian process to account for more of the structured residual variability.\n\nWe then compare the predicted prevalence from each model using a regular 5 by 5 km grid covering the whole of Malawi, and display the results in @fig-pred_models. The maps show broadly similar spatial patterns, with both models identifying areas of high and low predicted prevalence in the southern region of the country. However, these visual comparisons do not allow us to determine which model performs better. We address this question in the next stage of the analysis by formally assessing the calibration and sharpness of the predictions generated by each model.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a 5 by 5 regular grid \ngrid_mlw <- create_grid(mlw_admin0_sf, spat_res = 5)\n\n# Extract the covariates over the grid\nr_covs <- terra::project(r_covs, paste0(\"epsg:\",mlw_crs))\npc1_rast <- terra::project(pc1_rast, paste0(\"epsg:\",mlw_crs))\n\npredictors <- cbind(terra::extract(r_covs,  st_coordinates(grid_mlw)),\n                    terra::extract(pc1_rast,  st_coordinates(grid_mlw)))\n\n# Prevalence prediction over the grid for the two fitted models \npred_all_cov <- pred_over_grid(mod_all_cov,\n                               grid_pred = grid_mlw,\n                               predictors = predictors)\n\npred_pca <- pred_over_grid(mod_pca,\n                           grid_pred = grid_mlw,\n                           predictors = predictors)\n\npred_all_cov_prev <- pred_target_grid(pred_all_cov,\n                                      f_target = list(prev = function(x) exp(x)/(1+exp(x))))\n\npred_pca_prev <- pred_target_grid(pred_pca,\n                             f_target = list(prev = function(x) exp(x)/(1+exp(x))))\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npar(mfrow = c(1,2))\nplot(pred_all_cov_prev, which_target = \"prev\", which_summary = \"mean\",\n     main = \"Model: 'all_cov'\", range = c(0,1))\nplot(pred_pca_prev, which_target = \"prev\", which_summary = \"mean\",\n     main = \"Model: 'pca'\", range = c(0,1))\n```\n\n::: {.cell-output-display}\n![Predictive mean of prevalence obtained from geostatistical models using all covariates ('all_cov') versus the first principal component ('pca') of the standardized continuous environmental variables.](05_case-studies_files/figure-pdf/fig-pred_models-1.pdf){#fig-pred_models fig-align='center' fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n\n\n### Comparison of the predictive performance between models\n\nTo evaluate predictive performance, we use three spatially distinct hold-out test sets corresponding to the Northern, Central, and Southern regions of Malawi, as illustrated in @fig-mlw-tests. These were constructed using the `assess_pp` function with `method = \"cluster\"` and `fold = 3`, ensuring geographically stratified cross-validation.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nassess_pred_mlw <-\nassess_pp(list(all_cov = mod_all_cov,\n               pca = mod_pca),\n          method = \"cluster\",\n          which_metric = c(\"AnPIT\", \"CRPS\"),\n          iter = 1,\n          fold = 3)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![Geographic distribution of sampled locations in Malawi, coloured by their assignment to one of three cross-validation test sets.](figures/mlw_tests.png){#fig-mlw-tests width=80%}\n:::\n:::\n\n\n\n\n\n\n\n\nThe CRPS score shows that the model including all environmental covariates achieves better predictive accuracy across all test sets. Specifically, it yields a lower average CRPS. This improvement is consistent across the three hold-out data, with particularly notable gains in Test Set 1. Additionally, the non-randomized probability integral transform (AnPIT) plot, shown in @fig-pit-mlw, demonstrates that the full covariate model is better calibrated: its cumulative distribution curves lie closer to the identity line, suggesting that the predicted probabilities align more closely with observed prevalence.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_AnPIT(assess_pred_mlw, mode = \"all\")\n\nsummary(assess_pred_mlw)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSummary of Cross-Validation Scores\n----------------------------------\nModel: all_cov\n  Test Set 1:\n    CRPS: 1.9452\n  Test Set 2:\n    CRPS: 2.1383\n  Test Set 3:\n    CRPS: 1.5148\n  Overall average across test sets:\n    CRPS: 1.9067\n\nModel: pca\n  Test Set 1:\n    CRPS: 2.8064\n  Test Set 2:\n    CRPS: 2.5029\n  Test Set 3:\n    CRPS: 1.9321\n  Overall average across test sets:\n    CRPS: 2.6220\n```\n\n\n:::\n\n::: {.cell-output-display}\n![Plot of the average non-randomized probability integral transform (AnPIT) function to assess the calibration of the two geostatistical models ('all_cov' and 'pca') for the malaria prevalence data from Malawi.](05_case-studies_files/figure-pdf/fig-pit-mlw-1.pdf){#fig-pit-mlw fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n\n\n### Summary and conclusions\n\nIn this case study, we have walked through the full pipeline of conducting a geostatistical analysis of malaria prevalence using Malaria Indicator Survey data from Malawi. We began by downloading geo-referenced survey data from the `malariaAtlas` R package and retrieving relevant environmental covariates from Google Earth Engine. These covariates, selected for their mechanistic relevance to malaria transmission, were processed, clipped to the national boundary, and extracted at survey locations to be used as predictors in subsequent modelling.\n\nA critical step in the analysis involved the exploration of relationships between environmental conditions and malaria prevalence. Through scatterplots and spline fits, we identified key nonlinearities in variables such as temperature, elevation, and humidity, which informed the functional form of covariate effects in the regression model. This exploratory work is essential not only for model formulation but also for understanding the ecological underpinnings of disease risk.\n\nTo address potential collinearity and reduce the complexity of the model, we also illustrated the use of PCA as a method for dimensionality reduction. The first principal component (PC1) captured a dominant environmental gradient, summarizing variation across temperature, humidity, elevation, and vegetation, which was then used as a composite predictor in a reduced model. A simpler alternative is to let the data guide you through stepwise selection based on p-values—for example, adding or removing covariates until all retained terms meet a preset significance threshold. When the pool of candidate predictors is large relative to the sample size, however, stepwise methods can become unstable and over-fit; in such cases penalised approaches (e.g. ridge, lasso) or resampling-based strategies are usually preferred. A thorough discussion of these issues, with practical recommendations, is given in Section 4.7 of @harrell2015.\n\nWe compared two geostatistical models: one using all environmental covariates as separate predictors (with spline terms for nonlinear effects), and another using PC1 as a summary predictor. Cross-validation based on geographically stratified folds revealed that the full model was better calibrated and achieved sharper predictions, as measured by lower CRPS and AnPIT curves closer to the identity line.\n\nWe encourage the reader to explore Exercise 2 at the end of this chapter, where you will investigate whether including a second principal component (PC2) alongside PC1 leads to improved predictive performance. This offers an opportunity to assess whether PCA-based dimensionality reduction can match or exceed the predictive accuracy of models that include all covariates, while potentially offering greater parsimony.\n\n## Mapping the vector index for West Nile Virus in the Sacramento Metropolitan Area, United States {#sec-wnv}\n\nIn this section, we analyse entomological surveillance data on *Culex pipiens* in the Sacramento Metropolitan Area (SMA), California, from 2015 to 2021. *Cx. pipiens* is one of the primary vectors of West Nile virus (WNV) in North America [@petersen2013wnv; @kramer2007wnv]. WNV is a mosquito borne flavivirus sustained in an enzootic cycle, that is, persistent circulation of the virus within non human animal populations, primarily birds, in a defined geographic area. Transmission is maintained between *Culex* mosquitoes and birds, while humans and other mammals are incidental dead end hosts that do not contribute to further transmission. Most human infections are asymptomatic, a minority present with febrile illness, and a small proportion develop neuroinvasive disease [@petersen2013wnv]. Surveillance of both vector abundance and WNV infection prevalence is therefore important for anticipating human risk and guiding public health interventions.\n\nIn this analysis, we quantify local entomological risk using the vector index (VI), defined as\n$$\n\\text{VI} \\;=\\; \\text{abundance} \\times \\text{infection prevalence}.  \n$$ {#eq-vi}\nHere, *abundance* is the mean number of female mosquitoes collected per trap night, and *infection prevalence* is the estimated proportion of mosquitoes infected with WNV in the vector population. In practice, prevalence is inferred from pooled PCR testing using maximum likelihood estimators for pooled samples [@cdc_wnv_guidelines_2024]. Many operational analyses also report the minimum infection rate and apply either the maximum likelihood estimate or the minimum infection rate when computing the vector index [e.g., @bolling2009vi; @jones2011vi]. In this section, we extend these approaches using model-based geostatistics.\n\nIn what follows, we model abundance and infection prevalence for *Cx. pipiens* as two independent processes and combine the resulting estimates to obtain VI. We return to this assumption and other limitations of the analysis in @sec-summary-wnv.\n\n\n### Modelling the abundance of *Culex pipiens* {#sec-abund-model}\n\nWe begin by loading the necessary libraries and the data derived from the `vectorsurvR` package in R. The original datasets, `sample_pools` and `sample_collections`, contain mosquito surveillance data from California, including species identification, collection date, location, pathogen testing results, trap type, and trapping effort. For this case study, these have been processed to produce `abund_sma` in the `RiskMap` package, which summarises the abundance of female *Culex pipiens* within the Sacramento Metropolitan Area (SMA).\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(list = ls())\n\nlibrary(ggplot2)\nlibrary(patchwork)\n\ndata(abund_sma)\nstr(abund_sma)\n## 'data.frame':\t1551 obs. of  6 variables:\n##  $ lon          : num  -121 -121 -121 -121 -121 ...\n##  $ lat          : num  38.9 38.8 38.9 38.8 38.9 ...\n##  $ total_females: int  1 36 6 31 1 1 1 1 1 4 ...\n##  $ date         : Date, format: \"2015-01-02\" \"2015-01-02\" ...\n##  $ trap_nights  : int  15 15 15 8 8 8 8 6 6 6 ...\n##  $ trap_type    : chr  \"NJLT\" \"NJLT\" \"NJLT\" \"GRVD\" ...\n```\n:::\n\n\n\n\n\n\n\nThe outcome variable for this analysis is `total_females`, which records the total number of *Cx. pipiens* captured in a single trap. The variable `trap_nights` indicates the number of nights the trap was deployed and is used to account for variation in sampling effort across traps. The dataset also records the type of trap used (`trap_type`), which can influence capture rates. Trap types include New Jersey Light Traps (`NJLT`), Gravid Traps (`GRVD`), Mosquito Magnet Traps (`MMT`), BG-Sentinel Traps (`BGSENT`), $\\text{CO}_2$-baited traps (`CO2`), Backpack aspirators (`BACKPACK`), Lockyer traps (`LCKR`), and Ovitraps (`OVI`). These traps differ in their mode of attraction: for example, light traps attract host-seeking females using light, gravid traps target egg-laying females with an infusion lure, $\\text{CO}_2$-baited and BG-Sentinel traps mimic host cues through carbon dioxide and human scent, and backpack or hand-collection methods are opportunistic. Based on average catch per trap-night, we group these into low-yield traps (Backpack, Lockyer, New Jersey Light Trap, Ovitrap), moderate-yield traps (Gravid Trap, Mosquito Magnet), and high-yield traps ($\\text{CO}_2$-baited and BG-Sentinel), providing a more interpretable classification for analysing trap efficiency in subsequent modelling. We thus create the variable `trap_group` for later use in the model fitting as follows.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabund_sma <- abund_sma %>%\n  mutate(trap_group = case_when(\n    trap_type %in% c(\"BACKPACK\", \"LCKR\", \"NJLT\", \"OVI\") ~ \"low yeild\",\n    trap_type %in% c(\"GRVD\", \"MMT\") ~ \"moderate yeild\",\n    trap_type %in% c(\"CO2\", \"BGSENT\") ~ \"high yield\"\n  ))\n```\n:::\n\n\n\n\n\n\n\n\nTo provide spatial context, we use the `rgeoboundaries` package to download second-level administrative boundaries (ADM2) for the United States. We extract the boundaries for Placer, El Dorado and Sacrament counties which make up the SMA.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rgeoboundaries)\n\n# Get California ADM2 units and filter to relevant counties\nca_counties <- geoboundaries(\"United States of America\", adm_lvl = \"ADM2\")\nsma_names <- c(\"Sacramento\", \"Placer\", \"El Dorado\")\nsma_boundaries <- ca_counties[ca_counties$shapeName %in% sma_names, ]\n\n```\n:::\n\n\n\n\n\n\n\n\nGiven the time span of the data, it is important to consider the potential for temporal variation in mosquito abundance and infection prevalence. Changes in environmental conditions, climate, or vector control efforts may lead to substantial year-to-year fluctuations in mosquito populations. Additionally, if different geographic areas were sampled in different years, this could introduce spatial confounding, making it difficult to disentangle spatial from temporal effects.\n\nThe top panel of @fig-wnv-years reveals that while some spatial variation in sampling locations is present across years, there remains sufficient geographic overlap to enable estimation of temporal trends in mosquito counts. Overall, *Cx. pipiens* abundance declines over time, although the trend is more pronounced in high-yield traps, while moderate- and low-yield traps exhibit a more variable pattern. The decline in *Cx. pipiens* likely reflects two key drivers: reduced availability of aquatic breeding sites due to drought, and intensified vector control efforts. @bhattachan2023drought reported that *Cx. pipiens* populations in southern California dropped by about $40%$ during the 2012–2016 drought, linked to water-use restrictions that limited larval habitat in storm drains and catch basins. At the same time, vector control districts expanded targeted interventions. For example, the Sacramento–Yolo district treated over 160,000 drains in 2018 alone [@sacramento2018annual], and the statewide response plan formalised such practices as part of integrated mosquito management [@cdph2025response]. For these reasons, our model shall include a covariate for year, with a log-linear effect on the mean number of *Cx. pipiens*, under the expectation that abundance will show a decreasing trend over time.\n\n\n\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Creation of the variable year\nabund_sma$year <- as.numeric(substr(abund_sma$date, 1, 4))\n\n# bbox for coord_sf limits\nbb <- st_bbox(sma_boundaries)\nabund_sma <- st_as_sf(abund_sma, coords = c(\"lon\",\"lat\"), crs = 4326, remove = FALSE)\n\n\n# Panel 1: faceted map, colored by trap_group (scales fixed!)\np_locs <- ggplot() +\n  geom_sf(data = sma_boundaries, fill = NA, color = \"black\", linewidth = 0.3) +\n  geom_sf(data = abund_sma, color = \"black\", alpha = 0.85, size = 0.9) +\n  coord_sf(xlim = c(bb[\"xmin\"], bb[\"xmax\"]), ylim = c(bb[\"ymin\"], bb[\"ymax\"])) +\n  facet_wrap(~ year, ncol = 4) +\n  theme_minimal() +\n  labs(title = \"Trap locations by year\") +\n  theme(\n    strip.text = element_text(size = 13, face = \"bold\"),\n    plot.title = element_text(size = 16, face = \"bold\", hjust = 0.5),\n    axis.text = element_blank(),\n    axis.ticks = element_blank()\n  )\n\n# Panel 2: average mosquitoes per trap by year & trap_group\nannual_summary <- abund_sma %>%\n  group_by(year, trap_group) %>%\n  summarise(\n    total_mosquitoes = sum(total_females, na.rm = TRUE),\n    total_traps = n(),\n    mosq_per_trap = ifelse(total_traps > 0, total_mosquitoes / total_traps, NA_real_),\n    .groups = \"drop\"\n  )\n\np_pertrap <- ggplot(annual_summary,\n                    aes(x = factor(year), y = mosq_per_trap, fill = trap_group)) +\n  geom_col(position = position_dodge(width = 0.7), width = 0.7) +\n  theme_minimal() +\n  labs(title = \"Average mosquitoes per trap by year and trap group\",\n       x = \"Year\", y = \"Mosquitoes per trap\", fill = \"Trap group\") +\n  theme(\n    plot.title = element_text(size = 14, face = \"bold\", hjust = 0.5),\n    axis.title = element_text(size = 12),\n    axis.text = element_text(size = 11)\n  )\n\n# Combine\n(p_locs / p_pertrap) +\n  plot_layout(heights = c(3, 1))\n```\n\n::: {.cell-output-display}\n![Spatial and temporal overview of *Cx. pipiens* surveillance in the Sacramento Metropolitan Area from 2015 to 2021. The top panel shows the spatial distribution of trap locations for each year. The bottom panel displays the annual average number of mosquitoes captured per trap by trap group, illustrating variation in abundance over time.](05_case-studies_files/figure-pdf/fig-wnv-years-1.pdf){#fig-wnv-years fig-align='center' fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n\n\nIn our analysis, we first assess whether there is residual spatial correlation in mosquito counts by fitting the following Poisson mixed-effects model. Let $Y_i$ denote the number of trapped female *Cx. pipiens* at location $x_i$ and year $t_i$. Conditionally on independent and identically distributed zero-mean Gaussian random effects $Z_i \\sim \\mathcal{N}(0, \\sigma^2)$, we assume:\n$$\nY_i \\mid Z_i \\sim \\text{Poisson}(m_i\\lambda_i),\n$$\nwhere $m_i$ is the number of nights during which the trap has been deployed, and $\\lambda_i$ is the average number of $Cx. pipiens$ per trap-night, which we model as:\n$$\n\\begin{aligned}\n\\log\\{\\lambda_i\\} = & \n\\sum_{j=1}^3 d_{j}(x_i, t_i) \\beta_j + \\beta_4 t_i + \nZ_i \\\\\\\\\n=& \\: \\mu_i + Z_i,\n\\end{aligned}\n$$ {#eq-wnv-counts}\nwhere the $d_{j}(x_i, t_i)$ are binary indicators for the type of trap ($j=1$ corresponding to \"high-yield\", $j=2$ to \"moderate-yield\" and $j=3$ to \"low-yield\") and $\\mu_i = \\sum_{j=1}^3 d_{j}(x_i, t_i) \\beta_j + \\beta_4 t_i$. \nWe then fit this model using the `glmer` function from the `lme4` package as follows.\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabund_sma$loc <- 1:nrow(abund_sma)\n\n# In the fit, we scale the variable year to help convergence\nglmer_wvn <- glmer(total_females ~ -1 + trap_group + scale(year) + offset(log(trap_nights)) + (1 | loc),\n                   data = abund_sma, family = poisson,\n                   nAGQ = 100)\nsummary(glmer_wvn)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGeneralized linear mixed model fit by maximum likelihood (Adaptive\n  Gauss-Hermite Quadrature, nAGQ = 100) [glmerMod]\n Family: poisson  ( log )\nFormula: \ntotal_females ~ -1 + trap_group + scale(year) + offset(log(trap_nights)) +  \n    (1 | loc)\n   Data: abund_sma\n\n      AIC       BIC    logLik -2*log(L)  df.resid \n   5715.5    5742.2   -2852.7    5705.5      1546 \n\nScaled residuals: \n     Min       1Q   Median       3Q      Max \n-0.81365 -0.27049 -0.02063  0.10058  0.40034 \n\nRandom effects:\n Groups Name        Variance Std.Dev.\n loc    (Intercept) 2.356    1.535   \nNumber of obs: 1551, groups:  loc, 1551\n\nFixed effects:\n                         Estimate Std. Error z value Pr(>|z|)    \ntrap_grouphigh yield      1.68272    0.06643  25.331  < 2e-16 ***\ntrap_grouplow yeild      -0.41146    0.08736  -4.710 2.48e-06 ***\ntrap_groupmoderate yeild  0.29882    0.06762   4.419 9.92e-06 ***\nscale(year)              -0.20370    0.04206  -4.843 1.28e-06 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nCorrelation of Fixed Effects:\n            trp_grphy trp_grply trp_grpmy\ntrp_grplwyl  0.006                       \ntrp_grpmdry -0.013     0.002             \nscale(year) -0.119    -0.014     0.150   \n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nThe model summary indicates that, as expected, average mosquito counts decline over time. The effects associated with the different levels of `trap_group` also follow expectations, with high-yield traps having the highest average counts, followed by moderate- and low-yield traps. The relatively large estimate of the variance $\\sigma^2$ of the random effect $Z_i$ suggests substantial extra-Poisson variation between traps that is not explained by the yearly decline and the type of trap. \n\nWe then use the empirical variogram computed on the estimated $Z_i$ to assess the presence of residual spatial correlation. \n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extracting the estimates of the random effects\nwnv_summary$Z_hat <- ranef(glmer_wvn)$loc[,1]\n\n# Computing the empirical variogram\nvariogram_wnv <- \ns_variogram(data = wnv_summary, \n            variable = \"Z_hat\",\n            n_permutation = 1000,\n            scale_to_km = TRUE,\n            bins = seq(0,10, length = 15))\n```\n:::\n\n\n\n\n\n\n\nWe plot the empirical variogram and add the envelope generated under the assumption of absence of spatial correlation.\n\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot_s_variogram(variogram_wnv, plot_envelope = TRUE)\n```\n\n::: {.cell-output-display}\n![Empirical variogram (black line) for based on the random effects fitted from the model in @eq-wnv-counts. The shaded blue area correspond to the envelope of spatial independence at 95% confidence level generated using a permuation test. ](05_case-studies_files/figure-pdf/fig-wnv-variogram-1.pdf){#fig-wnv-variogram fig-align='center' fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nThe empirical variogram shown in @fig-wnv-variogram lies entirely within the simulation envelope, indicating no detectable spatial correlation in the residuals. This lack of evidence may be due to the fact that mosquito abundance is influenced by very local environmental conditions such as vegetation, drainage, or breeding site availability, which vary at spatial scales smaller than 1 km. Since only a few trap locations in the dataset are spaced closely enough to capture such fine-scale variation, the analysis may lack the resolution needed to detect spatial dependence. Therefore, although a geostatistical model is not justified in this case, we can still pursue our objective of estimating the average number of mosquitoes at the sampled locations using the model in @eq-wnv-counts. \n\nThe principles used in this case to derive the predictive distribution of $\\lambda(x_i)$, the expected number of mosquitoes at a sampled location $x_i$, are similar to those applied in geostatistical models. However, they take a simplified form here because we do not need to account for spatial correlation. The predictive distribution is given by:\n$$\n\\left[\\lambda(x_i) \\:\\middle | \\: Y_i = y_i \\right] = \\int [Z_i] \\, [Y_i \\mid Z_i] \\, dZ_i\n$$ {#eq-pred-distr}\nIn this expression, $[Z_i]$ denotes the density of a Gaussian distribution with mean zero and variance $\\sigma^2$, and $[Y_i \\mid Z_i]$ is the likelihood from a Poisson model with mean $\\lambda(x_i)$. The integral in @eq-pred-distr can be computed numerically in R with relative efficiency. This approach also allows for direct simulation from the predictive distribution, enabling us to compute any desired summary statistics.\n\nFor this analysis, we use a custom function called `simulate_random_effects`, which can be copied from @sec-sim-re and pasted into an R script, as it is not included in the `RiskMap` package. Further details of its implementation are provided in @sec-sim-re; here, we focus solely on the analysis.\n\nHence, we first simulate 1000 samples from the predictive distribution of $Z_i$ and denote those by $Z_i^{(j)}$, for $i=1,\\ldots,598$, and $j=1\\ldots,1000$.\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn_samples <- 1000\nsamples_z <- simulate_random_effects(glmer_wvn, n_sim = n_samples)\n```\n:::\n\n\n\n\n\n\n\n\nWe then obtain predictive samples for $\\lambda(x_i)$ by applying the exponential transformation to the linear predictor $\\hat{\\mu}_i + Z_{i}^{(j)}$, where in $\\hat{\\mu}_i$ we have plugged in the maximum likelihood estimates of the regression coefficients. \n\n\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n\n\nThe predictions shown in @fig-mosq-predictions indicate that the pattern of the mean number of mosquitoes across sampled locations is broadly comparable across time.\n\n\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Create dataframe\nmosq_df <- data.frame(\n  id = 1:nrow(abund_sma),\n  mean = mosq_mean,\n  lower = mosq_lower,\n  upper = mosq_upper\n)\n\n# Adding trap_group and year\nmosq_df$trap_group <- abund_sma$trap_group[match(mosq_df$id, abund_sma$loc)]\nmosq_df$year <- abund_sma$year[match(mosq_df$id, abund_sma$loc)]\n\n# Rearranging the data-frame in increasing order based\n# on the mean number of mosquitoes\n# by year and trap group\n\nmosq_df <- mosq_df %>%\n  group_by(year, trap_group) %>%\n  arrange(mean, .by_group = TRUE) %>%\n  mutate(x_order = row_number()) %>%\n  ungroup()\n\nlibrary(scales)  # Used for reporting the y-axis on the log-scale\n\nggplot(mosq_df, aes(x = x_order, y = mean,\n                    color = trap_group, fill = trap_group, group = trap_group)) +\n  geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.20, linewidth = 0) +\n  geom_line(linewidth = 0.9) +\n  scale_y_log10(\n    breaks = c(1, 10, 100, 1000),\n    labels = label_number()\n  ) +\n  facet_wrap(~year, scales = \"free_x\") +\n  labs(x = \"Locations (ordered within trap group)\",\n       y = \"Predicted no. mosquitoes (per trap-night)\",\n       color = \"Trap group\", fill = \"Trap group\") +\n  theme_minimal()\n\n```\n\n::: {.cell-output-display}\n![Predictive mean number of mosquitoes per trap-night for each location with 95% prediction intervals, stratified by year and trap group. Within each panel, locations are ordered by increasing predicted mean abundance. Shaded areas represent 95% prediction intervals for the number of mosquitoes at sampled locations. The y-axis is on a log scale, with tick labels shown on the original scale.](05_case-studies_files/figure-pdf/fig-mosq-predictions-1.pdf){#fig-mosq-predictions fig-align='center' fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n\n\nTo understand whether we can trust the inferences shown in @fig-mosq-predictions, we use the AnPIT graphical check as used in the previous case studies. Since we are not using a geostatistical model in this case, we will use a simplified implementation of the AnPIT for the Poisson mixed model fitted in this section. The function that we use to compute the AnPIT is called `anpit_wnv` and has been implemented specifically for this case study. For more details on its implementation, read @sec-nonspat-anpit. \n\n\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwnv_anpit_res <- anpit_wnv(glmer_wvn, test_prop = 0.30, nsim = 10000)\n```\n:::\n\n\n\n\n\n\n\nIn the code above the AnPIT is computed using a test-set corresponding to $30\\%$ of the original data-set. The number of simulation used to approximate the AnPIT is set to 1000. Finally, we plot the results.\n\n\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot_anpit(wnv_anpit_res)\n```\n\n::: {.cell-output-display}\n![Average non-randomized probability integral transform (AnPIT) for the Poisson mixed model specified in @eq-wnv-counts. The dahsed line corresponds to the identity line.](05_case-studies_files/figure-pdf/fig-wnv-anpit-1.pdf){#fig-wnv-anpit fig-align='center' fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n\n\nThe results shown in @fig-wnv-anpit an AnPIT curve from the fitted Poisson mixed model in @fig-wnv-anpit that closely follows the identity line. Hence, we can conclude that we find no evidence against the compatibility of the model in @fig-wnv-anpit with the data. \n\n### Modelling West Nile virus infection with pooled mosquito testing {#sec-wnv-model}\n\nPooled testing is widely used in mosquito surveillance. Rather than testing each mosquito individually for a pathogen, multiple mosquitoes collected from the same location and week are combined into a single pool and assayed by PCR. The test returns positive if at least one mosquito in the pool is infected and negative otherwise. This approach greatly reduces laboratory time and costs, but statistical analysis must account for variation in pool size, as larger pools have a higher probability of testing positive even if the underlying infection risk per mosquito is low.\n\nWe illustrate this using West Nile virus (WNV) PCR results from pools of female *Culex pipiens* collected in the Sacramento Metropolitan Area, available in the `infect_sma` data set of the `RiskMap` package.\n\nLet $k_i$ be the number of mosquitoes in pool $i$. Define the binary outcome $Y_i=1$ if the PCR test for pool $i$ is positive and $Y_i=0$ otherwise. Conditional on a stationary and isotropic spatial Gaussian process $S(x_i)$, the probability that pool $i$ is positive is  \n$$\nP(Y_i=1\\mid S(x_i))=1-\\left[1-p(x_i)\\right]^{k_i},\n$$ {#eq-wnv-pos-model}\nwhere $p(x_i)$ is the probability that an individual mosquito at location $x_i$ is infected with WNV. We model $p(x_i)$ using a logit-linear form  \n$$\n\\log\\left\\{\\frac{p(x_i)}{1-p(x_i)}\\right\\}=\\beta+S(x_i),\n$$ {#eq-wnv-lp}\nwhich explicitly incorporates the dependence of the pool positivity probability on pool size $k_i$.\n\nWe must emphasize that in the `infect_sma` data set the pool sizes $k_i$ are not taken directly from laboratory records but are estimated. For each pool, mosquito collections from nearby locations in the same epidemiological week and within a given spatial radius, for example 2 km, are identified. The total number of female mosquitoes from these nearby collections, denoted $T_{\\text{near}}$, is divided by the number of pools formed from the same nearby collections in that week, denoted $m_{\\text{near}}$, to obtain an estimate of pool size. The estimated pool size is therefore  \n$$\n\\widehat{k}_i=\\text{round}\\left(\\max\\{1,T_{\\text{near}}/m_{\\text{near}}\\}\\right),\n$$\nand a default conservative value, such as 25, is used if no nearby collections are available.\n\nThe data comprise 596 responses, of which only 18 pools test positive. This very low prevalence constrains our modelling choices, for example by limiting the feasibility of incorporating temporal dynamics. As a result, the model in @eq-wnv-pos-model represents the simplest specification that can still capture spatial correlation, under the simplifying assumption that WNV risk remains relatively stable over the study period. Furthermore, because there is only a single binary outcome per location, overdispersion cannot occur (see box “Why Bernoulli extra‐variation does not exist” in Section 5.1.1 of @diggleBook2019), and the empirical variogram provides limited value for assessing spatial correlation due to its high uncertainty in this context. We therefore proceed directly to fitting a geostatistical model and assess the estimate of the spatial correlation parameter, which quantifies the strength and range of spatial dependence in the data.\n\nWe then proceed in R as follows. We first load the data and convert them into an `sf` object with the appropriate UTM projection. \n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(infect_sma)\n\ninfect_sma <- st_as_sf(infect_sma, coords = c(\"lon\", \"lat\"), crs = 4326)\nwnv_crs <- propose_utm(infect_sma)\ninfect_sma <- st_transform(infect_sma, wnv_crs)\n```\n:::\n\n\n\n\n\n\n\n\nWe define the inverse link function based on @eq-wnv-pos-model and @eq-wnv-lp.\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninvlink_wnv <- function(x) 1-(1-exp(x)/(1+exp(x)))^infect_sma$est_pool_n\n```\n:::\n\n\n\n\n\n\n\n\nWe then fit the model by passing the inverse link function to the argument `invlink` within the `glgpm` function. \n\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ninf_fit <-\n  glgpm(wnv_pos ~ gp(lon,lat),\n        crs = wnv_crs,\n        family = \"binomial\",\n        invlink = invlink_wnv,\n        data=infect_sma)\n```\n:::\n\n\n\n\n\n\n\nFinally, we examine the the summary of the fitted model. \n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(inf_fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCall:\nglgpm(formula = wnv_pos ~ gp(lon, lat), data = infect_sma, family = \"binomial\", \n    invlink = invlink_wnv, crs = wnv_crs, par0 = coef(inf_fit), \n    start_pars = coef(inf_fit))\n\nBinomial geostatistical linear model\nLink: custom \nInverse link function = 1 - (1 - exp(x)/(1 + exp(x)))^infect_sma$est_pool_n \n \n'Lower limit' and 'Upper limit' are the limits of the 95% confidence level intervals\n\nRegression coefficients\n            Estimate Lower limit Upper limit  StdErr z.value  p.value    \n(Intercept)  -4.9648     -7.0190     -2.9105  1.0481 -4.7369 2.17e-06 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nSpatial Gaussian process\nMatern covariance parameters (kappa=0.5)\n                     Estimate Lower limit Upper limit\nSpatial process var.   5.9851      1.5402      23.259\nSpatial corr. scale   24.5370      9.1354      65.905\nVariance of the nugget effect fixed at 0\n\nLog-likelihood: 0.4061681\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nThe fitted model indicates a substantial spatial residual component, with the estimated scale parameter corresponding to a practical range of approximately 70 km. This represents a long‐range correlation relative to the spatial extent of the study area.\n\nWe first carry out predictions over a regular grid covering the area of the data collection efforts from 2015 to 2021. To achieve this, we create a regular grid 250 meters within the convex hull boundaries obtained by the full set of locations sampled from 2015 to 2021 (see @fig-wnv-convex-hull).\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Compute convex hull\ngeom_union <- st_union(inf_fit$data_sf)\nchull_sf <- st_convex_hull(geom_union)\nchull_sf <- st_as_sf(data.frame(geometry = st_sfc(chull_sf)),\n                     crs = st_crs(inf_fit$data_sf))\n\n# Plot points and convex hull\nggplot() +\n  geom_sf(data = inf_fit$data_sf, color = \"blue\", size = 1) +\n  geom_sf(data = chull_sf, fill = NA, color = \"red\", linewidth = 1) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![Sampling locations of pooled mosquito collections testing for West Nile virus in the Sacramento Metropolitan Area (blue points) and their convex hull (red outline) defining the minimal polygon enclosing all sites.](05_case-studies_files/figure-pdf/fig-wnv-convex-hull-1.pdf){#fig-wnv-convex-hull fig-pos='H'}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngrid_pred_sac <- create_grid(chull_sf, spat_res = 0.25)\n\npred_S_inf <- pred_over_grid(inf_fit,\n                             grid_pred = grid_pred_sac)\n\npred_inf_grid <- pred_target_grid(pred_S_inf,\n                                  f_target = list(prev = function(x) exp(x)/(1+exp(x))))\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n\n\n@fig-wnv-pred-map displays the predictive mean of $p(x)$ over the regular grid. Overall, the predicted prevalence of WNV is very low across the study area, with a small zone in the south‐west showing a relatively higher value of approximately $0.40\\%$.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(pred_inf_grid,\"prev\")\n```\n\n::: {.cell-output-display}\n![Map of the predictive mean for the prevalence of West Nile Virus infection among female *Culex pipiens* mosquitoes in an area of the Sacramento Metropolitan Area.](05_case-studies_files/figure-pdf/fig-wnv-pred-map-1.pdf){#fig-wnv-pred-map fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n\n\nFinally, we predict the vector index as defined in @eq-vi. Because *Cx. pipiens* abundance and WNV infection prevalence have been modelled as independent processes, the predictions from the two models can be combined directly. Specifically, for each location in the `abund_sma` data set, we take predictive samples of WNV prevalence and multiply them by the corresponding predictive samples of the mean number of female *Cx. pipiens* per trap‐night. This yields predictive samples of the vector index, which can then be summarised or mapped as required. In R, this is implemented as follows.\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Converting the abund_sma into an sf object\nloc_pred <- st_as_sfc(st_transform(st_as_sf(abund_sma, coords = c(\"lon\",\"lat\"), crs = 4326), crs = wnv_crs))\n\n# Prediction of the sptial process S(x) over the locations of the \n# abund_sma data-set\npred_S_loc <- pred_over_grid(inf_fit, grid_pred = loc_pred)\n\n# Computation of the samples for West Nile Virus prevalence\nbeta_hat <- coef(inf_fit)$beta\nprev_inf_samples <- 1/(1+exp(-(beta_hat +\n                                 pred_S_loc$S_samples)))\n\n# Predictive samples for the vector index (VI)\nvi_samples <- mean_nmosq * prev_inf_samples\n\n# Calculate predictive summaries for VI\nvi_mean  <- apply(vi_samples, 1, mean, na.rm = TRUE)\nvi_lower <- apply(vi_samples, 1, quantile, probs = 0.025, na.rm = TRUE)\nvi_upper <- apply(vi_samples, 1, quantile, probs = 0.975, na.rm = TRUE)\n\n# Build dataframe directly from original abund_sma order\nvi_df <- data.frame(\n  id    = 1:nrow(abund_sma),\n  mean  = vi_mean,\n  lower = vi_lower,\n  upper = vi_upper,\n  trap_group = abund_sma$trap_group,\n  year       = abund_sma$year\n)\n\n# Order within (year, trap_group) by increasing mean\nvi_df <- vi_df %>%\n  group_by(year, trap_group) %>%\n  arrange(mean, .by_group = TRUE) %>%\n  mutate(x_order = dplyr::row_number()) %>%\n  ungroup()\n```\n:::\n\n\n\n\n\n\n\n\nSeveral U.S. programs consider a vector index (VI) of 0.75 or higher as indicative of likely human transmission and use this threshold to trigger intensified control measures [@cityofboulder_wnv_vectorindex_2025; @fortcollins_localdata_vi_2025; @fortcollins_wnv_program_manual_2014]. In @fig-vi, the dashed red line marks this operational threshold for elevated WNV risk. We observe that only in few instances before the year 2020 the predicted VI exceeded this threshold. We thus conclude that between 2015 and 2021 the risk for WNV based as measured by the VI was relatively low in the SMA.\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(vi_df,\n       aes(x = x_order, y = mean,\n           color = trap_group, fill = trap_group, group = trap_group)) +\n  geom_hline(yintercept = 0.75, linetype = \"dashed\", color = \"red\", linewidth = 0.8) +\n  geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.20, linewidth = 0) +\n  geom_line(linewidth = 0.9) +\n  scale_y_log10(\n    breaks = c(0.01, 0.1, 1),\n    labels = scales::label_number()\n  ) +\n  facet_wrap(~ year, scales = \"free_x\") +\n  labs(\n    x = \"Locations (ordered within trap group)\",\n    y = \"Vector index (infected mosquitoes per trap night)\",\n    title = \"West Nile Virus\",\n    color = \"Trap group\", fill = \"Trap group\"\n  ) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![Predicted vector index (infected mosquitoes per trap night) by location, stratified by year and trap group. Locations within each panel are ordered by increasing predicted VI. Shaded bands represent 95% prediction intervals. The dashed red line marks the 0.75 threshold commonly used in U.S. West Nile virus surveillance to indicate elevated transmission risk. The y-axis is on a log scale with labels shown on the original scale.](05_case-studies_files/figure-pdf/fig-vi-1.pdf){#fig-vi fig-align='center' fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n\n\n### Summary and conclusions {#sec-summary-wnv}\n\nIn this analysis, our predictive target was the vector index (VI) in @eq-vi. Our proposed modelling approach was based on the assumption that abundance and infection prevalence are two independent processes. Treating prevalence as independent of vector density is a practical simplification. It can be reasonable when the fraction of infected mosquitoes at a place and time is driven mainly by host infection dynamics, temperature dependent incubation, and mosquito age structure, whereas trap counts reflect local production, as well as catchability. \nAn interesting result of our analysis is that abundance showed no detectable residual spatial correlation, while infection prevalence did. The empirical variogram of random effects from the abundance model lay within the envelope in @fig-wnv-variogram, suggesting that remaining variation after accounting for year and trap group is dominated by micro scale heterogeneity and trap specific noise at distances smaller than those represented by the sampling design. In contrast, the infection model estimated a spatial scale of correlation that is large relative to the study area, and may be explained in terms of processes that operate over broader extents, such as movement and aggregation of avian reservoir hosts, shared urban landscape features, and temperature fields. However, as a result of the disparity in the scales of spatial dependence for the two processes and the inability of the model for abundance to interpolate at unobserved locations, we could only predict the VI at the observed locations of the abundance data.\n\nAll West Nile virus data analysed in this section originate from the `vectorsurvR` workflow and are simulated rather than observed in the field. The `vectorsurvR` package provides a framework for generating realistic mosquito surveillance data by mimicking the structure, spatial layout, and sampling frequency of actual surveillance programmes. Hence, the results presented here should not be used to draw scientific conclusions about West Nile virus in the Sacramento Metropolitan Area. In addition to this, pool size is a key input when analysing pooled infection outcomes (see Exercise 6 below) and strongly affects the predictive inferences in prevalence (see Exercise 6 below). In this case study we used an estimated pool size (denoted in the text above by $k_i$) rather than laboratory recorded counts, which adds additional uncertainty that we did not propagate. The results illustrate modelling steps, diagnostics, and how to combine components to obtain the vector index, which remains useful for pedagogical purposes. \n\n## Theory\n\nIn the following two sections we explain the coding of the functions used in @sec-abund-model. These functions are not part of any existing R package. They are written for clarity rather than computational efficiency, and they are tailored to the current modelling example without attempts at generalisation. The aim is to present code that is correct and easy to follow, so that by understanding each component you can adapt and extend it to fit your own modelling requirements and learn more efficient implementations your own.\n\n\n### Simulating from the predictive of non-spatial mixed models {#sec-sim-re}\n\nIn this section, we provide a detailed explanation of the simulate_random_effects function used in this case study.\n\nSimulating from the conditional distribution of $Z_i$​ given the observed counts $y_i$​ under a Poisson mixed model can be done in several ways in R, often more efficiently than the approach illustrated here. However, our goal is not to present the fastest implementation, but to offer a transparent, step-by-step example. This level of detail is useful for readers who wish to understand the underlying computations, or who may want to adapt and generalize the function for other analyses. From a pedagogical perspective, dissecting such a function provides a hands-on introduction to computational methods for generalized linear mixed models and illustrates ideas that are extended in more advanced Bayesian and likelihood-based approaches.\n\nThe function is reproduced below:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimulate_random_effects <- function(model, nsim = 1000, grid_range = c(-10, 10), grid_length = 5000) {\n  # Extract fixed effects and RE variance\n  beta_hat <- fixef(model)\n  sigma2_hat <- as.numeric(VarCorr(model)[[1]][1])\n  \n  # Extract model frame and grouping\n  mf <- model@frame\n  group_var <- names(ranef(model))[1]\n  group_ids <- mf[[group_var]]\n  unique_groups <- unique(group_ids)\n  ngroups <- length(unique_groups)\n  \n  # Design matrix for fixed effects\n  D <- model.matrix(model)\n  \n  # Create result matrix\n  u_samples <- matrix(NA, nrow = ngroups, ncol = nsim)\n  rownames(u_samples) <- unique_groups\n  \n  # Log-predictive density function for one group\n  log_pd_u <- function(u, y_j, D_j, beta_hat, sigma2_hat) {\n    eta <- as.vector(D_j %*% beta_hat) + u\n    loglik <- sum(dpois(y_j, lambda = exp(eta), log = TRUE))\n    logprior <- dnorm(u, mean = 0, sd = sqrt(sigma2_hat), log = TRUE)\n    return(loglik + logprior)\n  }\n  \n  # For each group, compute predictive samples of u_j\n  for (j in seq_along(unique_groups)) {\n    gid <- unique_groups[j]\n    idx <- which(group_ids == gid)\n    y_j <- model@resp$y[idx]\n    D_j <- D[idx, , drop = FALSE]\n    \n    # Create grid and compute log predictive density\n    u_grid <- seq(grid_range[1], grid_range[2], length.out = grid_length)\n    logdens <- sapply(u_grid, log_pd_u, y_j = y_j, D_j = D_j,\n                      beta_hat = beta_hat, sigma2_hat = sigma2_hat)\n    logdens <- logdens - max(logdens)\n    dens <- exp(logdens)\n    pdf_u <- dens / sum(dens)\n    cdf_u <- cumsum(pdf_u)\n    cdf_u <- cdf_u / max(cdf_u)\n    \n    # Drop duplicated CDF values (necessary for approx)\n    keep <- !duplicated(cdf_u)\n    u_samples[j, ] <- approx(cdf_u[keep], u_grid[keep], xout = runif(nsim), rule = 2)$y\n    \n  }\n  \n  return(u_samples)\n}\n```\n:::\n\n\n\n\n\n\n\n\nBelow, we break down the function step by step.\n\nFirst, we extract the fixed-effect estimates and the random effect variance from the fitted model:\n\n``` r\nbeta_hat <- fixef(model)                        # Fixed effect coefficients (MLEs)\nsigma2_hat <- as.numeric(VarCorr(model)[[1]][1])# Estimated variance of random intercepts\n```\n\nThese parameters will be treated as known when simulating the predictive of the random effects. Next, we identify the grouping variable for the random effects and compute the fixed-effects design matrix:\n\n``` r\nmf <- model@frame                      # Model frame containing the data\ngroup_var <- names(ranef(model))[1]     # Name of the grouping variable\ngroup_ids <- mf[[group_var]]            # Group ID for each observation\nunique_groups <- unique(group_ids)      # Unique group levels\nngroups <- length(unique_groups)        # Number of groups\n\nD <- model.matrix(model)                # Fixed-effects design matrix\n```\n\nHere, `group_ids` associates each observation with its random effect, and `D` is the design matrix used to compute the linear predictor for the fixed effects.\n\nWe initialize a results matrix to store the predictive samples for each group:\n\n``` r\nu_samples <- matrix(NA, nrow = ngroups, ncol = nsim)\nrownames(u_samples) <- unique_groups\n```\n\nEach row corresponds to a group and each column to a predictive sample of $u_j$.\n\nWe then define a helper function to compute the unnormalized log-predictive density of a single random effect $u_j$ given the data for that group:\n\n``` r\nlog_pd_u <- function(u, y_j, D_j, beta_hat, sigma2_hat) {\n  eta <- as.vector(D_j %*% beta_hat) + u      # Linear predictor\n  loglik <- sum(dpois(y_j, lambda = exp(eta), log = TRUE))   # Poisson likelihood\n  logprior <- dnorm(u, mean = 0, sd = sqrt(sigma2_hat), log = TRUE) # Normal prior\n  return(loglik + logprior)                   # Unnormalized log-posterior\n}\n```\n\nThis combines the Poisson likelihood for the observations in group $j$ with the Gaussian prior on the random effect.\n\nFor each group, we first compute the predictive on a grid of $u$ values, then normalize it to form a cumulative distribution function (CDF), and finally draw samples using inverse CDF sampling.\n\n``` r\nfor (j in seq_along(unique_groups)) {\n  gid <- unique_groups[j]\n  idx <- which(group_ids == gid)\n  y_j <- model@resp$y[idx]\n  D_j <- D[idx, , drop = FALSE]\n\n  # Step 1: Compute predictive density on a grid\n  u_grid <- seq(grid_range[1], grid_range[2], length.out = grid_length)\n  logdens <- sapply(u_grid, log_pd_u, y_j = y_j, D_j = D_j,\n                    beta_hat = beta_hat, sigma2_hat = sigma2_hat)\n  logdens <- logdens - max(logdens)    # Stabilize exponentiation\n  dens <- exp(logdens)\n  pdf_u <- dens / sum(dens)\n\n  # Step 2: Compute cumulative distribution\n  cdf_u <- cumsum(pdf_u) / sum(pdf_u)\n\n  # Step 3: Sample from predictive using inverse CDF\n  keep <- !duplicated(cdf_u)  # Remove duplicates to avoid interpolation warnings\n  u_samples[j, ] <- approx(cdf_u[keep], u_grid[keep], xout = runif(nsim), rule = 2)$y\n}\n```\n\nThe function uses a grid-based approximation, evaluating the predictive on a fine grid to avoid running MCMC for these one-dimensional distributions.\\\nThe computation `logdens - max(logdens)` provides numerical stabilization, preventing underflow when exponentiating very small log-likelihood values.\\\nFinally, the function `approx()` performs inverse transform sampling. This works by first computing the CDF of the random effect on a fine grid, which maps each candidate value of the random effect to its cumulative probability. We then draw random numbers from a uniform distribution on $[0,1]$ and use `approx()` to interpolate the CDF to find the corresponding values of the random effect. In other words, we are transforming uniform draws into samples from the desired predictive distribution by inverting the CDF numerically, a method commonly known as the inverse transform method; for a thorough explanation of this approach, @robert2004 is a highly recommended reading.\n\nAs a self-directed learning activity for readers interested in the computational aspects of model fitting, we invite them to work through Exercise 4 at the end of this chapter.\n\n### The non-randomized probability integral transform for non-spatial models {#sec-nonspat-anpit}\n\nThe function for generating and plotting the average non-randomized probability transform (AnPIT) used in @sec-abund-model are given below. \n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanpit_wnv <- function(model, test_prop = 0.25, nsim = 2000,\n                      u_grid = seq(0, 1, length.out = 101), seed = NULL) {\n  stopifnot(inherits(model, \"glmerMod\"))\n  if (!is.null(seed)) set.seed(seed)\n  if (test_prop <= 0 || test_prop >= 1) stop(\"test_prop must be in (0,1)\")\n\n  # Extract pieces from the fitted model\n  D   <- model.matrix(model)                 # fixed-effects design as used at fit\n  off <- model@frame$`offset(log(trap_nights))`\n  y   <- model@resp$y\n  beta <- lme4::fixef(model)\n  sigma <- sqrt(as.numeric(lme4::VarCorr(model)[[1]][1]))\n\n  n <- nrow(D)\n  test_idx  <- sort(sample(seq_len(n), size = ceiling(n * test_prop)))\n  train_idx <- setdiff(seq_len(n), test_idx)\n\n  # Linear predictor without REs\n  eta0 <- as.numeric(D %*% beta) + off\n\n  # For these data loc is unique per row; for test rows we integrate over prior u ~ N(0, sigma^2)\n  # Draw nsim random-effect values once and reuse across test rows (common random numbers)\n  u_draws <- rnorm(nsim, mean = 0, sd = sigma)\n\n  y_test <- y[test_idx]\n  eta0_test <- eta0[test_idx]\n  n_test <- length(test_idx)\n\n  # Posterior predictive CDFs at y and y-1 via Monte Carlo over u\n  Fi_y      <- numeric(n_test)\n  Fi_yminus <- numeric(n_test)\n  y_minus <- pmax(y_test - 1L, -1L)\n\n  for (i in seq_len(n_test)) {\n    lam <- exp(eta0_test[i] + u_draws)\n    Fi_y[i] <- mean(ppois(y_test[i], lambda = lam))\n    Fi_yminus[i] <- if (y_minus[i] < 0) 0 else mean(ppois(y_minus[i], lambda = lam))\n    if (Fi_y[i] < Fi_yminus[i]) { tmp <- Fi_y[i]; Fi_y[i] <- Fi_yminus[i]; Fi_yminus[i] <- tmp }\n  }\n\n  # Nonrandomized PIT for each u in u_grid and average across test observations\n  npit_avg <- function(u, Fy, Fym1) {\n    denom <- pmax(Fy - Fym1, .Machine$double.eps)\n    lt <- u <= Fym1; gt <- u >= Fy; mid <- !(lt | gt)\n    out <- numeric(length(Fy))\n    out[lt] <- 0; out[gt] <- 1; out[mid] <- (u - Fym1[mid]) / denom[mid]\n    mean(out)\n  }\n  anpit <- vapply(u_grid, npit_avg, FUN.VALUE = 0.0, Fy = Fi_y, Fym1 = Fi_yminus)\n\n  list(u = u_grid,\n       anpit = as.numeric(anpit),\n       Fi_y = Fi_y,\n       Fi_yminus = Fi_yminus,\n       test_index = test_idx,\n       train_index = train_idx)\n}\n\nplot_anpit <- function(res) {\n  if (!requireNamespace(\"ggplot2\", quietly = TRUE)) stop(\"Need ggplot2 for plotting.\")\n  df <- data.frame(u = res$u, anpit = res$anpit)\n  ggplot(df, aes(u, anpit)) +\n    geom_line(linewidth = 0.9) +\n    geom_abline(slope = 1, intercept = 0, linetype = 2) +\n    labs(x = \"u\", y = \"Average nPIT\", title = \"\") +\n    theme_minimal()\n}\n```\n:::\n\n\n\n\n\n\n\nWe start by defining the function and adding input checks.\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanpit_wnv <- function(model, test_prop = 0.25, nsim = 2000,\n                      u_grid = seq(0, 1, length.out = 101), seed = NULL) {\n  stopifnot(inherits(model, \"glmerMod\"))\n  if (!is.null(seed)) set.seed(seed)\n  if (test_prop <= 0 || test_prop >= 1) stop(\"test_prop must be in (0,1)\")\n```\n:::\n\n\n\n\n\n\n\nThe function accepts a fitted Poisson mixed model, a proportion for the test set, number of Monte Carlo draws, a grid of u values (used as input of the AnPIT), and an optional seed for reproducibility. It checks that the model is of class `glmerMod` and that the test proportion is valid.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n  D    <- model.matrix(model)\n  off  <- model@offset; if (is.null(off)) off <- rep(0, nrow(D))\n  y    <- model@resp$y\n  beta <- lme4::fixef(model)\n  sigma <- sqrt(as.numeric(lme4::VarCorr(model)[[1]][1]))\n```\n:::\n\n\n\n\n\n\n\nThis block extracts the design matrix, the offset (log of trap nights in our case), the response counts, the fixed effects, and the standard deviation of the random intercept.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n  n <- nrow(D)\n  test_idx  <- sort(sample(seq_len(n), size = ceiling(n * test_prop)))\n  train_idx <- setdiff(seq_len(n), test_idx)\n```\n:::\n\n\n\n\n\n\n\nHere we randomly split the data into a test and training set according to `test_prop`.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n  eta0 <- as.numeric(D %*% beta) + off\n  u_draws <- rnorm(nsim, mean = 0, sd = sigma)\n```\n:::\n\n\n\n\n\n\n\nWe compute the linear predictor without random effects and generate random intercept samples from the marginal distribution of the random effects $Z_i$, namely a Gaussian distribution with mean 0 and standard deviation `sigma`. Since each location is unique, we integrate over the prior for the test rows.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n  y_test    <- y[test_idx]\n  eta0_test <- eta0[test_idx]\n  n_test    <- length(test_idx)\n\n  Fi_y      <- numeric(n_test)\n  Fi_yminus <- numeric(n_test)\n  y_minus   <- pmax(y_test - 1L, -1L)\n```\n:::\n\n\n\n\n\n\n\nThe response, linear predictor, and number of test observations are stored. We also prepare storage for the predictive CDFs.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n  for (i in seq_len(n_test)) {\n    lam <- exp(eta0_test[i] + u_draws)\n    Fi_y[i]      <- mean(ppois(y_test[i],    lambda = lam))\n    Fi_yminus[i] <- if (y_minus[i] < 0) 0 else mean(ppois(y_minus[i], lambda = lam))\n    if (Fi_y[i] < Fi_yminus[i]) { tmp <- Fi_y[i]; Fi_y[i] <- Fi_yminus[i]; Fi_yminus[i] <- tmp }\n  }\n```\n:::\n\n\n\n\n\n\n\nFor each test observation, we compute the predictive CDF at $y$ and $y−1$ via Monte Carlo integration over the u draws. These quantities are then used to compute the AnPIT below.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n  npit_avg <- function(u, Fy, Fym1) {\n    denom <- pmax(Fy - Fym1, .Machine$double.eps)\n    lt <- u <= Fym1; gt <- u >= Fy; mid <- !(lt | gt)\n    out <- numeric(length(Fy))\n    out[lt] <- 0; out[gt] <- 1; out[mid] <- (u - Fym1[mid]) / denom[mid]\n    mean(out)\n  }\n  anpit <- vapply(u_grid, npit_avg, FUN.VALUE = 0.0, Fy = Fi_y, Fym1 = Fi_yminus)\n```\n:::\n\n\n\n\n\n\n\nWe define a helper to compute the AnPIT for a given u and average it over the test set (see @eq-anpit for the definition of the AnPIT). This is repeated for each u in the grid.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n  list(u = u_grid,\n       anpit = as.numeric(anpit),\n       Fi_y = Fi_y,\n       Fi_yminus = Fi_yminus,\n       test_index = test_idx,\n       train_index = train_idx)\n}\n```\n:::\n\n\n\n\n\n\n\nThe function returns a list with the u grid, the averaged nPIT values, the predictive CDFs, and the indices of the test and training sets.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_anpit <- function(res) {\n  if (!requireNamespace(\"ggplot2\", quietly = TRUE)) stop(\"Need ggplot2 for plotting.\")\n  df <- data.frame(u = res$u, anpit = res$anpit)\n  ggplot(df, aes(u, anpit)) +\n    geom_line(linewidth = 0.9) +\n    geom_abline(slope = 1, intercept = 0, linetype = 2) +\n    labs(x = \"u\", y = \"Average nPIT\", title = \"\") +\n    theme_minimal()\n}\n```\n:::\n\n\n\n\n\n\n\nThis helper function takes the output and produces a plot of the averaged nPIT curve against the identity line.\n\n\n\n## Exercises\n\n1.  Re-analyse the Ghana malnutrition data set (see @sec-ghana) after dichotomising the height-for-age Z-score (HAZ) and weight-for-age Z-score (WAZ). Define two binary outcomes:\n\n    -   `HAZ_bin` = 1 if HAZ \\< −2, and 0 otherwise\\\n    -   `WAZ_bin` = 1 if WAZ \\< −2, and 0 otherwise\n\n    Fit binomial geostatistical models to the individual-level data and compare the point estimates and spatial predictions to those obtained from the geostatistical models described in @sec-ghana. Discuss which model provides a better fit and why.\n\n2.  In the Malawi prevalence mapping analysis, we used the first principal component (PC1) of the environmental covariates to summarize covariate variation and reduce dimensionality. In this exercise, you will investigate whether including the second principal component (PC2) improves the model.\n\n    -   Compute the second principal component (PC2) from the same set of standardized covariates used to derive PC1. What is the interpretation of PC2? What kind of relationship does PC2 show with the empirical logit?\n\n    -   Fit a geostatistical model that includes both PC1 and PC2 as covariates. How do the covariance parameters of the spatial process change after including PC2 compared to the model with PC1 only?\n\n    -   Compare this model to:\n\n        -   the model using only PC1, and\n        -   the model using all covariates as separate predictors.\n\n        Use the AnPIT plot and CRPS/SCRPS scores to assess predictive performance.\n\n    -   Discuss whether adding PC2 captures additional meaningful variation or introduces multicollinearity or overfitting. What implications does this have for model interpretability and parsimony?\n\n3.  In this exercise, you will repeat the full analysis pipeline developed for Malawi using data from a different country.\n\n    -   Choose a different country available in the `malariaAtlas` package (e.g., Zambia or Nigeria), and download parasite prevalence survey data for a specific year.\n\n    -   Obtain the same set of environmental covariates used in the Malawi analysis, and prepare them for analysis (e.g., resample, standardize, and extract values at survey locations).\n\n    -   Fit and compare two geostatistical models:\n\n        -   A model using the environmental covariates as separate fixed effects.\n        -   A model using the first principal component (PC1) as a synthetic covariate summarizing the covariate space.\n\n    -   Evaluate model performance using the AnPIT plot and CRPS/SCRPS scores.\n\n    -   Reflect on which model performs better in this new setting. Do your conclusions align with what was observed in the Malawi case study? What might explain any differences in performance across countries?\n\n4.  The function `simulate_random_effects()` in @sec-sim-re samples random effects using a simple grid-based inverse CDF approach.\\\n    While easy to understand, this method can be slow when the number of groups or simulations is large. Rewrite the function using a more efficient sampling strategy such as slice sampling [@neal2003] or a simple Metropolis–Hastings sampler [@gelman2013bayesian]. After implementing your new function, compare the sampled random effect distributions to those obtained from `simulate_random_effects` and discuss any differences in accuracy and computational speed.\n    \n5.  The function `anpit_wnv()` computes the average non-randomized probability integral transform for the specific model in @eq-wnv-counts. Full details of the implementation are given in @sec-nonspat-anpit. You may wish to enhance this function in one of two ways: first, by generalising it so that it can be applied to any generalized linear mixed model with the same random effects structure; second, by replacing the Monte Carlo step that samples from a Gaussian distribution with a numerical integration approach. Once you have implemented this function, you can apply it to the analysed data-sets of the previous chapter and compare the generated AnPIT against those of the fitted geostatistical models. Does the AnPIT show an unsatisfactory diagnostic in some cases?\n\n6. Repeat the analysis in @sec-wnv from the beginning to predict the vector index, but this time assume alternative fixed values for the PCR pool size $k_i$ in @sec-wnv-model, setting all $k_i$ to 10, 25, and 50 in turn. Compare the resulting inferences on West Nile virus infection prevalence and the vector index across these three scenarios, and discuss how they differ from each other as well as from the results presented earlier in this chapter.\n \n",
    "supporting": [
      "05_case-studies_files/figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}