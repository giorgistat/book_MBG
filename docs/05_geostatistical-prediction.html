<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>5&nbsp; Geostatistical prediction – Model-based geostatistics for global public health using R</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>

<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./06_case-studies.html" rel="next">
<link href="./04_residuals-analysis.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/quarto-contrib/line-highlight-1.0.0/line-highlight.css" rel="stylesheet"><script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script><link href="site_libs/pagedtable-1.1/css/pagedtable.css" rel="stylesheet">
<script src="site_libs/pagedtable-1.1/js/pagedtable.js"></script><script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script><script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>
</head>
<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top"><nav class="quarto-secondary-nav"><div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./05_geostatistical-prediction.html"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Geostatistical prediction</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav></header><!-- content --><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto"><div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Model-based geostatistics for global public health using R</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./author.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Author</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01_intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02_handling-spatial-data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Handling of spatial data in R</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03_model-fitting.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Model formulation and parameter estimation</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04_residuals-analysis.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Model validation through residuals analysis</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05_geostatistical-prediction.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Geostatistical prediction</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06_case-studies.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Case studies</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./appendix.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Appendix</span></a>
  </div>
</li>
    </ul>
</div>
</nav><div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active"><h2 id="toc-title">Contents</h2>
   
  <ul>
<li><a href="#list-of-the-main-functions-used-in-the-chapter" id="toc-list-of-the-main-functions-used-in-the-chapter" class="nav-link active" data-scroll-target="#list-of-the-main-functions-used-in-the-chapter">List of the main functions used in the chapter</a></li>
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction"><span class="header-section-number">5.1</span> Introduction</a></li>
  <li>
<a href="#sec-spat-pred-target" id="toc-sec-spat-pred-target" class="nav-link" data-scroll-target="#sec-spat-pred-target"><span class="header-section-number">5.2</span> Spatial prediction using geostatistical models</a>
  <ul class="collapse">
<li><a href="#sec-pred-samples" id="toc-sec-pred-samples" class="nav-link" data-scroll-target="#sec-pred-samples"><span class="header-section-number">5.2.1</span> Generating samples from the predictive distribution of <span class="math inline">\(S(\tilde{X})\)</span> (continue from <span>Section 3.3.1</span>)</a></li>
  </ul>
</li>
  <li>
<a href="#sec-spat-cont-target" id="toc-sec-spat-cont-target" class="nav-link" data-scroll-target="#sec-spat-cont-target"><span class="header-section-number">5.3</span> Spatially continuous targets</a>
  <ul class="collapse">
<li><a href="#sec-liberia-prediction-1" id="toc-sec-liberia-prediction-1" class="nav-link" data-scroll-target="#sec-liberia-prediction-1"><span class="header-section-number">5.3.1</span> Example: mapping riverblidness prevalence in Liberia (continuing from <span>Section 5.2.1</span>)</a></li>
  <li><a href="#sec-non-spar-covariates" id="toc-sec-non-spar-covariates" class="nav-link" data-scroll-target="#sec-non-spar-covariates"><span class="header-section-number">5.3.2</span> Example: mapping malaria using age and elevation as predictors</a></li>
  </ul>
</li>
  <li>
<a href="#sec-areal-target" id="toc-sec-areal-target" class="nav-link" data-scroll-target="#sec-areal-target"><span class="header-section-number">5.4</span> Areal-level targets</a>
  <ul class="collapse">
<li><a href="#sec-liberia-prediction-2" id="toc-sec-liberia-prediction-2" class="nav-link" data-scroll-target="#sec-liberia-prediction-2"><span class="header-section-number">5.4.1</span> Example: predicting the average riverblindness prevalence at admin level 1 in Liberia (continuing from <span>Section 5.3.1</span>)</a></li>
  <li><a href="#sec-anopheles-pred" id="toc-sec-anopheles-pred" class="nav-link" data-scroll-target="#sec-anopheles-pred"><span class="header-section-number">5.4.2</span> Example: predicting the total number of Anopheles gambiae mosquitoes (continuing from <span>Section 3.3.2</span>)</a></li>
  </ul>
</li>
  <li>
<a href="#sec-compare-pp" id="toc-sec-compare-pp" class="nav-link" data-scroll-target="#sec-compare-pp"><span class="header-section-number">5.5</span> Assessing the predictive performance of geostatistical models with cross-validation</a>
  <ul class="collapse">
<li><a href="#sec-split-data" id="toc-sec-split-data" class="nav-link" data-scroll-target="#sec-split-data"><span class="header-section-number">5.5.1</span> How to split geostatistical data for model performance comparisons</a></li>
  <li><a href="#sec-anpit" id="toc-sec-anpit" class="nav-link" data-scroll-target="#sec-anpit"><span class="header-section-number">5.5.2</span> Assessing calibration using the nonrandomized probability integral transform</a></li>
  <li><a href="#assessing-calibration-and-sharpness-using-continuous-ranked-probability-scores" id="toc-assessing-calibration-and-sharpness-using-continuous-ranked-probability-scores" class="nav-link" data-scroll-target="#assessing-calibration-and-sharpness-using-continuous-ranked-probability-scores"><span class="header-section-number">5.5.3</span> Assessing calibration and sharpness using continuous ranked probability scores</a></li>
  </ul>
</li>
  <li>
<a href="#simulation-based-assessment-of-predictive-performance" id="toc-simulation-based-assessment-of-predictive-performance" class="nav-link" data-scroll-target="#simulation-based-assessment-of-predictive-performance"><span class="header-section-number">5.6</span> Simulation-based assessment of predictive performance</a>
  <ul class="collapse">
<li><a href="#sec-sim-step1" id="toc-sec-sim-step1" class="nav-link" data-scroll-target="#sec-sim-step1"><span class="header-section-number">5.6.1</span> Step 1: Define the aim of the simulation study</a></li>
  <li><a href="#step-2-simulate-the-spatial-surface-and-the-data-from-the-true-model" id="toc-step-2-simulate-the-spatial-surface-and-the-data-from-the-true-model" class="nav-link" data-scroll-target="#step-2-simulate-the-spatial-surface-and-the-data-from-the-true-model"><span class="header-section-number">5.6.2</span> Step 2: Simulate the spatial surface and the data from the true model</a></li>
  <li><a href="#sec-sim-step3" id="toc-sec-sim-step3" class="nav-link" data-scroll-target="#sec-sim-step3"><span class="header-section-number">5.6.3</span> Step 3: Fit the candidate models to the simulated data and predict the target</a></li>
  <li><a href="#step-4-summarize-the-results-using-a-pre-defined-objective-function" id="toc-step-4-summarize-the-results-using-a-pre-defined-objective-function" class="nav-link" data-scroll-target="#step-4-summarize-the-results-using-a-pre-defined-objective-function"><span class="header-section-number">5.6.4</span> Step 4: Summarize the results using a pre-defined objective function</a></li>
  <li><a href="#sec-sim-assessment" id="toc-sec-sim-assessment" class="nav-link" data-scroll-target="#sec-sim-assessment"><span class="header-section-number">5.6.5</span> Assessessment of threshold-based classification of spatial units using geostatistical models</a></li>
  </ul>
</li>
  <li>
<a href="#sec-theory-prediction" id="toc-sec-theory-prediction" class="nav-link" data-scroll-target="#sec-theory-prediction"><span class="header-section-number">5.7</span> Theory</a>
  <ul class="collapse">
<li><a href="#sec-pred-distr-theory" id="toc-sec-pred-distr-theory" class="nav-link" data-scroll-target="#sec-pred-distr-theory"><span class="header-section-number">5.7.1</span> Expression of the predictive distribution for a linear geostatistical model</a></li>
  <li><a href="#a-brief-overview-of-scoring-rules" id="toc-a-brief-overview-of-scoring-rules" class="nav-link" data-scroll-target="#a-brief-overview-of-scoring-rules"><span class="header-section-number">5.7.2</span> A brief overview of scoring rules</a></li>
  </ul>
</li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary"><span class="header-section-number">5.8</span> Summary</a></li>
  <li><a href="#faqs" id="toc-faqs" class="nav-link" data-scroll-target="#faqs"><span class="header-section-number">5.9</span> FAQs</a></li>
  <li><a href="#review-questions" id="toc-review-questions" class="nav-link" data-scroll-target="#review-questions"><span class="header-section-number">5.10</span> Review questions</a></li>
  <li><a href="#exercises" id="toc-exercises" class="nav-link" data-scroll-target="#exercises"><span class="header-section-number">5.11</span> Exercises</a></li>
  </ul></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block default"><div class="quarto-title">
<h1 class="title"><span id="sec-geo-prediction" class="quarto-section-identifier"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Geostatistical prediction</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header><section id="list-of-the-main-functions-used-in-the-chapter" class="level2 unnumbered"><h2 class="unnumbered anchored" data-anchor-id="list-of-the-main-functions-used-in-the-chapter">List of the main functions used in the chapter</h2>
<table class="caption-top table">
<colgroup>
<col style="width: 34%">
<col style="width: 25%">
<col style="width: 40%">
</colgroup>
<thead><tr class="header">
<th>Function</th>
<th>R Package</th>
<th>Used for</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>pred_over_grid</code></td>
<td><code>RiskMap</code></td>
<td>Predicting the different component of the linear predictor over a grid: the covariates effects and the random effects</td>
</tr>
<tr class="even">
<td><code>pred_target_grid</code></td>
<td><code>RiskMap</code></td>
<td>Predictions of target defined at pixel-level</td>
</tr>
<tr class="odd">
<td><code>pred_target_shp</code></td>
<td><code>RiskMap</code></td>
<td>Predictions of targets defined at areal level</td>
</tr>
<tr class="even">
<td><code>assess_pp</code></td>
<td><code>RiskMap</code></td>
<td>Assessing the predictive performance of geostatistical models using cross-validation</td>
</tr>
<tr class="odd">
<td><code>surf_sim</code></td>
<td><code>RiskMap</code></td>
<td>Simulating surfaces and data from geostatistical models</td>
</tr>
<tr class="even">
<td><code>assess_sim</code></td>
<td><code>RiskMap</code></td>
<td>Assessing the predictive performance of geostatistical models using simulations</td>
</tr>
</tbody>
</table></section><section id="introduction" class="level2" data-number="5.1"><h2 data-number="5.1" class="anchored" data-anchor-id="introduction">
<span class="header-section-number">5.1</span> Introduction</h2>
<p>Geostatistics was originally developed and applied as a predictive tool for improving mining operations and planning. In the seminal paper on model-based geostatistics (MBG) <span class="citation" data-cites="diggle1998">(<a href="references.html#ref-diggle1998" role="doc-biblioref">P. J. Diggle, Tawn, and Moyeed 1998</a>)</span>, the authors begin by stating:</p>
<blockquote class="blockquote">
<p>*“Conventional geostatistical methodology solves the problem of predicting the realized value of a linear functional of a Gaussian spatial stochastic process* <span class="math inline">\(S(x)\)</span> based on observations <span class="math inline">\(Y_i= S(x_i) + Z_i\)</span> at sampling locations <span class="math inline">\(x_i\)</span>, where the <span class="math inline">\(Z_i\)</span> are mutually independent, zero-mean Gaussian random variables.”</p>
</blockquote>
<p>It is no coincidence that, although MBG represents a broad class of statistical models applicable to both estimation and prediction problems, the majority of its applications have focused on prediction. This is evident in many scientific fields where MBG has been used, including global public health, which is the primary application focus in this book. In line with the quote above, for most of the examples considered in this book, the analyses we illustrate aim to use a finite set of locations <span class="math inline">\(x_i\)</span> — typically corresponding to households or villages — to make inferences about an observed disease risk surface. Having performed estimation of MBG models in <a href="03_model-fitting.html" class="quarto-xref"><span>Chapter 3</span></a>, we can now carry out spatial prediction to answer critical public health questions, such as identifying hot-spots and cold-spots — areas of unusually high or low disease risk, respectively — or determining whether the average prevalence across a region exceeds a predefined policy threshold.</p>
<p>In this chapter, we will explore these issues, beginning with a formal statistical formulation of the spatial prediction problem and a description of the necessary steps for its implementation. We will then demonstrate how spatial prediction is performed when considering predictive targets at both the <em>pixel-level</em> and <em>areal-level</em>. Finally, we will conclude the chapter by presenting methods for comparing the predictive performance of different models, with some insights into their relative strengths and weaknesses.</p>
</section><section id="sec-spat-pred-target" class="level2" data-number="5.2"><h2 data-number="5.2" class="anchored" data-anchor-id="sec-spat-pred-target">
<span class="header-section-number">5.2</span> Spatial prediction using geostatistical models</h2>
<p>Let us consider the class of generalized linear geostatistical models (GLGM) as in <a href="01_intro.html#sec-geostat-models" class="quarto-xref"><span>Section 1.5</span></a>. In the formulation of prediction problems, the first step consists of defining our predictive target, which we denote as <span class="math inline">\(T(x)\)</span> where <span class="math inline">\(x\)</span> denotes any locations within the study, which is usually not part of the sampled data. For example in the analysis of the riverblindness in Liberia, our interest lies in identifying areas where disease prevalence exceeds 20<span class="math inline">\(\%\)</span>, a threshold that use been used in the past to identify areas in need of mass drug administration due to the potential for significant disease burden and transmission <span class="citation" data-cites="amazigo2008">(<a href="references.html#ref-amazigo2008" role="doc-biblioref">Amazigo 2008</a>)</span>. Hence, in this case, disease prevalence corresponds to our predictive target <span class="math inline">\(T(x)\)</span>. To draw inferences on <span class="math inline">\(T(x)\)</span> and allow us to answer the question of where <span class="math inline">\(T(x)\)</span> exceeds a 20<span class="math inline">\(\%\)</span> threshold, we first need to obtain the so called <em>predictive distribution</em> of <span class="math inline">\(T(x)\)</span>. More specifically, the <em>predictive distribution</em> of <span class="math inline">\(T(x)\)</span> is the distribution of <span class="math inline">\(T(x)\)</span> conditioned to the data, which we denote by <span class="math inline">\([T(x) \: \mid \: y]\)</span>. More importantly, by incorporating the information provided by the data, the predictive distribution of the target enables us to quantify the uncertainty stemming from the stochastic nature of the process we are modeling. In other words, the predictive distribution reflects the range of possible values that the target <span class="math inline">\(T(x)\)</span> can take and their likelihoods based on the model we have fitted to the data. As we shall see in our examples, we can use the predictive distribution of <span class="math inline">\(T(x)\)</span> both to provide what is our “best guess” for <span class="math inline">\(T(x)\)</span> and a summary of uncertainty which quantifies how much concentrated is the predictive distribution around that guess. However, providing a single “best guess” for <span class="math inline">\(T(x)\)</span> is not always the answer to our research question. In the example on riverblindness mentioned at the start of the this section, a more natural way to use the predictive distribution would be to compute the likelihood that <span class="math inline">\(T(x)\)</span> exceeds 0.2 at any given location <span class="math inline">\(x\)</span>.</p>
<p>In summary, the first two steps of spatial prediction are:</p>
<ul>
<li><p>Step 1. define the predictive target <span class="math inline">\(T(x)\)</span>;</p></li>
<li><p>Step 2. obtain the predictive distribution of <span class="math inline">\(T(x)\)</span> and use this to compute summaries that helps to answer your original research question.</p></li>
</ul>
<p>This begs two practical questions: “How do we obtain the predictive distribution of <span class="math inline">\(T(x)\)</span>?” and “How do we use the predictive distribution to compute our summaries?”. For a mathematical derivation of the predictive distribution and the form that this takes in the special case of a linear geostatistical model, you can read <a href="#sec-theory-prediction" class="quarto-xref"><span>Section 5.7</span></a>. In what follows, we shall assume that we can simulate directly from <span class="math inline">\([T(x) \: \mid \: y]\)</span> either using direct simulation or Markov Chains Monte Carlo (see <a href="03_model-fitting.html#sec-mcmc-mala" class="quarto-xref"><span>Section 3.4.2.2</span></a>).</p>
<p>In our exposition so far, we have also made the implicit assumption that prediction is required for our predictive target at a single, unsampled, location <span class="math inline">\(x\)</span> and for this reason we have denote our predictive target simply as <span class="math inline">\(T(x)\)</span>. However, this is almost never the case, since in most cases, our predictive target correspond to either of the following.</p>
<ul>
<li><p><strong>Spatially continuous targets</strong> correspond to an unobserved spatially continuous surface (e.g.&nbsp;disease prevalence), formally denoted by <span class="math inline">\(\mathcal{T} = \{T(x), x \in A\}\)</span>, where <span class="math inline">\(A\)</span> is our region of interest.</p></li>
<li><p><strong>Areal-level targets</strong>, usually defined as transformation of the spatially continuous surface <span class="math inline">\(\mathcal{T}\)</span>, defined previously, and which we denote as <span class="math inline">\(\mathcal{T}_{A} = F(\mathcal{T}, A)\)</span>. For example, the average of <span class="math inline">\(T(x)\)</span> over <span class="math inline">\(A\)</span> is an areal-level target, formally defined as <span class="math inline">\(F(\mathcal{T}, A) = \int_{A} T(x) \: dx / |A|\)</span>, where <span class="math inline">\(|A|\)</span> is the area of <span class="math inline">\(A\)</span>.</p></li>
</ul>
<p>Before we consider these two types of prediction targets more in detail, we first explain the preliminary steps that need to be performed and are common to both. Whether our goal is predict a spatially continuous or areal-level target, the initial task is to draw Monte Carlo samples from the predictive distribution of the spatial process <span class="math inline">\(S(x)\)</span><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. Next, we define a set of prediction locations, say <span class="math inline">\(q\)</span> in total, denoted as <span class="math inline">\(\tilde{X} = {\tilde{x}_1, \ldots, \tilde{x}_q}\)</span>. These locations correspond to a regular grid that spans our region of interest, <span class="math inline">\(A\)</span>. the predictive distribution of the spatial process over the grid, represented as <span class="math inline">\([S(\tilde{X}) \: |\: y]\)</span>. This distribution allows us to generate Monte Carlo samples for <span class="math inline">\(S(\tilde{X})\)</span>, which will later be used for computing our target.</p>
<p>At this stage, we need to consider which of the two following types of predictions from <span class="math inline">\([S(\tilde{X}) \: |\: y]\)</span> are required.</p>
<ul>
<li><p><strong>Marginal predictions</strong> are obtained by simulating independently from the <span class="math inline">\(q\)</span> marginal predictive distributions of <span class="math inline">\([S(\tilde{X}) | y]\)</span>. In other words, we consider a prediction location <span class="math inline">\(\tilde{x}_j\)</span>, simulate from <span class="math inline">\([S(\tilde{x}_j) \: |\: y]\)</span> say <span class="math inline">\(B\)</span> samples, and repeat this for <span class="math inline">\(j=1,\ldots,q\)</span></p></li>
<li><p><strong>Joint predictions</strong> are obtained by simulating from the joint distribution of <span class="math inline">\([S(\tilde{X}) \: |\: y]\)</span>. Unlike marginal predictions, joint predictions take into account the correlation between the different components of <span class="math inline">\([S(\tilde{X}) \: |\: y]\)</span>.</p></li>
</ul>
<p>To better understand the technical differences between marginal and joint predictions, we refer you to <a href="#sec-pred-distr-theory" class="quarto-xref"><span>Section 5.7.1</span></a>. However, in practice, the two following observations are important.</p>
<p>O1. Joint predictions are computationally more intensive than marginal predictions.</p>
<p>O2. Joint predictions are required when the predictive target is at areal-level.</p>
<p>O3. For spatially continuous targets, both marginal and joint predictions can be used but, in light of O1, we might prefer using the former.</p>
<section id="sec-pred-samples" class="level3" data-number="5.2.1"><h3 data-number="5.2.1" class="anchored" data-anchor-id="sec-pred-samples">
<span class="header-section-number">5.2.1</span> Generating samples from the predictive distribution of <span class="math inline">\(S(\tilde{X})\)</span> (continue from <a href="03_model-fitting.html#sec-liberia-estim1" class="quarto-xref"><span>Section 3.3.1</span></a>)</h3>
<p>We now show how the ideas and concepts discussed above are put into practice in an geostatistical analysis, using the Liberia data example. Using the fitted model in <a href="03_model-fitting.html#sec-liberia-estim1" class="quarto-xref"><span>Section 3.3.1</span></a>, we use the <code>predict_over_grid</code> function in <code>RiskMap</code>, to sample from the predictive distribution of the spatial Gaussian process <span class="math inline">\(S(x)\)</span> based on a regular grid spanning the country of Liberia.</p>
<p>The <code>pred_over_grid</code> function enables us to predict the the separate effects of the covariates, given by <span class="math inline">\(d(x)^\top \beta\)</span>, and the spatial random effects, <span class="math inline">\(S(x)\)</span>, at any desired location <span class="math inline">\(x\)</span>. Hence, before we can use the <code>pred_over_grid</code> function, we need to do 1) obtain a shape file that defines the boundaries of our study area, 2) use that to create a regular grid and 3) extract the covariates values at those locations. The R script below performs all these steps.</p>
<div class="cell">
<div class="sourceCode" id="cb1" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># 1) Obtaining Liberia boundaries </span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/wmgeolab/rgeoboundaries">rgeoboundaries</a></span><span class="op">)</span></span>
<span><span class="va">liberia_adm0</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/rgeoboundaries/man/geoboundaries.html">geoboundaries</a></span><span class="op">(</span><span class="st">"liberia"</span>, adm_lvl <span class="op">=</span> <span class="st">"adm0"</span><span class="op">)</span></span>
<span><span class="va">liberia_adm0</span> <span class="op">&lt;-</span> <span class="fu">st_transform</span><span class="op">(</span><span class="va">liberia_adm0</span>, crs <span class="op">=</span> <span class="fl">32629</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 2) Create the grid at 5 km resolution</span></span>
<span><span class="va">liberia_grid</span> <span class="op">&lt;-</span> <span class="fu">create_grid</span><span class="op">(</span><span class="va">liberia_adm0</span>, spat_res <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Download elevation data</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/jhollist/elevatr/">elevatr</a></span><span class="op">)</span></span>
<span><span class="va">liberia_elev</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/elevatr/man/get_elev_raster.html">get_elev_raster</a></span><span class="op">(</span>locations <span class="op">=</span> <span class="va">liberia_adm0</span>, </span>
<span>                                z <span class="op">=</span> <span class="fl">5</span>, clip <span class="op">=</span> <span class="st">"locations"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 3) Extracting elevation at the grid locations</span></span>
<span><span class="va">lb_predictors</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span>elevation <span class="op">=</span> </span>
<span>                         <span class="fu">terra</span><span class="fu">::</span><span class="fu"><a href="https://rspatial.github.io/terra/reference/extract.html">extract</a></span><span class="op">(</span><span class="va">liberia_elev</span>,</span>
<span>                                <span class="fu">st_coordinates</span><span class="op">(</span><span class="va">liberia_grid</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In the code above, we generated a prediction grid — which, we recall, that we denote as <span class="math inline">\(\tilde{X}\)</span> — with a spatial resolution of 5 km. Generally, a higher spatial resolution (note that a “higher spatial resolution” corresponds to a lower value for <code>spat_res</code>) yields more detailed prediction maps but also increases the computational cost. In this case, the choice of a 5 km grid strikes a balance between sufficient visualization clarity and manageable computation time.</p>
<p>At this point, we have all the necessary inputs to execute the <code>pred_over_grid</code> function for both marginal and joint predictions, as demonstrated below.</p>
<div class="cell">
<div class="sourceCode" id="cb2" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Predicting the spatial process S(x) over the grid, as well as</span></span>
<span><span class="co"># covariates effects</span></span>
<span></span>
<span><span class="co"># Marginal predictions</span></span>
<span><span class="va">lb_pred_S_m</span> <span class="op">&lt;-</span> <span class="fu">pred_over_grid</span><span class="op">(</span><span class="va">fit_liberia</span>, </span>
<span>                            grid_pred <span class="op">=</span> <span class="va">liberia_grid</span>, </span>
<span>               predictors <span class="op">=</span> <span class="va">lb_predictors</span>, messages <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>               type <span class="op">=</span> <span class="st">"marginal"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Joint predictions</span></span>
<span><span class="va">lb_pred_S_j</span> <span class="op">&lt;-</span> <span class="fu">pred_over_grid</span><span class="op">(</span><span class="va">fit_liberia</span>, </span>
<span>                            grid_pred <span class="op">=</span> <span class="va">liberia_grid</span>, </span>
<span>               predictors <span class="op">=</span> <span class="va">lb_predictors</span>, messages <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>               type <span class="op">=</span> <span class="st">"joint"</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Both <code>lb_pred_S_m</code> and <code>lb_pred_S_j</code> contain lists with the same arguments, with one key difference: the samples in the list element named <code>S_samples</code> for the former are drawn from the marginal predictive distributions of the components of <span class="math inline">\(S(\tilde{X})\)</span>, while for the latter, they come from the joint predictive distribution of <span class="math inline">\(S(\tilde{X})\)</span>.</p>
<p>An important note is that in the code above we have used the default settings for the Markov Chain Monte Carlo (MCMC). To change these setting use the function <code>set_control_sim</code> whose output should be passed to the argument <code>contol_sim</code> of <code>pred_over_grid</code>. The diagnostic on the convergence of the MCMC can also be applying the <code>check_mcmc</code> function to either <code>lb_pred_S_m</code> or <code>lb_pred_S_j</code>; see <a href="03_model-fitting.html#sec-summary" class="quarto-xref"><span>Section 3.4.2.3</span></a> for more details.</p>
<p>We can inspect the predictive distribution of any component <span class="math inline">\(S(\tilde{X})\)</span> through the Monte Carlo samples stored in <code>S_samples</code>. For example, the script below generates the histogram for the predictive distribution of the first component of <span class="math inline">\(S(\tilde{X})\)</span> (<a href="#fig-hist-first-comp-pd" class="quarto-xref">Figure&nbsp;<span>5.1</span></a>).</p>
<div class="cell">
<div class="sourceCode" id="cb3" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html">hist</a></span><span class="op">(</span><span class="va">lb_pred_S_m</span><span class="op">$</span><span class="va">S_samples</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span>, main <span class="op">=</span> <span class="st">"Predictive distribution"</span>,</span>
<span>     xlab <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/expression.html">expression</a></span><span class="op">(</span><span class="fu">S</span><span class="op">(</span><span class="fu">tilde</span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div id="fig-hist-first-comp-pd" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-hist-first-comp-pd-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="05_geostatistical-prediction_files/figure-html/fig-hist-first-comp-pd-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-hist-first-comp-pd-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5.1: Histrogram of the predictive distribution of the first component, <span class="math inline">\(S(\tilde{x}_1)\)</span> of <span class="math inline">\(S(\tilde{X})\)</span> for the Liberia data analysis.
</figcaption></figure>
</div>
</div>
</div>
</section></section><section id="sec-spat-cont-target" class="level2" data-number="5.3"><h2 data-number="5.3" class="anchored" data-anchor-id="sec-spat-cont-target">
<span class="header-section-number">5.3</span> Spatially continuous targets</h2>
<p>In the previous section, we explained and demonstrated how to obtain Monte Carlo samples from the predictive distribution of <span class="math inline">\(S(\tilde{X})\)</span>, which we denoted by <span class="math inline">\([S(\tilde{X}) \: |\: y]\)</span>. Let <span class="math inline">\(S_{(j)}(\tilde{X})\)</span> and <span class="math inline">\([S(\tilde{X}) \: |\: y]\)</span> represent the <span class="math inline">\(j\)</span>-th Monte Carlo samples for the entire grid and the specific location <span class="math inline">\(x_k\)</span>, respectively, for <span class="math inline">\(j=1,\ldots,B\)</span> and <span class="math inline">\(k=1,\ldots,q\)</span>.</p>
<p>We define our predictive target, <span class="math inline">\(T(x)\)</span>, at any given location <span class="math inline">\(x\)</span>, as a transformation of <span class="math inline">\(S(x)\)</span>. Thus, we express it as <span class="math inline">\(T(x) = f\{S(x)\}\)</span>. Note that <span class="math inline">\(f(\cdot)\)</span> can represent any type of non-linear transformation of <span class="math inline">\(S(x)\)</span> and may include covariate effects and other non-structured random effects. A list of common predictive targets frequently used in geostatistical analysis is provided in <a href="#tbl-spat-cont-pred-target" class="quarto-xref">Table&nbsp;<span>5.1</span></a>.</p>
<div id="tbl-spat-cont-pred-target" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-spat-cont-pred-target-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;5.1: List of some of the most common spatially continuous predictive targets in a geostatistical analysis. For each target, we also indicate the generalized linear model (GLM) family for which these can be defined. Note that this list not exhaustive and different predictive other than those listed in the table could also be considered.
</figcaption><div aria-describedby="tbl-spat-cont-pred-target-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<colgroup>
<col style="width: 38%">
<col style="width: 30%">
<col style="width: 31%">
</colgroup>
<thead><tr class="header">
<th>Predictive target <span class="math inline">\(T(x)\)</span>
</th>
<th>Name of the predictive target</th>
<th>Generalized linear model (GLM) family</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(d(x)^\top \beta + S(x)\)</span></td>
<td>Linear predictor</td>
<td>Any GLM</td>
</tr>
<tr class="even">
<td><span class="math inline">\(\frac{\exp\{d(x)^\top \beta + S(x)\}}{1+\exp\{d(x)^\top \beta + S(x)\}}\)</span></td>
<td>Prevalence</td>
<td>Binomial</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\exp\{d(x)^\top \beta + S(x)\}\)</span></td>
<td>Mean number of cases</td>
<td>Poisson</td>
</tr>
<tr class="even">
<td><span class="math inline">\(S(x)\)</span></td>
<td>Spatial random effects</td>
<td>Any GLM</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(d(x)^\top \beta\)</span></td>
<td>Covariates effects</td>
<td>Any GLM</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>An important feature of the predictive targets listed in <a href="#tbl-spat-cont-pred-target" class="quarto-xref">Table&nbsp;<span>5.1</span></a> is that none of them include the nugget effect, denoted by <span class="math inline">\(Z_i\)</span> in our linear predictor definition for generalized linear geostatistical models. The reason for excluding <span class="math inline">\(Z_i\)</span> from the predictive targets is that, in most cases, it lacks a clear, unambiguous scientific interpretation. However, <span class="math inline">\(Z_i\)</span> might be included, for example, in environmental studies focusing on highly localized phenomena where measurement error or small-scale variability is of direct scientific interest; or in epidemiological studies where inferences at the individual level, rather than the population level, are required, and where <span class="math inline">\(Z_i\)</span> is introduced to account for unexplained individual-level variation. It is also worth noticing, the primary impact of including <span class="math inline">\(Z_i\)</span> in <span class="math inline">\(T(x)\)</span> would be an increase in the uncertainty of predictive inferences for <span class="math inline">\(T(x)\)</span>, with minimal effect (or none at all, if <span class="math inline">\(T(x)\)</span> corresponds to the linear predictor) on the point predictions.</p>
<p>The predictive targets in <a href="#tbl-spat-cont-pred-target" class="quarto-xref">Table&nbsp;<span>5.1</span></a> corresponding to <span class="math inline">\(d(x)^\top \beta\)</span> or the spatial random effects <span class="math inline">\(S(x)\)</span> might be considered when the goal is to highlight the different contribution to the overall predictive inferences from the measured covariates.</p>
<section id="sec-liberia-prediction-1" class="level3" data-number="5.3.1"><h3 data-number="5.3.1" class="anchored" data-anchor-id="sec-liberia-prediction-1">
<span class="header-section-number">5.3.1</span> Example: mapping riverblidness prevalence in Liberia (continuing from <a href="#sec-pred-samples" class="quarto-xref"><span>Section 5.2.1</span></a>)</h3>
<p>Let us continue the geostatistical of the riverblindness data in Liberia. The predictive target we consider is prevalence, hence <span id="eq-rb-prev-target"><span class="math display">\[T(x) = \frac{\exp\{ \beta_{0} + \beta_{1}\log\{e(x)\} + S(x)\}}{1+\exp\{\beta_{0} + \beta_{1}\log\{e(x)\} + S(x)\}}, \tag{5.1}\]</span></span> where <span class="math inline">\(e(x)\)</span> is the elevation in meters at location <span class="math inline">\(x\)</span>.</p>
<p>Through the <code>pred_target_grid</code> we can use the output in <code>lb_pred_S_m</code> (or <code>lb_pred_S_j</code> as well, in this case) to generate predictions of prevalence over the regular grid at 5 km we have created earlier.</p>
<div class="cell">
<div class="sourceCode" id="cb4" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span></span>
<span><span class="co"># Prediction of riverblindness prevalence</span></span>
<span><span class="va">lb_prev</span> <span class="op">&lt;-</span> </span>
<span><span class="fu">pred_target_grid</span><span class="op">(</span></span>
<span>  <span class="va">lb_pred_S_m</span>, </span>
<span>  f_target <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>prev <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">lp</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">lp</span><span class="op">)</span><span class="op">/</span><span class="op">(</span><span class="fl">1</span><span class="op">+</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">lp</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  pd_summary <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>mean <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">Tx</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="va">Tx</span><span class="op">)</span>, </span>
<span>                    cv <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">Tx</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/stats/sd.html">sd</a></span><span class="op">(</span><span class="va">Tx</span><span class="op">)</span><span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="va">Tx</span><span class="op">)</span>,</span>
<span>                    exceed20 <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">Tx</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="va">Tx</span> <span class="op">&gt;</span> <span class="fl">0.2</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In the function above the argument <code>f_target</code> can take a list of functions, as multiple predictive targets can be defined. Here, we only specified prevalence (<code>prev</code>). Note that in defining the predictive target in <code>f_target</code>, we need to express that as a function of <span class="math inline">\(d(x)^\top \beta + S(x)\)</span>. The argument <code>include_covariates</code> also allows us to define predictive target that do not use covariates from the model. By default <code>include_covariates = TRUE</code>, hence in the code above covariates are part of what is defined as <code>lp</code>. To predict the spatial random effects <span class="math inline">\(S(x)\)</span> only, for example, you can set <code>include_covariates = FALSE</code> and <code>f_target = list(Sx = function(lp) lp)</code>. In <code>pd_summary</code>, we define the summaries that we want to visualize from the predictive distribution. Here, we have specified the mean, coefficient of variation and the probability of exceeding a 20<span class="math inline">\(\%\)</span> prevalence threshold.</p>
<p>We can then visualize the resulting maps as follows.</p>
<div class="cell">
<div class="sourceCode" id="cb5" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Displying the results</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html">par</a></span><span class="op">(</span>mfrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">3</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">lb_prev</span>, which_target <span class="op">=</span> <span class="st">"prev"</span>, </span>
<span>     which_summary <span class="op">=</span> <span class="st">"mean"</span>, main <span class="op">=</span> <span class="st">"Mean"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">lb_prev</span>, which_target <span class="op">=</span> <span class="st">"prev"</span>, </span>
<span>     which_summary <span class="op">=</span> <span class="st">"cv"</span>, main <span class="op">=</span> <span class="st">"Coefficient of variation"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">lb_prev</span>, which_target <span class="op">=</span> <span class="st">"prev"</span>, </span>
<span>     which_summary <span class="op">=</span> <span class="st">"exceed20"</span>, main <span class="op">=</span> <span class="st">"Exceedance probability"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html">par</a></span><span class="op">(</span>mfrow<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">1</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div id="fig-lb-maps" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-lb-maps-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="05_geostatistical-prediction_files/figure-html/fig-lb-maps-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-lb-maps-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5.2: Mapping riverblindness in Liberia. Plots of the mean (left panel), coefficient of variation (central panel) and exceedance probability (right panel) for a 20% prevalence threshold.
</figcaption></figure>
</div>
</div>
</div>
<p>The maps in <a href="#fig-lb-maps" class="quarto-xref">Figure&nbsp;<span>5.2</span></a> indicate a higher prevalence as we move away from the coast and at higher altitudes. A very similar spatial pattern is observed in the likelihood of exceeding 20<span class="math inline">\(\%\)</span> prevalence. Also, based on the map of the coefficient of variation, the uncertainty around the point predictions of prevalence is higher along the coast and lower in the inland areas of Liberia.</p>
</section><section id="sec-non-spar-covariates" class="level3" data-number="5.3.2"><h3 data-number="5.3.2" class="anchored" data-anchor-id="sec-non-spar-covariates">
<span class="header-section-number">5.3.2</span> Example: mapping malaria using age and elevation as predictors</h3>
<p>We now consider an example on malaria mapping, where we use two different types of covariates: a spatially referenced covariate corresponding to elevation; the individual age. We use the <code>malkenya_comm</code> subset of the <code>malkenya</code> data-set (see <a href="03_model-fitting.html#sec-indiv-expl-analysis" class="quarto-xref"><span>Section 3.1.1.2</span></a>) and, to alleviate the computational burden, we further reduce this data-set by taking the first 1000 rows. Hence, we create our new data-set, <code>malkenya_comm1000</code>, using the followind code.</p>
<div class="cell">
<div class="sourceCode" id="cb6" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">malkenya_comm1000</span> <span class="op">&lt;-</span> <span class="va">malkenya_comm</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">1000</span>,<span class="op">]</span></span>
<span></span>
<span><span class="va">malkenya_comm1000</span> <span class="op">&lt;-</span> <span class="fu">st_as_sf</span><span class="op">(</span><span class="va">malkenya_comm1000</span>, coords <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Long"</span>, <span class="st">"Lat"</span><span class="op">)</span>,</span>
<span>                              crs <span class="op">=</span> <span class="fl">4326</span><span class="op">)</span></span>
<span><span class="va">malkenya_comm1000</span> <span class="op">&lt;-</span> <span class="fu">st_transform</span><span class="op">(</span><span class="va">malkenya_comm1000</span>, crs <span class="op">=</span> <span class="fl">32736</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Based on the exploratory analysis shown in <a href="03_model-fitting.html#sec-indiv-expl-analysis" class="quarto-xref"><span>Section 3.1.1.2</span></a>, we consider a geostatistical model fitted to the individual binary outcomes, <span class="math inline">\(Y_{ij}\)</span>, which correspond the rapid diagnostic test (RDT) results for the <span class="math inline">\(j\)</span>-th individual in the <span class="math inline">\(i\)</span>-th community, and take value <span class="math inline">\(Y_{ij}=1\)</span> if the RDT is positive and <span class="math inline">\(Y_{ij}=0\)</span> if the RDT is negative. Using a Binomial geostatistical model, we model the individual probability, <span class="math inline">\(p_{ij}\)</span> of a positive RDT using the following linear predictor. <span id="eq-lp-malkenya"><span class="math display">\[
\log\left\{\frac{p_{ij}}{1-p_{ij}}\right\} = \beta_{0} + \beta_{1}a_{ij}+\beta_{2} \times\max\{a_{ij}-15, 0\} + \beta_{3}\max\{a_{ij}-40, 0\} + \beta_{4} e(x_i) + S(x_i),
\tag{5.2}\]</span></span> where <span class="math inline">\(e(x_{i})\)</span> and <span class="math inline">\(a_{ij}\)</span> are the elevation in meter and the age in years for the <span class="math inline">\(j\)</span>-th individual residing at the <span class="math inline">\(i\)</span>-th household, respectively.</p>
<p>When using the model in <a href="#eq-lp-malkenya" class="quarto-xref">Equation&nbsp;<span>5.2</span></a> to predict RDT prevalence, a key question arises: how should we handle the age variable, which, unlike elevation, is not available as a geo-referenced covariate at all locations in the study area? The answer depends on the research question being addressed.</p>
<p>For instance, if the goal is to infer disease risk across different age groups, we can generate different maps for each group of interest. This can be easily achieved by fixing the value of <span class="math inline">\(a_{ij}\)</span> to a specific age for all prediction locations. Alternatively, if the objective is to generate a predictive map for the general population, rather than for a specific age group, we must employ a probabilistic model for age and integrate out its effect.</p>
<p>Developing a credible probabilistic model for age is beyond the scope of this section. Instead, we demonstrate a simple yet reasonable solution which uses the empirical age distribution from the data. By random sampling from this distribution, we can then assign age values to prediction locations. The steps are as follows.</p>
<ol type="1">
<li>Obtain the empirical distribution of age from the data.</li>
<li>Sample with replacement from such distribution (the <code>sample</code> function in R can be used for this purpose) as many times as the number of prediction locations, so that each grid location <span class="math inline">\(\tilde{x}\)</span> has a value of age assigned.</li>
<li>Generate a sample from the predictive distribution of the target <span class="math inline">\(T(\tilde{x})\)</span> at each of the grid locations <span class="math inline">\(\tilde{x}\)</span>.</li>
<li>Repeat 1 to 3, for as many times as the samples generates from <span class="math inline">\(S(\tilde{X})\)</span>.</li>
</ol>
<p>This approach relies on two key assumptions. First, that the age distribution is spatially neutral, i.e., it does not vary across space. Second, that the data are representative of the age distribution in the target population. In the data used for this example, we believe these assumptions are reasonable, given the relatively small study area, where age is unlikely to exhibit significant spatial variation, and the fact that the data are a random sample from the community.</p>
<p>In the scripts presented in the remainder of this section, we show how to generate a predictive map of prevalence for children age 15 years, and another map that instead uses the approach earlier described to remove the effect of age and generate a map of prevalence for the general population.</p>
<p>First, we fit the model. Note that the effect of age is not linear and we use linear splines to account for this, using the results of the exploratory analysis shown in @<a href="03_model-fitting.html#sec-indiv-expl-analysis" class="quarto-xref"><span>Section 3.1.1.2</span></a>.</p>
<div class="cell">
<div class="sourceCode" id="cb7" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">fit_malkenya</span> <span class="op">&lt;-</span> <span class="fu">glgpm</span><span class="op">(</span><span class="va">RDT</span> <span class="op">~</span> <span class="va">Age</span> <span class="op">+</span>  <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">pmax</a></span><span class="op">(</span><span class="va">Age</span><span class="op">-</span><span class="fl">15</span>, <span class="fl">0</span><span class="op">)</span> <span class="op">+</span> </span>
<span>                        <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">pmax</a></span><span class="op">(</span><span class="va">Age</span><span class="op">-</span><span class="fl">40</span>, <span class="fl">0</span><span class="op">)</span> <span class="op">+</span> <span class="va">elevation</span> <span class="op">+</span></span>
<span>                        <span class="fu">gp</span><span class="op">(</span><span class="op">)</span>,</span>
<span>                      data <span class="op">=</span> <span class="va">malkenya_comm1000</span>,</span>
<span>                      family <span class="op">=</span> <span class="st">"binomial"</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>After fitting the model, we create a prediction grid at a spatial resolution of 500 meters and extract the values of elevation. In this analysis, due to the small size of the study area, we do not use administrative boundaries as they are too large. Instead, we use the convex hull<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> of the sample locations to define the boundaries of our study area.</p>
<div class="cell">
<div class="sourceCode" id="cb8" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Create grid from convex hull</span></span>
<span><span class="va">shp_ch</span> <span class="op">&lt;-</span> <span class="fu">convex_hull_sf</span><span class="op">(</span><span class="va">malkenya_comm1000</span><span class="op">)</span></span>
<span><span class="va">ken_grid</span> <span class="op">&lt;-</span> <span class="fu">create_grid</span><span class="op">(</span><span class="va">shp_ch</span>, spat_res <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Get elevation raster</span></span>
<span><span class="va">ken_elev</span> <span class="op">&lt;-</span> </span>
<span><span class="fu"><a href="https://rdrr.io/pkg/elevatr/man/get_elev_raster.html">get_elev_raster</a></span><span class="op">(</span>locations <span class="op">=</span> <span class="va">shp_ch</span>, </span>
<span>                z <span class="op">=</span> <span class="fl">9</span>, clip <span class="op">=</span> <span class="st">"locations"</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We then create the data frame of predictors where age is set to 15.</p>
<div class="cell">
<div class="sourceCode" id="cb9" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Create the data fr</span></span>
<span><span class="va">ken_predictors</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span>elevation <span class="op">=</span> </span>
<span>                           <span class="fu">extract</span><span class="op">(</span><span class="va">ken_elev</span>, <span class="fu">st_coordinates</span><span class="op">(</span><span class="va">ken_grid</span><span class="op">)</span><span class="op">)</span>,</span>
<span>                         Age <span class="op">=</span> <span class="fl">15</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We now have all the ingredients to carry out prediction.</p>
<div class="cell">
<div class="sourceCode" id="cb10" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">pred_ken_S</span> <span class="op">&lt;-</span> <span class="fu">pred_over_grid</span><span class="op">(</span><span class="va">fit_malkenya</span>, grid_pred <span class="op">=</span> <span class="va">ken_grid</span>,</span>
<span>                             predictors <span class="op">=</span> <span class="va">ken_predictors</span><span class="op">)</span></span>
<span></span>
<span><span class="va">pred_age15</span> <span class="op">&lt;-</span> </span>
<span><span class="fu">pred_target_grid</span><span class="op">(</span><span class="va">pred_ken_S</span>, </span>
<span>                 f_target <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>prev <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">lp</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">lp</span><span class="op">)</span><span class="op">/</span><span class="op">(</span><span class="fl">1</span><span class="op">+</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">lp</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>,</span>
<span>                 pd_summary <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>mean <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">Tx</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="va">Tx</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The code below shows how to perform the 4 steps described above to generate a predictive map for the general population. Below we use the function <code>update_predictors</code> to update the covariates effects that are stored in <code>mu_pred</code>, a list element generated as the output of <code>pred_over_grid</code>.</p>
<div class="cell">
<div class="sourceCode" id="cb11" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Number of Monte Carlo samples</span></span>
<span><span class="va">n_sim</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">ncol</a></span><span class="op">(</span><span class="va">pred_age15</span><span class="op">$</span><span class="va">lp_samples</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Number of prediction locations</span></span>
<span><span class="va">n_pred</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">predictors</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># The create object `pred_ken_S_i` with the goal of changing the </span></span>
<span><span class="co"># coviariates effects stored in `mu_pred` according the sample values of age</span></span>
<span><span class="va">pred_ken_S_i</span> <span class="op">&lt;-</span> <span class="va">pred_ken_S</span></span>
<span><span class="va">pred_ken_S_i</span><span class="op">$</span><span class="va">mu_pred</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="cn">NA</span>, nrow <span class="op">=</span> <span class="va">n_pred</span>, ncol <span class="op">=</span> <span class="va">n_sim</span><span class="op">)</span></span>
<span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">n_sim</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="co"># Generate n_pred samples from the empirical distribution of age</span></span>
<span>  <span class="va">ken_predictors</span><span class="op">$</span><span class="va">Age</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html">sample</a></span><span class="op">(</span><span class="va">malkenya_comm1000</span><span class="op">$</span><span class="va">Age</span>, <span class="va">n_pred</span>, replace <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span>  <span class="co"># Generate the new covariates effects with `update_predictors` and store them in </span></span>
<span>  <span class="co"># `mu_pred`</span></span>
<span>  <span class="va">pred_ken_S_i</span><span class="op">$</span><span class="va">mu_pred</span><span class="op">[</span>,<span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu">update_predictors</span><span class="op">(</span><span class="va">pred_ken_S</span>, <span class="va">ken_predictors</span><span class="op">)</span><span class="op">$</span><span class="va">mu_pred</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co"># Prediction of prevalence</span></span>
<span><span class="va">pred_aver_pop</span> <span class="op">&lt;-</span> <span class="fu">pred_target_grid</span><span class="op">(</span><span class="va">pred_ken_S_i</span>, </span>
<span>               f_target <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>prev <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">lp</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">lp</span><span class="op">)</span><span class="op">/</span><span class="op">(</span><span class="fl">1</span><span class="op">+</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">lp</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can now plot the two maps and compare them.</p>
<div class="cell">
<div class="sourceCode" id="cb12" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html">par</a></span><span class="op">(</span>mfrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">2</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">pred_age15</span>, which_target <span class="op">=</span> <span class="st">"prev"</span>, which_summary <span class="op">=</span> <span class="st">"mean"</span>, main <span class="op">=</span> <span class="st">"Prevalence (15 years)"</span>, range <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">0.6</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">pred_aver_pop</span>, which_target <span class="op">=</span> <span class="st">"prev"</span>, which_summary <span class="op">=</span> <span class="st">"mean"</span>,  main <span class="op">=</span> <span class="st">"Prevalence (General population)"</span>, range <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">0.6</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html">par</a></span><span class="op">(</span>mfrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">1</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div id="fig-malaria-maps" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-malaria-maps-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="05_geostatistical-prediction_files/figure-html/fig-malaria-maps-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-malaria-maps-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5.3: Maps of the predictive mean of the rapid diagnostic test (RDT) prevalence for children of the age of 15 (left panel) and the general population (right panel).
</figcaption></figure>
</div>
</div>
</div>
<p>The exploratory analysis of <a href="03_model-fitting.html#sec-indiv-expl-analysis" class="quarto-xref"><span>Section 3.1.1.2</span></a> had shown that the prevalence around the age of 15 is higher than at other ages. This is also reflected in <a href="#fig-malaria-maps" class="quarto-xref">Figure&nbsp;<span>5.3</span></a>, when the left panel, corresponding to the RDT prevalence for children at the age of 15 years, shows a higher level of prevalence than the right panel, which is instead for the general population.</p>
</section></section><section id="sec-areal-target" class="level2" data-number="5.4"><h2 data-number="5.4" class="anchored" data-anchor-id="sec-areal-target">
<span class="header-section-number">5.4</span> Areal-level targets</h2>
<p>When determining areal-level targets, we must first address the following questions:</p>
<ol type="1">
<li>What spatially continuous target, <span class="math inline">\(T(x)\)</span>, are we seeking to aggregate?</li>
<li>What are the spatial units, denoted as <span class="math inline">\(A_i\)</span> for <span class="math inline">\(i = 1, \dots, N\)</span>, over which the aggregation is required?</li>
<li>What aggregating function should be applied?</li>
<li>Should spatial weights be incorporated in the aggregation, and if so, what weights are appropriate?</li>
</ol>
<p>The first question was discussed in earlier sections, where examples of predictive targets that define <span class="math inline">\(T(x)\)</span> can be found in <a href="#tbl-spat-cont-pred-target" class="quarto-xref">Table&nbsp;<span>5.1</span></a>. The answers to the remaining questions are context-dependent and closely linked to the primary research objectives. In public health settings, the areas <span class="math inline">\(A_i\)</span> often correspond to administrative units or regions where decisions are made and resources are allocated.</p>
<p>A common aggregating function for <span class="math inline">\(T(x)\)</span> is the mean, which is formally defined as:</p>
<p><span id="eq-mean-alt"><span class="math display">\[
\mathcal{M}_i = \frac{1}{|A_i|}\int_{A_i} T(x) \: dx.
\tag{5.3}\]</span></span></p>
<p>In addition to the mean, several other aggregating functions can be applied depending on the context of the analysis. We also note that computing the integral in <a href="#eq-mean-alt" class="quarto-xref">Equation&nbsp;<span>5.3</span></a> requires some approximations. Our approach utilizes the regular grid <span class="math inline">\(\tilde{X}\)</span>, previously defined when dealing with spatially continuous targets. This grid covers the area <span class="math inline">\(A_i\)</span>, allowing us to approximate <span class="math inline">\(M_i\)</span> as: <span id="eq-mean-alt-approx"><span class="math display">\[\mathcal{M}_i \approx \frac{1}{\#\{j : \tilde{x}_j \in A_i\}} \sum_{\tilde{x}_j \in A_i} T(\tilde{x}_j),  \tag{5.4}\]</span></span> where <span class="math inline">\(\#\{j : \tilde{x}_j \in A_i\}\)</span> denotes the number of grid locations <span class="math inline">\(\tilde{x}_j\)</span> that fall within <span class="math inline">\(A_i\)</span>. The same approximation will be applied to other areal-level targets discussed in this section. However, for simplicity, we will omit the detailed explanation of this step and instead express the predictive target as an integral.</p>
<p>For instance, in the study of Anopheles mosquitoes in Cameroon, we may be interested in estimating the total number of mosquitoes trapped within the study area (<span class="math inline">\(A_i\)</span> represents a single region in this case). If <span class="math inline">\(T(x)\)</span> denotes the number of mosquitoes trapped at location <span class="math inline">\(x\)</span>, the areal-level target can be expressed as: <span class="math display">\[
  \mathcal{S}_i = \int_{A_i} T(x) \: dx.
  \]</span></p>
<p>Additionally, to capture the heterogeneity of <span class="math inline">\(T(x)\)</span> within an area, variance-based measures can be used. The variance of <span class="math inline">\(T(x)\)</span> in <span class="math inline">\(A_i\)</span> is given by: <span class="math display">\[
   \mathcal{V}_i = \frac{1}{|A_i|}\int_{A_i} \left(T(x) - \mathcal{M}_i\right)^2 \: dx,
   \]</span> where <span class="math inline">\(\mathcal{M}_i\)</span> is the mean of <span class="math inline">\(T(x)\)</span> in <span class="math inline">\(A_i\)</span>.</p>
<p>The formulation of the areal-level targets given so far assumes equal weighting for all locations within the area. Alternatively, if the we consider for example the areal level target in <a href="#eq-mean-alt" class="quarto-xref">Equation&nbsp;<span>5.3</span></a>, one could use spatial weights, <span class="math inline">\(w(x) &gt; 0\)</span>, and redefine <span class="math inline">\(\mathcal{M}_i\)</span> as:</p>
<p><span class="math display">\[
\mathcal{M}_i = \frac{\int_{A_i} w(x) T(x) \: dx}{\int_{A_i} w(x) \: dx}.
\]</span></p>
<p>Selecting appropriate spatial weights is crucial, as it reflects the significance of different locations within the area. We can define three types of weighting: population-density, risk-based, and distance-based. We point out that this distinction is not always clear cut (population could indeed be a risk factor in our analysis) but this classification is made only for the sake of making the explanation clearer.</p>
<p>For example, if the goal is to prioritize areas with higher populations, weights <span class="math inline">\(w(x)\)</span> could be proportional to population density at location <span class="math inline">\(x\)</span>. This approach gives greater importance to locations where more people reside, which can be particularly relevant when aggregating disease prevalence data for resource allocation.</p>
<p>In cases where certain sub-regions within <span class="math inline">\(A_i\)</span> are at higher risk for disease (e.g., proximity to environmental hazards or areas with lower access to healthcare), risk-based weights could be applied. Here, <span class="math inline">\(w(x)\)</span> would be higher in regions identified as higher risk, providing a more targeted aggregation of disease prevalence. For example, populations in rural areas may face higher exposure to infectious diseases than those in urban areas, making it important to assign greater weight to these higher-risk regions in the aggregation process.</p>
<p>If the objective is to account for proximity effects (such as the spread of an infectious disease or contamination from a known source), distance-based weights could be used. Locations closer to a known disease outbreak area or source of exposure could be given more weight to reflect the spatial dynamics of disease transmission.</p>
<p>Using spatial weights in these ways ensures that the aggregation of disease prevalence <span class="math inline">\(T(x)\)</span> reflects not only the distribution of the disease but also the underlying population, risk, or spatial characteristics relevant to the public health problem under investigation.</p>
<section id="sec-liberia-prediction-2" class="level3" data-number="5.4.1"><h3 data-number="5.4.1" class="anchored" data-anchor-id="sec-liberia-prediction-2">
<span class="header-section-number">5.4.1</span> Example: predicting the average riverblindness prevalence at admin level 1 in Liberia (continuing from <a href="#sec-liberia-prediction-1" class="quarto-xref"><span>Section 5.3.1</span></a>)</h3>
<p>We continue our analysis of the Liberia data and consider areal-level targets. More specifically, we aim to predict the average prevalence over the regions which give the administrative level 1 of Liberia. By denoting with <span class="math inline">\(A_i\)</span> the i-th out of the 15 regions in Liberia. By denoting with <span class="math inline">\(T(x)\)</span> reiverblindness prevalence as defined in <a href="#eq-rb-prev-target" class="quarto-xref">Equation&nbsp;<span>5.1</span></a>, we define our predictive target as <span class="math display">\[
T_{i} = \frac{1}{|A_i|} \int_{A_i} T(x) \: dx.
\]</span> The R code below shows how predictions for <span class="math inline">\(T_i\)</span> can be performed using the <code>pred_target_shp</code> function.</p>
<div class="cell">
<div class="sourceCode" id="cb13" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Admin level 1 boundaries</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/wmgeolab/rgeoboundaries">rgeoboundaries</a></span><span class="op">)</span></span>
<span><span class="va">lb_adm1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/rgeoboundaries/man/geoboundaries.html">geoboundaries</a></span><span class="op">(</span>country <span class="op">=</span> <span class="st">"Liberia"</span>, adm_lvl <span class="op">=</span> <span class="st">"adm1"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Prediction of prevalence </span></span>
<span><span class="va">pred_shp</span> <span class="op">&lt;-</span> <span class="fu">pred_target_shp</span><span class="op">(</span><span class="va">lb_pred_S_j</span>, shp <span class="op">=</span> <span class="va">lb_adm1</span>,</span>
<span>                            shp_target <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">Tx</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="va">Tx</span><span class="op">)</span>,</span>
<span>                            f_target <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>prev <span class="op">=</span> </span>
<span>                                       <span class="kw">function</span><span class="op">(</span><span class="va">lp</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">lp</span><span class="op">)</span><span class="op">/</span><span class="op">(</span><span class="fl">1</span><span class="op">+</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">lp</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>,</span>
<span>                            pd_summary <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>mean <span class="op">=</span> <span class="va">mean</span><span class="op">)</span>,</span>
<span>                            col_names <span class="op">=</span> <span class="st">"shapeName"</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The argument <code>shp_target</code> is used define the type of aggregation function over the region <span class="math inline">\(A_i\)</span>, in this case the mean of the target <span class="math inline">\(T(x)\)</span>. Also note that, like for spatially continuous targets, we can define any summary of the predictive distribution of <span class="math inline">\(\mathcal{M}_i\)</span> through the argument <code>pd_summary</code>. Here, we chose to compute only the mean of the predictive distribution but other summaries, such as exceedance probabilities, standard error, quantiles and so on, can be specified if needed.</p>
<p>Before we plot the results on a map, let us also consider the population-density weighted target, defined as <span class="math display">\[
T_{i}^* = \frac{ \int_{A_i} w(x) T(x) \: dx}{\int_{A_i} w(x) \: dx}.
\]</span> To aid the explanation of the R code script, we first rewrite the above areal-level target as <span class="math display">\[
T_{i}^* = \int_{A_i} \tilde{w_i}(x) T(x) \: dx.
\]</span> where <span class="math inline">\(\tilde{w}_{i}(x)\)</span> are the standardized weights that integrate to 1 in <span class="math inline">\(A_i\)</span> (i.e.&nbsp;<span class="math inline">\(\int_{A_i} \tilde{w}_i(x) \: dx = 1\)</span>).</p>
<p>We first retrieve the population density data from the World Pop database (see <a href="02_handling-spatial-data.html#sec-pop-data" class="quarto-xref"><span>Section 2.4.2</span></a>) and use these to derive the un-standardized weights <span class="math inline">\(w(x)\)</span>.</p>
<div class="cell">
<div class="sourceCode" id="cb14" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span></span>
<span><span class="co"># Obtaining population density</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va">wpgpDownloadR</span><span class="op">)</span></span>
<span><span class="va">lbr_url</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/wpgpDownloadR/man/wpgpGetCountryDataset.html">wpgpGetCountryDataset</a></span><span class="op">(</span>ISO3 <span class="op">=</span> <span class="st">"LBR"</span>, covariate <span class="op">=</span> <span class="st">"ppp_2014"</span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://rspatial.org/">terra</a></span><span class="op">)</span></span>
<span><span class="va">lbr_pop</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/rast.html">rast</a></span><span class="op">(</span><span class="va">lbr_url</span><span class="op">)</span></span>
<span><span class="va">lbr_pop</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/project.html">project</a></span><span class="op">(</span><span class="va">lbr_pop</span>, <span class="st">"EPSG:32629"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Extra pop density weights at the prediction grid</span></span>
<span><span class="va">weights_pred</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/extract.html">extract</a></span><span class="op">(</span><span class="va">lbr_pop</span>, <span class="fu">st_coordinates</span><span class="op">(</span><span class="va">liberia_grid</span><span class="op">)</span><span class="op">)</span><span class="op">$</span><span class="va">lbr_ppp_2014</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In the code above the population density weights are extracted at the locations of the prediction grid. In the <code>pred_target_shp</code> function, in order to use the weights for our predictive target, we need to specify two additional arguments: <code>weights</code> to which we pass the population density values (in our case these are stored in <code>weights_pred</code>); <code>standardize_weights</code>, which is a logical argument taking value <code>TRUE</code> if the weights to be standardized so that the sum over the grid covering a region <span class="math inline">\(A_i\)</span> adds up to one.</p>
<div class="cell">
<div class="sourceCode" id="cb15" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">pred_shp_w</span> <span class="op">&lt;-</span> <span class="fu">pred_target_shp</span><span class="op">(</span><span class="va">lb_pred_S_j</span>, shp <span class="op">=</span> <span class="va">lb_adm1</span>,</span>
<span>                            shp_target <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">Tx</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">Tx</span><span class="op">)</span>,</span>
<span>                            f_target <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>prev <span class="op">=</span> </span>
<span>                                       <span class="kw">function</span><span class="op">(</span><span class="va">lp</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">lp</span><span class="op">)</span><span class="op">/</span><span class="op">(</span><span class="fl">1</span><span class="op">+</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">lp</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>,</span>
<span>                            pd_summary <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>mean <span class="op">=</span> <span class="va">mean</span><span class="op">)</span>,</span>
<span>                            weights <span class="op">=</span> <span class="va">weights_pred</span>,</span>
<span>                            standardize_weights <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>                            col_names <span class="op">=</span> <span class="st">"shapeName"</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can then finally plot the results from the prediction at admin level 1, without using any weights and by weighing according to population density.</p>
<div class="cell">
<div class="sourceCode" id="cb16" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">plot_1</span> <span class="op">&lt;-</span> </span>
<span><span class="fu"><a href="https://rspatial.github.io/terra/reference/plot.html">plot</a></span><span class="op">(</span><span class="va">pred_shp</span>, which_target <span class="op">=</span> <span class="st">"prev"</span>, which_summary <span class="op">=</span> <span class="st">"mean"</span>,</span>
<span>     palette <span class="op">=</span> <span class="st">"RdYlGn"</span>,</span>
<span>    limits <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.1</span>, <span class="fl">0.30</span><span class="op">)</span>,</span>
<span>    breaks <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">0.1</span>,<span class="fl">0.30</span>, by <span class="op">=</span> <span class="fl">0.05</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span> </span>
<span>  <span class="fu">guides</span><span class="op">(</span>fill<span class="op">=</span><span class="fu">guide_legend</span><span class="op">(</span>title<span class="op">=</span><span class="st">"Prevalence"</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ggtitle</span><span class="op">(</span><span class="st">"Average prevalence \n (no weights)"</span><span class="op">)</span> <span class="op">+</span> </span>
<span>   <span class="fu">theme</span><span class="op">(</span>plot.title <span class="op">=</span> <span class="fu">element_text</span><span class="op">(</span>size <span class="op">=</span> <span class="fl">15</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">plot_2</span>  <span class="op">&lt;-</span> </span>
<span>  <span class="fu"><a href="https://rspatial.github.io/terra/reference/plot.html">plot</a></span><span class="op">(</span><span class="va">pred_shp_w</span>, which_target <span class="op">=</span> <span class="st">"prev"</span>, which_summary <span class="op">=</span> <span class="st">"mean"</span>,</span>
<span>     palette <span class="op">=</span> <span class="st">"RdYlGn"</span>,</span>
<span>    limits <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.1</span>, <span class="fl">0.30</span><span class="op">)</span>,</span>
<span>    breaks <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">0.1</span>,<span class="fl">0.30</span>, by <span class="op">=</span> <span class="fl">0.05</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span> </span>
<span>  <span class="fu">guides</span><span class="op">(</span>fill<span class="op">=</span><span class="fu">guide_legend</span><span class="op">(</span>title<span class="op">=</span><span class="st">"Prevalence"</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ggtitle</span><span class="op">(</span><span class="st">"Average prevalence \n (population weighted)"</span><span class="op">)</span> <span class="op">+</span> </span>
<span>  <span class="fu">theme</span><span class="op">(</span>plot.title <span class="op">=</span> <span class="fu">element_text</span><span class="op">(</span>size <span class="op">=</span> <span class="fl">15</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va">gridExtra</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/gridExtra/man/arrangeGrob.html">grid.arrange</a></span><span class="op">(</span><span class="va">plot_1</span>, <span class="va">plot_2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div id="fig-average-prev-Liberia" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-average-prev-Liberia-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="05_geostatistical-prediction_files/figure-html/fig-average-prev-Liberia-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-average-prev-Liberia-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5.4: Maps of the predictive mean for the admin level 1 average prevalence in Liberia. The left panel uses a standard average of locations within an admin level 1 region, whilst in the right panel each location is weighted according to population density.
</figcaption></figure>
</div>
</div>
</div>
<p>In <a href="#fig-average-prev-Liberia" class="quarto-xref">Figure&nbsp;<span>5.4</span></a>, we observe that the differences between the two predictive targets, with and without weights, are not substantial. However, we observe that the predicted average prevalence shows slightly greater variation in coastal regions, particularly in Montserrado County, where the majority of the population residing in the capital of Monrovia. This concentration of population likely accounts for the more noticeable differences in this area.</p>
</section><section id="sec-anopheles-pred" class="level3" data-number="5.4.2"><h3 data-number="5.4.2" class="anchored" data-anchor-id="sec-anopheles-pred">
<span class="header-section-number">5.4.2</span> Example: predicting the total number of Anopheles gambiae mosquitoes (continuing from <a href="03_model-fitting.html#sec-anopheles-fit" class="quarto-xref"><span>Section 3.3.2</span></a>)</h3>
<p>For the analysis on Anopheles gambiae mosquitoes, we consider the prediction of the total number of mosquitoes within the study area. In this case, because there is not a natural definition of the study area borders as in the previous analysis, we consider the convex hull as representing those borders. To pursue this let us first, visualize the predictive map of the number of mosquitoes on a regular grid cover the study area. In other words, we first consider the spatially continuous target <span class="math display">\[
T(x) = \exp\{\beta_0 + \beta_1 e(x) + S(x)\},
\]</span> where, we recall, <span class="math inline">\(e(x)\)</span> is the elevation in meters at location <span class="math inline">\(x\)</span>. In the code below in addition to generate prediction for <span class="math inline">\(T(x)\)</span>, we also create a binary indicator defined as <span class="math display">\[
w(x) =
\begin{cases}
1 &amp; \text{if  } 390 &lt; e(x) &lt; 837 \\
0 &amp; \text{otherwise.}
\end{cases}
\]</span> The values of 390 and 837 meters correspond to the minimum and maximum values of elevation observed in the data.</p>
<div class="cell">
<div class="sourceCode" id="cb17" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Create grid from convex hull</span></span>
<span><span class="va">shp_ch</span> <span class="op">&lt;-</span> <span class="fu">convex_hull_sf</span><span class="op">(</span><span class="va">an_fit</span><span class="op">$</span><span class="va">data_sf</span><span class="op">)</span></span>
<span><span class="va">an_grid</span> <span class="op">&lt;-</span> <span class="fu">create_grid</span><span class="op">(</span><span class="va">shp_ch</span>, spat_res <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span></span>
<span><span class="va">an_elev</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/elevatr/man/get_elev_raster.html">get_elev_raster</a></span><span class="op">(</span>locations <span class="op">=</span> <span class="va">shp_ch</span>, </span>
<span>                                z <span class="op">=</span> <span class="fl">9</span>, clip <span class="op">=</span> <span class="st">"locations"</span><span class="op">)</span></span>
<span></span>
<span><span class="va">predictors</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span>elevation<span class="op">=</span> <span class="fu">terra</span><span class="fu">::</span><span class="fu"><a href="https://rspatial.github.io/terra/reference/extract.html">extract</a></span><span class="op">(</span><span class="va">an_elev</span>,</span>
<span>                                                   <span class="fu">st_coordinates</span><span class="op">(</span><span class="va">an_grid</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">pred_an_S</span> <span class="op">&lt;-</span> <span class="fu">pred_over_grid</span><span class="op">(</span><span class="va">an_fit</span>, grid <span class="op">=</span> <span class="va">an_grid</span>, </span>
<span>               predictors <span class="op">=</span> <span class="va">predictors</span>,</span>
<span>               type <span class="op">=</span> <span class="st">"joint"</span><span class="op">)</span></span>
<span></span>
<span><span class="va">pred_n_mosq_grid</span> <span class="op">&lt;-</span> </span>
<span><span class="fu">pred_target_grid</span><span class="op">(</span><span class="va">pred_an_S</span>, </span>
<span>                 f_target <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>n_mosq <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">lp</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">lp</span><span class="op">)</span><span class="op">)</span>,</span>
<span>                 pd_summary <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>mean <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">Tx</span><span class="op">)</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/summarize-generics.html">mean</a></span><span class="op">(</span><span class="va">Tx</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">an_weights</span> <span class="op">&lt;-</span> <span class="fl">1</span><span class="op">*</span><span class="op">(</span><span class="va">predictors</span><span class="op">$</span><span class="va">elevation</span> <span class="op">&gt;</span> <span class="fl">390</span> <span class="op">&amp;</span> <span class="va">predictors</span><span class="op">$</span><span class="va">elevation</span> <span class="op">&lt;</span> <span class="fl">837</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We now define our predictive target corresponding to the total number of mosquitoes within the study area <span class="math inline">\(A\)</span>, given by the convex hull of the observed locations, as <span id="eq-tot-mosq"><span class="math display">\[
T = \int_{A} w(x) T(x) \: dx
\tag{5.5}\]</span></span> The rationale is to estimate the total number of mosquitoes in the study area while restricting predictions to locations within the observed range of elevation. This approach helps avoid the risk of predicting in ecological areas that may not be suitable for mosquito presence. It is also important to note that in <a href="#eq-tot-mosq" class="quarto-xref">Equation&nbsp;<span>5.5</span></a>, we do not standardize the weights in this case.</p>
<div class="cell">
<div class="sourceCode" id="cb18" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html">par</a></span><span class="op">(</span>mfrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">2</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rspatial.github.io/terra/reference/plot.html">plot</a></span><span class="op">(</span><span class="va">pred_n_mosq_grid</span>, which_target <span class="op">=</span> <span class="st">"n_mosq"</span>, which_summary <span class="op">=</span> <span class="st">"mean"</span>,</span>
<span>     main <span class="op">=</span> <span class="st">"Number of mosquitoes"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rspatial.github.io/terra/reference/plot.html">plot</a></span><span class="op">(</span><span class="va">an_grid</span>, pch <span class="op">=</span> <span class="fl">20</span>, cex <span class="op">=</span> <span class="fl">1</span>, col <span class="op">=</span> <span class="va">an_weights</span><span class="op">+</span><span class="fl">1</span>, main <span class="op">=</span> <span class="st">"Weights"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html">par</a></span><span class="op">(</span>mfrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">1</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div id="fig-mosq-map" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-mosq-map-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="05_geostatistical-prediction_files/figure-html/fig-mosq-map-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-mosq-map-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5.5: Maps of the predicted averae number of mosqutoes (left panel). The right panel shows prediction locations in red if they have an elevation between 390 and 837 meters, or black otherwise.
</figcaption></figure>
</div>
</div>
</div>
<p><a href="#fig-mosq-map" class="quarto-xref">Figure&nbsp;<span>5.5</span></a> shows the prediction map for the number of mosquitoes at each prediction location, indicating a relatively high spatial heterogeneity as was also indicated by the low value for the estimate of the scale of the spatial correction (parameter <span class="math inline">\(\phi\)</span>). The right panel, we have an image of the weights <span class="math inline">\(w(x)\)</span>, with locations that will not contribute to the prediction of the total number of mosquitoes denoted in black.</p>
<div class="cell">
<div class="sourceCode" id="cb19" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">pred_n_mosq_shp</span> <span class="op">&lt;-</span> </span>
<span><span class="fu">pred_target_shp</span><span class="op">(</span><span class="va">pred_an_S</span>, shp <span class="op">=</span> <span class="va">shp_ch</span>, </span>
<span>                 weights <span class="op">=</span> <span class="va">an_weights</span>,</span>
<span>                 shp_target <span class="op">=</span> <span class="va">sum</span>,</span>
<span>                 f_target <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>n_mosq <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">lp</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">lp</span><span class="op">)</span><span class="op">)</span>,</span>
<span>                 pd_summary <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>mean <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">Tx</span><span class="op">)</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/summarize-generics.html">mean</a></span><span class="op">(</span><span class="va">Tx</span><span class="op">)</span>,</span>
<span>                                   q025 <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">Tx</span><span class="op">)</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/quantile.html">quantile</a></span><span class="op">(</span><span class="va">Tx</span>, <span class="fl">0.025</span><span class="op">)</span>,</span>
<span>                                   q075 <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">Tx</span><span class="op">)</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/quantile.html">quantile</a></span><span class="op">(</span><span class="va">Tx</span>, <span class="fl">0.975</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">pred_n_mosq_shp</span><span class="op">$</span><span class="va">target</span><span class="op">$</span><span class="va">reg1</span><span class="op">$</span><span class="va">n_mosq</span></span>
<span><span class="co">## $mean</span></span>
<span><span class="co">## [1] 17715.28</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $q025</span></span>
<span><span class="co">##     2.5% </span></span>
<span><span class="co">## 14917.66 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $q075</span></span>
<span><span class="co">##    97.5% </span></span>
<span><span class="co">## 20940.22</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Since we are not standardizing the weights, there is no need to specify <code>standardize_weights</code>, as it is set to <code>FALSE</code> by default. In the code above, we printed the mean of the predictive distribution of <span class="math inline">\(T\)</span> along with the 95% prediction interval. The point estimate of approximately 17,719 mosquitoes is likely an underestimate of the total number of Anopheles gambiae in the area, as the trap used to count the mosquitoes may not capture all of them, particularly those outside the immediate trapping zone or those active at different times.</p>
</section></section><section id="sec-compare-pp" class="level2" data-number="5.5"><h2 data-number="5.5" class="anchored" data-anchor-id="sec-compare-pp">
<span class="header-section-number">5.5</span> Assessing the predictive performance of geostatistical models with cross-validation</h2>
<p>In this section, we address the problem of identifying the geostatistical model that offers the best predictive performance among a set of candidates. However, we first need a clear definition of predictive performance which can be used to select suitable statistical tools that can be to used to evaluate it. Broadly speaking, predictive performance is defined by how well a model’s predictive distribution aligns with observed data. Evaluating predictive performance requires examining two key characteristics of the predictive distribution: <em>sharpness</em> and <em>calibration</em>.</p>
<section id="sec-split-data" class="level3" data-number="5.5.1"><h3 data-number="5.5.1" class="anchored" data-anchor-id="sec-split-data">
<span class="header-section-number">5.5.1</span> How to split geostatistical data for model performance comparisons</h3>
<p>To carry out the assessment and comparison of the predictive performance of geostatistical models using the methods illustrated in the following sections, the first crucial step to decide which approach to use to use split the data-set into a <em>training set</em> and <em>test set</em>. In the context of geostatistical analysis, the <em>training set</em> is the subset of the original data-set that is used to estimate the model parameters and then predict at the locations of the <em>test set</em>, which is used to assess how well the model can predict unseen data.</p>
<p>When splitting geostatistical data-sets for model performance evaluation, it is essential to consider the objective of the spatial prediction. Here, we consider two main prediction objectives: 1) predicting in areas disjoint from the study area where there are no data; 2) inferring the spatial surface of disease risk within a given study area. Let us give an example to better explain the difference between these two objectives. Under objective 1), if survey data exist for a specific country, say Kenya, but not for a neighboring country, say Somalia, a model trained on Kenyan data might then be used to predict disease prevalence in Somalia. In objective 2), instead, high-resolution risk maps of a health outcome might be required within a single country. The splitting of geostatistical data for predictive performance assessment should align with the intended application of the model and reflect whether the goal is to predict in entirely disjoint areas with no data (objective 1) ) or to infer the spatial surface of interest within the same study area (objective 2) ). Below, we elaborate on suitable methods for each of these two.</p>
<p>In the first scenario (objective 1) ), splitting the data using k-fold cross-validation with spatially coherent folds is more appropriate. These folds can be created using clustering methods such as k-means or hierarchical clustering (see <span class="citation" data-cites="yin2024">Yin et al. (<a href="references.html#ref-yin2024" role="doc-biblioref">2024</a>)</span> for review of the main clustering methods). These methods group spatial locations based on their coordinates or covariates, ensuring each fold represents a distinct spatial region. This approach mimics the challenge of predicting in disjoint areas by withholding entire spatial clusters from the training data. For instance, k-means minimizes within-cluster variance to produce compact, non-overlapping groups, while hierarchical clustering organizes data into nested clusters based on a linkage criterion like geographic distance. In the code below we show an example of the use of these methods for data splitting, using the <code>spatial_clusterin_cv</code> function from the <code>spatialsample</code> package <span class="citation" data-cites="mahoney2023">(<a href="references.html#ref-mahoney2023" role="doc-biblioref">Mahoney et al. 2023</a>)</span>.</p>
<div class="cell">
<div class="sourceCode" id="cb20" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/tidymodels/spatialsample">spatialsample</a></span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span>
<span><span class="va">liberia_sf</span> <span class="op">&lt;-</span> <span class="va">liberia</span> <span class="op">%&gt;%</span></span>
<span>              <span class="fu">st_as_sf</span><span class="op">(</span><span class="va">.</span>, coords <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"long"</span>, <span class="st">"lat"</span><span class="op">)</span>,</span>
<span>                       crs <span class="op">=</span> <span class="fl">4326</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>              <span class="fu">st_transform</span><span class="op">(</span><span class="va">.</span>,crs <span class="op">=</span> <span class="fl">32629</span><span class="op">)</span></span>
<span></span>
<span></span>
<span><span class="co"># K-means</span></span>
<span><span class="va">kmeans_liberia</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://spatialsample.tidymodels.org/reference/spatial_clustering_cv.html">spatial_clustering_cv</a></span><span class="op">(</span><span class="va">liberia_sf</span>,</span>
<span>                      v <span class="op">=</span> <span class="fl">10</span>, cluster_function <span class="op">=</span> <span class="st">"kmeans"</span><span class="op">)</span></span>
<span><span class="va">kmeans_plot</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/autoplot.html">autoplot</a></span><span class="op">(</span><span class="va">kmeans_liberia</span><span class="op">)</span> <span class="op">+</span> <span class="fu">ggtitle</span><span class="op">(</span><span class="st">"K-means"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Hierarchical clustering</span></span>
<span><span class="va">hclust_liberia</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://spatialsample.tidymodels.org/reference/spatial_clustering_cv.html">spatial_clustering_cv</a></span><span class="op">(</span><span class="va">liberia_sf</span>,</span>
<span>                      v <span class="op">=</span> <span class="fl">10</span>, cluster_function <span class="op">=</span> <span class="st">"hclust"</span><span class="op">)</span> </span>
<span>                   </span>
<span></span>
<span><span class="va">hclust_plot</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/autoplot.html">autoplot</a></span><span class="op">(</span><span class="va">hclust_liberia</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ggtitle</span><span class="op">(</span><span class="st">"Hierarchical clustering"</span><span class="op">)</span></span>
<span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va">gridExtra</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/gridExtra/man/arrangeGrob.html">grid.arrange</a></span><span class="op">(</span><span class="va">kmeans_plot</span>, <span class="va">hclust_plot</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div id="fig-clus-loc" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-clus-loc-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="05_geostatistical-prediction_files/figure-html/fig-clus-loc-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-clus-loc-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5.6: Examples un the use of spatial clustering methods for the splitting of the Liberia data on riverblindness.
</figcaption></figure>
</div>
</div>
</div>
<p>The results of the splitting are shown in <a href="#fig-clus-loc" class="quarto-xref">Figure&nbsp;<span>5.6</span></a>, where we have generated 10 folds using the k-means and hierarchical clustering methods with the default options. We can observe that the test sets are very similar, with fold 3 from the k-means and fold 7 from hierarchical clustering being identical. If using only the distance between locations to cluster the data into different folds, the choice of clustering method should have much impact on the model assessment as long as we repeat the split and assessment of the methods multiple times as we will show later in the next sections.</p>
<p>Before proceeding further, it is important to highlight that when the objective is predicting an outcome in entirely disjoint areas, the risks and limitations of this assessment should be carefully considered. In such cases, predictions are predominantly driven by covariates because the spatial Gaussian process <span class="math inline">\(S(x)\)</span> cannot extrapolate spatial patterns across regions with no connecting data. When the disjoint region requiring predictions is far from the sampled data, the Gaussian process contributes primarily to inflating prediction uncertainty and has no tangible impact on the point predictions, reflecting the lack of ground data in the area. Consequently, this validation approach primarily assesses the predictive power of the covariates rather than the geostatistical model as a whole. This limitation may lead to overestimating the model’s generalization capabilities, especially if the model is being used to predict areas that are far away from the study area. Hence, the results of this validation should be interpreted cautiously, emphasizing the critical role of covariates in driving predictions under such conditions.</p>
<p>We now consider the second prediction objective of inferring the spatial surface within the study area. In this case, a random sampling approach can be employed. However, to preserve a good spatial coverage of the study area, a minimum distance can be imposed between selected locations. For example, methods such as spatial thinning or stratified sampling can be adapted to enforce a minimum spatial separation. This can be done in R using the <code>subsample.distance</code> function from the <code>spatialEco</code> package <span class="citation" data-cites="evans2021">(<a href="references.html#ref-evans2021" role="doc-biblioref">Evans and Murphy 2021</a>)</span>.</p>
<div class="cell">
<div class="sourceCode" id="cb21" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/jeffreyevans/spatialEco">spatialEco</a></span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Regulirized spatial sampling: 30km</span></span>
<span><span class="va">dist30_liberia</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://jeffreyevans.github.io/spatialEco/reference/subsample.distance.html">subsample.distance</a></span><span class="op">(</span><span class="va">liberia_sf</span>,</span>
<span>                      size <span class="op">=</span> <span class="fl">20</span>, d <span class="op">=</span> <span class="fl">30000</span><span class="op">)</span></span>
<span><span class="va">dist30_plot</span> <span class="op">&lt;-</span> <span class="fu">ggplot</span><span class="op">(</span><span class="va">dist30_liberia</span><span class="op">)</span> <span class="op">+</span> <span class="fu">geom_sf</span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>               <span class="fu">theme_minimal</span><span class="op">(</span><span class="op">)</span> <span class="op">+</span> </span>
<span>               <span class="fu">ggtitle</span><span class="op">(</span><span class="st">"Minimum distance: 30km"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Regulirized spatial sampling: 40km</span></span>
<span><span class="va">dist40_liberia</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://jeffreyevans.github.io/spatialEco/reference/subsample.distance.html">subsample.distance</a></span><span class="op">(</span><span class="va">liberia_sf</span>,</span>
<span>                      size <span class="op">=</span> <span class="fl">20</span>, d <span class="op">=</span> <span class="fl">40000</span><span class="op">)</span></span>
<span><span class="va">dist40_plot</span> <span class="op">&lt;-</span> <span class="fu">ggplot</span><span class="op">(</span><span class="va">dist40_liberia</span><span class="op">)</span> <span class="op">+</span> <span class="fu">geom_sf</span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>               <span class="fu">theme_minimal</span><span class="op">(</span><span class="op">)</span> <span class="op">+</span> </span>
<span>               <span class="fu">ggtitle</span><span class="op">(</span><span class="st">"Minimum distance: 40km"</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/gridExtra/man/arrangeGrob.html">grid.arrange</a></span><span class="op">(</span><span class="va">dist30_plot</span>, <span class="va">dist40_plot</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div id="fig-reg-loc" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-reg-loc-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="05_geostatistical-prediction_files/figure-html/fig-reg-loc-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-reg-loc-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5.7: Examples un the use of spatialky regularized thinning for the splitting of the Liberia data on riverblindness into training and test set. The plots show the resulting test sets by randomly selecting 20 locations from the original data-set and imposing a minimum distance of 30km (left panel) and 40km (right panel).
</figcaption></figure>
</div>
</div>
</div>
<p>In the code above, we randomly selected 20 locations from the original data-set, enforcing minimum distances of 30 km and 40 km between points. The results are presented in <a href="#fig-reg-loc" class="quarto-xref">Figure&nbsp;<span>5.7</span></a>. The choice of the minimum distance for the test sample should ideally consider the spatial correlation scale (previously denoted by <span class="math inline">\(\phi\)</span>) of the spatial Gaussian process <span class="math inline">\(S(X)\)</span>. To minimize correlation within the test set, the minimum distance could be set to a value greater than <span class="math inline">\(\phi\)</span>. However, increasing the minimum distance makes it more challenging to obtain a test set of the desired sample size. Reducing correlation within the test set is important for ensuring that the assessment of predictive performance is as robust as possible.</p>
<p>A key challenge in both approaches is the potential lack of independence between the training and test data-sets due to spatial correlation. This can lead to an overly optimistic evaluation of model performance, as the training set may already contain information that is correlated with the test set. However, if we assume that all models benefit equally from this correlation during performance evaluation, the methods we illustrate next can still provide a reliable comparison of model performance in relative terms, even if the considered performance metrics may be somewhat biased.</p>
</section><section id="sec-anpit" class="level3" data-number="5.5.2"><h3 data-number="5.5.2" class="anchored" data-anchor-id="sec-anpit">
<span class="header-section-number">5.5.2</span> Assessing calibration using the nonrandomized probability integral transform</h3>
<p>A model is considered <em>well-calibrated</em> if its predictions adequately reflect the true uncertainty of the data. Assessment of a model’s calibration can be carried out in several ways. We can examine the agreement between the point predictions, say <span class="math inline">\(\hat{y}_i\)</span>, and the observed outcomes <span class="math inline">\(y_i\)</span>, commonly referred to as <em>accuracy</em>. The mean squared error (MSE), defined as <span class="math inline">\(\text{MSE} = \frac{1}{n} \sum_{i=1}^n (y_i - \hat{y}_i)^2\)</span>, is an example of a commonly used metric to evaluate the accuracy of a model. To characterize calibration more fully, it is also essential to quantify the spread of the predictive distributions, which also defines the <em>precision</em> of predictions. For example, prediction intervals generated from the predictive distribution for <span class="math inline">\(y_i\)</span> can help assess the precision of a geostatistical model. In summary, a well-calibrated model is both accurate and precise.</p>
<p>Assessment of the calibration of the model should precede the assessment of sharpness, since, as we shall see in the next section, this relies on the model being well-calibrated. The probability integral transform (PIT) was originally proposed by <span class="citation" data-cites="dawid1984">Dawid (<a href="references.html#ref-dawid1984" role="doc-biblioref">1984</a>)</span> as a way to assess the calibration of a model. The PIT is based on the simple observation that if we consider a variable <span class="math inline">\(Y\)</span> and apply the transformation <span class="math inline">\(Y^* = F_{Y}(Y)\)</span>, where <span class="math inline">\(F_{Y}(\cdot)\)</span> is the cumulative density function (or cumulative distribution if <span class="math inline">\(Y\)</span> is discrete) of <span class="math inline">\(Y\)</span>, it then follows that <span class="math inline">\(Y^*\)</span> follows a uniform distribution in the unit interval. The fundamental problem and the reason why statistical modelling exists is that we do not <span class="math inline">\(F_{Y}\)</span> but we would like to propose a model <span class="math inline">\(M\)</span> that we believe adequately approximates <span class="math inline">\(F_{Y}\)</span> with <span class="math inline">\(F_{M}\)</span>. The main advantage of using the PIT is that assessment of whether <span class="math inline">\(M\)</span> is well calibrated reduces to assessing whether the transform set of data <span class="math inline">\(F_{M}(y_1), \ldots, F_{M}(y_n)\)</span> follows a uniform distribution. To illustrate this, let us a consider a simple simulated example.</p>
<p>We first create a function that can compute the PIT.</p>
<div class="cell">
<div class="sourceCode" id="cb22" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Define a function for the PIT</span></span>
<span><span class="co"># F_M is the cumulative density function generated by the adopted model</span></span>
<span><span class="va">pit_transform</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">data</span>, <span class="va">F_M</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="co"># Apply the model CDF to the data</span></span>
<span>  <span class="va">pit_values</span> <span class="op">&lt;-</span> <span class="fu">F_M</span><span class="op">(</span><span class="va">data</span><span class="op">)</span></span>
<span>  <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="va">pit_values</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We then apply this function to show how the assessment of calibration through the PIT is carried out under two scenarios: 1) <span class="math inline">\(F_{Y}\)</span> is a Gamma distribution with shape 2 and scale parameter 1; 2) <span class="math inline">\(F_{Y}\)</span> is Student’s T distribution with 3 degrees of freedom. In each of the two scenarios, we show how the PIT behaves when our model coincides with the the true model (i.e.&nbsp;<span class="math inline">\(F_{M} = F_{Y}\)</span>) and when instead our model <span class="math inline">\(M\)</span> is a Gaussian distribution, with mean and variance estimated from the data.</p>
<div class="cell">
<div class="sourceCode" id="cb23" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Generate data from a skewed (gamma) distribution</span></span>
<span><span class="va">n</span> <span class="op">&lt;-</span> <span class="fl">1000</span></span>
<span><span class="va">shape</span> <span class="op">&lt;-</span> <span class="fl">2</span></span>
<span><span class="va">rate</span> <span class="op">&lt;-</span> <span class="fl">1</span></span>
<span><span class="va">data_gamma</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/GammaDist.html">rgamma</a></span><span class="op">(</span><span class="va">n</span>, shape <span class="op">=</span> <span class="va">shape</span>, rate <span class="op">=</span> <span class="va">rate</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Define correct and incorrect model CDFs for gamma data</span></span>
<span><span class="co"># Correct CDF</span></span>
<span><span class="va">model_cdf_correct_gamma</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/stats/GammaDist.html">pgamma</a></span><span class="op">(</span><span class="va">x</span>, shape <span class="op">=</span> <span class="va">shape</span>, rate <span class="op">=</span> <span class="va">rate</span><span class="op">)</span></span>
<span><span class="co"># Incorrect CDF: Assume data is normal (wrong model)</span></span>
<span><span class="va">model_cdf_incorrect_gamma</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">pnorm</a></span><span class="op">(</span><span class="va">x</span>, mean <span class="op">=</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/summarize-generics.html">mean</a></span><span class="op">(</span><span class="va">data_gamma</span><span class="op">)</span>, sd <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/sd.html">sd</a></span><span class="op">(</span><span class="va">data_gamma</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Compute PIT values for gamma data under both models</span></span>
<span><span class="va">pit_correct_gamma</span> <span class="op">&lt;-</span> <span class="fu">pit_transform</span><span class="op">(</span><span class="va">data_gamma</span>, <span class="va">model_cdf_correct_gamma</span><span class="op">)</span></span>
<span><span class="va">pit_incorrect_gamma</span> <span class="op">&lt;-</span> <span class="fu">pit_transform</span><span class="op">(</span><span class="va">data_gamma</span>, <span class="va">model_cdf_incorrect_gamma</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Generate data from a heavy-tailed (t) distribution</span></span>
<span><span class="va">df</span> <span class="op">&lt;-</span> <span class="fl">3</span></span>
<span><span class="va">data_t</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/TDist.html">rt</a></span><span class="op">(</span><span class="va">n</span>, df <span class="op">=</span> <span class="va">df</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Define correct and incorrect model CDFs for t data</span></span>
<span><span class="co"># Correct CDF</span></span>
<span><span class="va">model_cdf_correct_t</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/stats/TDist.html">pt</a></span><span class="op">(</span><span class="va">x</span>, df <span class="op">=</span> <span class="va">df</span><span class="op">)</span></span>
<span><span class="co"># Incorrect CDF: Assume data is normal (wrong model)</span></span>
<span><span class="va">model_cdf_incorrect_t</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">pnorm</a></span><span class="op">(</span><span class="va">x</span>, mean <span class="op">=</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/summarize-generics.html">mean</a></span><span class="op">(</span><span class="va">data_t</span><span class="op">)</span>, sd <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/sd.html">sd</a></span><span class="op">(</span><span class="va">data_t</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Compute PIT values for t data under both models</span></span>
<span><span class="va">pit_correct_t</span> <span class="op">&lt;-</span> <span class="fu">pit_transform</span><span class="op">(</span><span class="va">data_t</span>, <span class="va">model_cdf_correct_t</span><span class="op">)</span></span>
<span><span class="va">pit_incorrect_t</span> <span class="op">&lt;-</span> <span class="fu">pit_transform</span><span class="op">(</span><span class="va">data_t</span>, <span class="va">model_cdf_incorrect_t</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Combine results into a data frame for plotting</span></span>
<span><span class="va">df_plot</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span></span>
<span>  PIT <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">pit_correct_gamma</span>, <span class="va">pit_incorrect_gamma</span>, <span class="va">pit_correct_t</span>, <span class="va">pit_incorrect_t</span><span class="op">)</span>,</span>
<span>  Model <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Correct Gamma Model"</span>, <span class="st">"Incorrect Normal Model for Gamma"</span>, </span>
<span>                <span class="st">"Correct t Model"</span>, <span class="st">"Incorrect Normal Model for t"</span><span class="op">)</span>, each <span class="op">=</span> <span class="va">n</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Plot PIT distributions</span></span>
<span><span class="va">hist_plot</span> <span class="op">&lt;-</span> <span class="fu">ggplot</span><span class="op">(</span><span class="va">df_plot</span>, <span class="fu">aes</span><span class="op">(</span>x <span class="op">=</span> <span class="va">PIT</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">geom_histogram</span><span class="op">(</span><span class="fu">aes</span><span class="op">(</span>y <span class="op">=</span> <span class="va">..density..</span><span class="op">)</span>, bins <span class="op">=</span> <span class="fl">20</span>, fill <span class="op">=</span> <span class="st">"skyblue"</span>, color <span class="op">=</span> <span class="st">"black"</span>, alpha <span class="op">=</span> <span class="fl">0.7</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">geom_hline</span><span class="op">(</span>yintercept <span class="op">=</span> <span class="fl">1</span>, linetype <span class="op">=</span> <span class="st">"dashed"</span>, color <span class="op">=</span> <span class="st">"red"</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">facet_wrap</span><span class="op">(</span><span class="op">~</span> <span class="va">Model</span>, scales <span class="op">=</span> <span class="st">"free"</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">labs</span><span class="op">(</span>title <span class="op">=</span> <span class="st">"Probability Integral Transform (PIT) Distributions"</span>,</span>
<span>       x <span class="op">=</span> <span class="st">"PIT Values"</span>,</span>
<span>       y <span class="op">=</span> <span class="st">"Density"</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">theme_minimal</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Display the plot</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html">print</a></span><span class="op">(</span><span class="va">hist_plot</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div id="fig-hist-pit" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-hist-pit-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="05_geostatistical-prediction_files/figure-html/fig-hist-pit-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-hist-pit-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5.8: Histograms of the probability integral transform applied to simulated data. The top panels show the histograma of the PIT when the fitted model coincides with the true data generating model. The lower panels show how the PIT histrograms deviate from a uniform distribution. For more details, we refer to main text.
</figcaption></figure>
</div>
</div>
</div>
<p>In <a href="#fig-hist-pit" class="quarto-xref">Figure&nbsp;<span>5.8</span></a>, we assess whether the PIT transformed data follow a uniform distribution if the bars of the histogram are all approximately at the same height as indicated by the dashed line. Our preference to this diagnostic plot, is to use a qq-plot for a uniform distribution as shown below.</p>
<div class="cell">
<div class="sourceCode" id="cb24" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># QQ plot to check uniformity of PIT values</span></span>
<span><span class="va">qq_plot</span> <span class="op">&lt;-</span> <span class="fu">ggplot</span><span class="op">(</span><span class="va">df_plot</span>, <span class="fu">aes</span><span class="op">(</span>sample <span class="op">=</span> <span class="va">PIT</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">stat_qq</span><span class="op">(</span>distribution <span class="op">=</span> <span class="va">qunif</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">stat_qq_line</span><span class="op">(</span>distribution <span class="op">=</span> <span class="va">qunif</span>, color <span class="op">=</span> <span class="st">"red"</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">facet_wrap</span><span class="op">(</span><span class="op">~</span> <span class="va">Model</span>, scales <span class="op">=</span> <span class="st">"free"</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">labs</span><span class="op">(</span>title <span class="op">=</span> <span class="st">"QQ Plot of PIT Values against Uniform Distribution"</span>,</span>
<span>       x <span class="op">=</span> <span class="st">"Theoretical Quantiles (Uniform)"</span>,</span>
<span>       y <span class="op">=</span> <span class="st">"Sample Quantiles (PIT Values)"</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">theme_minimal</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Display both plot</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html">print</a></span><span class="op">(</span><span class="va">qq_plot</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div id="fig-qqplot-pit" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-qqplot-pit-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="05_geostatistical-prediction_files/figure-html/fig-qqplot-pit-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-qqplot-pit-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5.9: QQ-plots of the probability integral transform applied to simulated data. The top panels show the histograma of the PIT when the fitted model coincides with the true data generating model. The lower panels show how the PIT qq-plots deviate from a uniform distribution. The red line is the identity line For more details, we refer to main text.
</figcaption></figure>
</div>
</div>
</div>
<p>In the results of <a href="#fig-qqplot-pit" class="quarto-xref">Figure&nbsp;<span>5.9</span></a>, we consider a model well-calibrated if the qq-plot is as close as possible to the identity line. It is clear that in the first case the use of Gaussian distribution is violated by the skewness of the data generated from a Gamma distribution, and in the second scenario by the heavier tail of the Student’s T distribution.</p>
<p>In the simulated example, the PIT might seem unnecessary because we can directly assess if the data follow the assumed distribution (Gamma, Gaussian, or Student’s T) by comparing empirical and theoretical distributions. In these simple models, including linear Gaussian geostatistical models, the marginal distribution of the data is analytically available, so assessing goodness-of-fit is straightforward.</p>
<p>However, in the case of Binomial and Poisson geostatistical models, the marginal distribution of the data <span class="math inline">\(Y\)</span> – unconditioned on the spatial random effects <span class="math inline">\(S(x)\)</span> – cannot be obtained analytically. Specifically, geostatistical models for count data assume that <span class="math inline">\(Y\)</span>, conditioned on <span class="math inline">\(S(x)\)</span>, follows either a Binomial or Poisson distribution. But once we integrate out <span class="math inline">\(S(x)\)</span> to obtain the marginal (i.e., unconditioned) distribution of <span class="math inline">\(Y\)</span>, this distribution is no longer Poisson or Binomial. Instead, it becomes an overdispersed count distribution that lacks a closed-form expression.</p>
<p>In such cases, the PIT becomes valuable for evaluating model adequacy, as it allows for assessing the uniformity of PIT values against the assumed model distribution, even when the marginal distribution is intractable. However, direct application of the PIT raises the issue that the the transformation <span class="math inline">\(F_{Y}(Y)\)</span> does not follow a uniform distribution, because of the discrete nature of the random variable <span class="math inline">\(Y\)</span>. Hence, for a given discrete-outcome model <span class="math inline">\(M\)</span>, we use a modified version of the PIT, referred to as nonrandomized PIT (henceforth, nPIT), originally proposed by <span class="citation" data-cites="czado2009">Czado, Gneiting, and Held (<a href="references.html#ref-czado2009" role="doc-biblioref">2009</a>)</span>, taking the form <span class="math display">\[
\text{nPIT}(u,y) =
\begin{cases}
0, &amp; u \leq F_{M}(y-1) \\
\frac{u - F_{M}(y-1)}{P_x - F_{M}(y-1)}, &amp; F_{M}(y-1) \leq u \leq F_{M}(y) \\
1, &amp; u \geq F_{M}(y)
\end{cases}.
\]</span> We then take the average nPIT over the observed outcomes <span class="math inline">\(y_{1}, \ldots, y_{n}\)</span>, hence <span class="math display">\[
\text{AnPIT}(u) = \frac{1}{n} \sum_{i=1}^n \text{nPIT}(u, y_{i}).
\]</span> Assessment of calibration is then carried out by checking wether the AnPIT is as close as possible to the identity function, i.e.&nbsp;<span class="math inline">\(\text{AnPIT}(u) = u\)</span>. Hence, by plotting <span class="math inline">\(\text{AnPIT}(u)\)</span> against <span class="math inline">\(u\)</span>, we can consider any deviations from the identity line as evidence that the model is not well-calibrated.</p>
<p>We now illustrate the use of the AnPIT through a simulated example. We simulate data from a negative Binomial distribution, with mean <span class="math inline">\(\lambda = 5\)</span> and dispersion parameter <span class="math inline">\(\alpha = 1/2\)</span>, hence <span class="math inline">\(E[Y] = \lambda\)</span> and <span class="math inline">\(\text{Var}[Y] = \lambda \times (1 + \alpha \lambda)\)</span>.</p>
<div class="cell">
<div class="sourceCode" id="cb25" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Parameters for the Negative Binomial distribution</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span>
<span><span class="va">n</span> <span class="op">&lt;-</span> <span class="fl">200</span>                <span class="co"># number of simulations</span></span>
<span><span class="va">lambda</span> <span class="op">&lt;-</span> <span class="fl">5</span>             <span class="co"># mean</span></span>
<span><span class="va">dispersion</span> <span class="op">&lt;-</span> <span class="fl">0.5</span>       <span class="co"># dispersion parameter</span></span>
<span><span class="va">size</span> <span class="op">&lt;-</span> <span class="fl">1</span> <span class="op">/</span> <span class="va">dispersion</span>  <span class="co"># size parameter for negative binomial</span></span>
<span></span>
<span><span class="co"># Simulate data from the Negative Binomial distribution</span></span>
<span><span class="va">sim_data_nb</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/NegBinomial.html">rnbinom</a></span><span class="op">(</span><span class="va">n</span>, size <span class="op">=</span> <span class="va">size</span>, mu <span class="op">=</span> <span class="va">lambda</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Define the nonrandomized PIT function</span></span>
<span><span class="va">compute_npit</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">y</span>, <span class="va">u</span>, <span class="va">cdf_func</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="co"># Calculate cumulative probabilities F_M(y-1) and F_M(y) using the provided CDF function</span></span>
<span>  <span class="va">f_y_minus_1</span> <span class="op">&lt;-</span> <span class="fu">cdf_func</span><span class="op">(</span><span class="va">y</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span></span>
<span>  <span class="va">f_y</span> <span class="op">&lt;-</span> <span class="fu">cdf_func</span><span class="op">(</span><span class="va">y</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co"># Apply the piecewise formula for nPIT</span></span>
<span>  <span class="kw">if</span> <span class="op">(</span><span class="va">u</span> <span class="op">&lt;=</span> <span class="va">f_y_minus_1</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="fl">0</span><span class="op">)</span></span>
<span>  <span class="op">}</span> <span class="kw">else</span> <span class="kw">if</span> <span class="op">(</span><span class="va">u</span> <span class="op">&lt;=</span> <span class="va">f_y</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="op">(</span><span class="va">u</span> <span class="op">-</span> <span class="va">f_y_minus_1</span><span class="op">)</span> <span class="op">/</span> <span class="op">(</span><span class="va">f_y</span> <span class="op">-</span> <span class="va">f_y_minus_1</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span>    <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co"># Generate a sequence of u values from 0 to 1</span></span>
<span><span class="va">u_values</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">1</span>, length.out <span class="op">=</span> <span class="fl">100</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Calculate the average nPIT for each u value for both models</span></span>
<span><span class="va">AnPIT_nb</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/lapply.html">sapply</a></span><span class="op">(</span><span class="va">u_values</span>, <span class="kw">function</span><span class="op">(</span><span class="va">u</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rspatial.github.io/terra/reference/summarize-generics.html">mean</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/lapply.html">sapply</a></span><span class="op">(</span><span class="va">sim_data_nb</span>, <span class="va">compute_npit</span>, u <span class="op">=</span> <span class="va">u</span>, cdf_func <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">k</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/stats/NegBinomial.html">pnbinom</a></span><span class="op">(</span><span class="va">k</span>, size <span class="op">=</span> <span class="va">size</span>, mu <span class="op">=</span> <span class="va">lambda</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">}</span><span class="op">)</span></span>
<span></span>
<span><span class="va">AnPIT_poisson</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/lapply.html">sapply</a></span><span class="op">(</span><span class="va">u_values</span>, <span class="kw">function</span><span class="op">(</span><span class="va">u</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rspatial.github.io/terra/reference/summarize-generics.html">mean</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/lapply.html">sapply</a></span><span class="op">(</span><span class="va">sim_data_nb</span>, <span class="va">compute_npit</span>, u <span class="op">=</span> <span class="va">u</span>, cdf_func <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">k</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/stats/Poisson.html">ppois</a></span><span class="op">(</span><span class="va">k</span>, lambda <span class="op">=</span> <span class="va">lambda</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">}</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Combine the results into a data frame for plotting</span></span>
<span><span class="va">AnPIT_data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span></span>
<span>  u <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="va">u_values</span>, times <span class="op">=</span> <span class="fl">2</span><span class="op">)</span>,</span>
<span>  AnPIT <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">AnPIT_nb</span>, <span class="va">AnPIT_poisson</span><span class="op">)</span>,</span>
<span>  Model <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Negative Binomial (correct model)"</span>, <span class="st">"Poisson (wrong model)"</span><span class="op">)</span>, each <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="va">u_values</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Plotting the average nPIT as a function of u for both models</span></span>
<span><span class="fu">ggplot</span><span class="op">(</span><span class="va">AnPIT_data</span>, <span class="fu">aes</span><span class="op">(</span>x <span class="op">=</span> <span class="va">u</span>, y <span class="op">=</span> <span class="va">AnPIT</span>, color <span class="op">=</span> <span class="va">Model</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">geom_line</span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">geom_abline</span><span class="op">(</span>slope <span class="op">=</span> <span class="fl">1</span>, intercept <span class="op">=</span> <span class="fl">0</span>, linetype <span class="op">=</span> <span class="st">"dashed"</span>, color <span class="op">=</span> <span class="st">"black"</span><span class="op">)</span> <span class="op">+</span>  <span class="co"># Identity line</span></span>
<span>  <span class="fu">facet_wrap</span><span class="op">(</span><span class="op">~</span> <span class="va">Model</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">coord_cartesian</span><span class="op">(</span>xlim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">1</span><span class="op">)</span>, ylim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span>  </span>
<span>  <span class="fu">xlab</span><span class="op">(</span><span class="st">"u"</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ylab</span><span class="op">(</span><span class="st">"AnPIT"</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">theme_minimal</span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">theme</span><span class="op">(</span>legend.position <span class="op">=</span> <span class="st">"none"</span><span class="op">)</span>  </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div id="fig-anpit" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-anpit-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="05_geostatistical-prediction_files/figure-html/fig-anpit-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-anpit-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5.10: Average nonrandomized Probability Integral Transform (AnPIT) applied to simulated data from a Negative Binomial distribution. The left plot shows the AnPIT when the model is correctly specified. The right panel shows the AnPIT when a Poisson model is instead used. For more details we refer to the main text.
</figcaption></figure>
</div>
</div>
</div>
<p><a href="#fig-anpit" class="quarto-xref">Figure&nbsp;<span>5.10</span></a> shows clear evidence that the Poisson model is not adequately accounting for the overdispersion of the simulated data from the Negative Binomial distribution.</p>
<p>How can we adapt this approach to generalized linear geostatistical models (GLGMs)? The concept is straightforward, though the implementation is less so (but fortunately, we have already done this in <code>RiskMap</code>). Essentially, in all relevant equations above, we need to replace <span class="math inline">\(M\)</span> with the predictive distribution of the fitted geostatistical model.</p>
<p>To explain further, suppose we have fitted our model using data <span class="math inline">\(Y^{(1)} = \left( y^{(1)}_{1}, \ldots, y^{(1)}_{n} \right)\)</span> (the training data-set), and we want to use another set of data <span class="math inline">\(Y^{(2)} = \left( y^{(2)}_{1}, \ldots, y^{(2)}_{m} \right)\)</span> (the test data-set) to assess calibration; the selection of <span class="math inline">\(Y^{(1)}\)</span> and <span class="math inline">\(Y^{(2)}\)</span> can be done using the methods described in <a href="#sec-split-data" class="quarto-xref"><span>Section 5.5.1</span></a>. Our model <span class="math inline">\(M\)</span> in the equations above corresponds to the distribution of <span class="math inline">\(\left[ Y^{(2)} \mid Y^{(1)} \right]\)</span> – the distribution of <span class="math inline">\(Y^{(2)}\)</span> conditioned to <span class="math inline">\(Y^{(1)}\)</span> derived from our geostatistical model. Since its derivation cannot be done analytically, we use Monte Carlo methods to approximate <span class="math inline">\(\left[ Y^{(1)} \mid Y^{(2)} \right]\)</span>. We discuss this in more detail in <a href="#sec-theory-prediction" class="quarto-xref"><span>Section 5.7</span></a>. However, the key point here is to understand why we perform this assessment and how to interpret the results. We next show the application of the AnPIT diagnostic to the example on riverblindess mapping in Liberia.</p>
<section id="sec-liberia-anpit" class="level4" data-number="5.5.2.1"><h4 data-number="5.5.2.1" class="anchored" data-anchor-id="sec-liberia-anpit">
<span class="header-section-number">5.5.2.1</span> Example: assessing the calibration of two geostatistical models for riverblindness mapping</h4>
<p>In our example on riverblindness mapping, we now consider two models. A mode, which we call <span class="math inline">\(M_{0}\)</span>, which is an intercept only geostatistical model, with linear predictor <span class="math display">\[
M_{0} \: : \: \log\left\{\frac{p(x_i)}{1-p(x_i)}\right\} = \beta_0 + S(x_i) ,
\]</span> and a geostatistical model, which we denote as <span class="math inline">\(M_{1}\)</span>, which uses a linear spline with a not in 150 meters, and has linear predictor <span class="math display">\[
M_{1} \: : \: \log\left\{\frac{p(x_i)}{1-p(x_i)}\right\} = \beta_0 + \beta_{1}e(x_i) + \beta_{2}\max\{e(x_i) - 150, 0\} + S(x_i).
\]</span> The reason for using this type of linear spline in <span class="math inline">\(M_{1}\)</span> is explained in <a href="03_model-fitting.html#sec-expl-assoc" class="quarto-xref"><span>Section 3.1.1</span></a>.</p>
<p>Hence, we first fit the two models.</p>
<div class="cell">
<div class="sourceCode" id="cb26" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Fitting M0</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span>
<span><span class="va">M0_fit</span> <span class="op">&lt;-</span> </span>
<span><span class="fu">glgpm</span><span class="op">(</span><span class="va">npos</span> <span class="op">~</span>  <span class="fu">gp</span><span class="op">(</span><span class="va">long</span>, <span class="va">lat</span>, nugget <span class="op">=</span> <span class="cn">NULL</span><span class="op">)</span>,</span>
<span>      den <span class="op">=</span> <span class="va">ntest</span>, data <span class="op">=</span> <span class="va">liberia</span>,</span>
<span>      crs <span class="op">=</span> <span class="fl">4326</span>,</span>
<span>      convert_to_crs <span class="op">=</span> <span class="fl">32629</span>,</span>
<span>      family <span class="op">=</span> <span class="st">"binomial"</span>, messages <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Fitting M1</span></span>
<span><span class="va">M1_fit</span> <span class="op">&lt;-</span> </span>
<span><span class="fu">glgpm</span><span class="op">(</span><span class="va">npos</span> <span class="op">~</span>  <span class="va">elevation</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">pmax</a></span><span class="op">(</span><span class="va">elevation</span> <span class="op">-</span> <span class="fl">150</span>, <span class="fl">0</span><span class="op">)</span> <span class="op">+</span></span>
<span>      <span class="fu">gp</span><span class="op">(</span><span class="va">long</span>, <span class="va">lat</span>, nugget <span class="op">=</span> <span class="cn">NULL</span><span class="op">)</span>,</span>
<span>      den <span class="op">=</span> <span class="va">ntest</span>, data <span class="op">=</span> <span class="va">liberia</span>,</span>
<span>      crs <span class="op">=</span> <span class="fl">4326</span>,</span>
<span>      convert_to_crs <span class="op">=</span> <span class="fl">32629</span>,</span>
<span>      family <span class="op">=</span> <span class="st">"binomial"</span>, messages <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Since the main goal of this analysis is to draw predictive inference on riverblindness prevalence within Liberia, it would be more appropriate to use a regulirized subsampling scheme to split the data. To generate the AnPIT diagnostic plot in R, we can use the <code>assess_pp</code> function in <code>RiskMap</code></p>
<div class="cell">
<div class="sourceCode" id="cb27" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">regularized</span> <span class="op">&lt;-</span> </span>
<span><span class="fu">assess_pp</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>M0 <span class="op">=</span> <span class="va">M0_fit</span>, M1 <span class="op">=</span> <span class="va">M1_fit</span><span class="op">)</span>,</span>
<span>          which_metric <span class="op">=</span> <span class="st">"AnPIT"</span>, </span>
<span>          method <span class="op">=</span> <span class="st">"regularized"</span>, min_dist <span class="op">=</span> <span class="fl">20</span>,</span>
<span>          n_size <span class="op">=</span> <span class="fl">9</span>, iter <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode" id="cb28" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">p1</span> <span class="op">&lt;-</span> <span class="fu">plot_AnPIT</span><span class="op">(</span><span class="va">regularized</span>, combine_panels <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span> <span class="op">+</span></span>
<span>      <span class="fu">theme</span><span class="op">(</span>plot.margin <span class="op">=</span> <span class="fu">unit</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.5</span>, <span class="fl">0.5</span>, <span class="fl">0.5</span>, <span class="fl">0.5</span><span class="op">)</span>, <span class="st">"lines"</span><span class="op">)</span><span class="op">)</span> </span>
<span></span>
<span><span class="va">p2</span> <span class="op">&lt;-</span> <span class="fu">plot_AnPIT</span><span class="op">(</span><span class="va">regularized</span>, mode <span class="op">=</span> <span class="st">"all"</span><span class="op">)</span> <span class="op">+</span></span>
<span>      <span class="fu">theme</span><span class="op">(</span>plot.margin <span class="op">=</span> <span class="fu">unit</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.5</span>, <span class="fl">0.5</span>, <span class="fl">0.5</span>, <span class="fl">0.5</span><span class="op">)</span>, <span class="st">"lines"</span><span class="op">)</span><span class="op">)</span> </span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/gridExtra/man/arrangeGrob.html">grid.arrange</a></span><span class="op">(</span><span class="va">p1</span>, <span class="va">p2</span>, nrow <span class="op">=</span> <span class="fl">2</span>, heights <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div id="fig-anpit-reg" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-anpit-reg-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="05_geostatistical-prediction_files/figure-html/fig-anpit-reg-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-anpit-reg-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5.11: The average nonrandomized probability integral transform (AnPIT) averaged across 10 test sets of size 9 (upper panel) and for each of the 10 tests sets (lower panel). The test sets are generated using a spatially regularized sampling scheme.
</figcaption></figure>
</div>
</div>
</div>
<p>In the above function, we have used a spatially regularized sampling scheme (<code>method = "clusterized"</code>), where the locations are at least 20 kilometers (<code>min_dist = 20</code>) apart from each other to create 10 test sets (<code>iter = 10</code>) each of size 9 (<code>n_size = 9</code>) which corresponds to 10% of the original data-set. The results reported in <a href="#fig-anpit-reg" class="quarto-xref">Figure&nbsp;<span>5.11</span></a>, show both the AnPIT for each of the 10 test sets and the averaged AnPIT across the 10 test sets, for both <span class="math inline">\(M_0\)</span> and <span class="math inline">\(M_1\)</span>. The AnPIT plots show curves that are not too far from the identity line, which leads us to conclude that both <span class="math inline">\(M_0\)</span> and <span class="math inline">\(M_1\)</span> can be considered to be approximately well calibrated models.</p>
<p>Let us how if these results would change if we were to split the data using a clustering algorithm approach. We then use the <code>assess_pp</code>, to create 10 folds and set <code>method = "cluster"</code>.</p>
<div class="cell">
<div class="sourceCode" id="cb29" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">cluster</span> <span class="op">&lt;-</span> </span>
<span><span class="fu">assess_pp</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>M0 <span class="op">=</span> <span class="va">M0_fit</span>, M1 <span class="op">=</span> <span class="va">M1_fit</span><span class="op">)</span>,</span>
<span>          which_metric <span class="op">=</span> <span class="st">"AnPIT"</span>, </span>
<span>          method <span class="op">=</span> <span class="st">"cluster"</span>, fold <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode" id="cb30" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">p1</span> <span class="op">&lt;-</span> <span class="fu">plot_AnPIT</span><span class="op">(</span><span class="va">cluster</span>, combine_panels <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span> <span class="op">+</span></span>
<span>      <span class="fu">theme</span><span class="op">(</span>plot.margin <span class="op">=</span> <span class="fu">unit</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.5</span>, <span class="fl">0.5</span>, <span class="fl">0.5</span>, <span class="fl">0.5</span><span class="op">)</span>, <span class="st">"lines"</span><span class="op">)</span><span class="op">)</span> <span class="co"># Tighter margins</span></span>
<span></span>
<span><span class="va">p2</span> <span class="op">&lt;-</span> <span class="fu">plot_AnPIT</span><span class="op">(</span><span class="va">cluster</span>, mode <span class="op">=</span> <span class="st">"all"</span><span class="op">)</span> <span class="op">+</span></span>
<span>      <span class="fu">theme</span><span class="op">(</span>plot.margin <span class="op">=</span> <span class="fu">unit</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.5</span>, <span class="fl">0.5</span>, <span class="fl">0.5</span>, <span class="fl">0.5</span><span class="op">)</span>, <span class="st">"lines"</span><span class="op">)</span><span class="op">)</span> <span class="co"># Tighter margins</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/gridExtra/man/arrangeGrob.html">grid.arrange</a></span><span class="op">(</span><span class="va">p1</span>, <span class="va">p2</span>, nrow <span class="op">=</span> <span class="fl">2</span>, heights <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span> <span class="co"># Equal heights</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div id="fig-anpit-clus" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-anpit-clus-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="05_geostatistical-prediction_files/figure-html/fig-anpit-clus-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-anpit-clus-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5.12: The average nonrandomized probability integral transform (AnPIT) averaged across 10 test sets of size 9 (upper panel) and for each of the 10 test sets (lower panel). The test sets are generated using a clustering algorithm based on the locations of the data.
</figcaption></figure>
</div>
</div>
</div>
<p>The AnPIT from <a href="#fig-anpit-clus" class="quarto-xref">Figure&nbsp;<span>5.12</span></a> show very similar results to those of <a href="#fig-anpit-reg" class="quarto-xref">Figure&nbsp;<span>5.11</span></a>, hence similar conclusions are drawn.</p>
</section></section><section id="assessing-calibration-and-sharpness-using-continuous-ranked-probability-scores" class="level3" data-number="5.5.3"><h3 data-number="5.5.3" class="anchored" data-anchor-id="assessing-calibration-and-sharpness-using-continuous-ranked-probability-scores">
<span class="header-section-number">5.5.3</span> Assessing calibration and sharpness using continuous ranked probability scores</h3>
<p>We now consider another important aspect that helps to describe the predictive performance of a geostatistical model, namely sharpness. As the name suggests, sharpness refers to the spread of the predictive distribution. A sharp predictive distribution has a narrow spread, indicating that the model is highly confident in its predictions. Importantly, sharpness does not depend on how close predictions are to the true values (i.e., it is independent of accuracy). A model with high sharpness will produce predictions with low variance, but this sharpness is only meaningful if the model is well-calibrated, ensuring that the high confidence aligns with observed values. For example, a geostatistical model for disease prevalence mapping that predicts a very tight range of possible prevalence values for a location is producing sharp predictions. However, if the actual prevalence often falls outside this range, then the predictions may be sharp but poorly calibrated, thus limiting the value of quantifying sharpness alone.</p>
<p>To assess predictive performance while considering both sharpness and calibration, we introduce the <em>continuous ranked probability score (CRPS)</em> <span class="citation" data-cites="gneiting2007">(<a href="references.html#ref-gneiting2007" role="doc-biblioref">Gneiting, Balabdaoui, and Raftery 2007</a>)</span> and its scaled variant, the <em>scaled CRPS (SCRPS)</em> <span class="citation" data-cites="bolin2023">(<a href="references.html#ref-bolin2023" role="doc-biblioref">Bolin and Wallin 2023</a>)</span>. The CRPS evaluates the agreement between the predicted cumulative distribution function of the model <span class="math inline">\(M\)</span>, which we denote as in the previous section as <span class="math inline">\(F_M\)</span>, and the observed value <span class="math inline">\(y_i\)</span>. The CRPS is formally defined as <span class="math display">\[
\text{CRPS}(F_M, y_i) = \int_{-\infty}^\infty \left[ F_M(y) - \mathbf{1}(y \geq y_i) \right]^2 dy,
\]</span> The CRPS balances sharpness and calibration, penalizing deviations of the predictive distribution from the observation, with smaller CRPS value indicating better predictive performance.</p>
<p>The <em>scaled CRPS (SCRPS)</em>, proposed by <span class="citation" data-cites="bolin2023">Bolin and Wallin (<a href="references.html#ref-bolin2023" role="doc-biblioref">2023</a>)</span>, refines this further by addressing the issue of scale dependence, which in observations with varying uncertainty. This is formally defined as <span class="math display">\[
\text{SCRPS}(F, y_i) = -\frac{1}{2} \left[ 1 + \frac{\text{CRPS}(F_M, y_i)}{\text{CRPS}(F_M, F_M)} + \log\left\{2 \text{CRPS}(F_M, F_M)\right\} \right],
\]</span></p>
<p>where <span class="math inline">\(\text{CRPS}(F_M, F_M)\)</span> is the expectation of <span class="math inline">\(\text{CRPS}(F_M, Y)\)</span> when <span class="math inline">\(Y\)</span> follows the distribution <span class="math inline">\(F_M\)</span>.</p>
<p>The expressions for the CRPS and SCRPS may initially appear complex, but their appropriate application and interpretation lie in understanding their differences and the contexts in which each is more suitable. These differences become more intuitive when considering the more familiar concept of the standard error. The standard error of a predictive distribution represents its uncertainty, but it is not inherently standardized. In many cases, there exists a mean-variance relationship, where the variance increases with the mean. For instance, in Poisson-distributed data, higher mean values correspond to larger variances. This lack of standardization means that directly comparing predictive uncertainties across different scales can be misleading. Similarly, the CRPS is sensitive to the scale of the predictive distribution, as it penalizes errors in absolute terms, often giving disproportionate weight to observations with larger predictive uncertainty.</p>
<p>The SCRPS addresses this issue by standardizing predictive errors relative to the expected spread of the predictive distribution, ensuring <em>local scale invariance</em>. This means that the penalty for an incorrect prediction is adjusted proportionally to the scale of the predictive distribution. As a result, the SCRPS enables meaningful comparisons across observations with varying levels of uncertainty. To draw an analogy, the SCRPS standardizes the CRPS in much the same way that the coefficient of variation (CV) standardizes the standard error. By dividing the standard error by the mean of the predictive distribution, the CV expresses variability relative to the mean. This property is particularly valuable in geostatistical applications, where uncertainty often varies spatially due to factors such as non-stationarity of the predictive distribution or irregularly spaced observations.</p>
<p>However, while the SCRPS is more robust in settings where variability differs significantly across observations, there are contexts where the CRPS may be preferred. Specifically, in cases where greater emphasis should be placed on accurately predicting observations with larger uncertainty, the CRPS is more appropriate because it assigns greater weight to predictions with higher variance. For example, as highlighted in <span class="citation" data-cites="bolin2023">Bolin and Wallin (<a href="references.html#ref-bolin2023" role="doc-biblioref">2023</a>)</span>, when forecasting rare but impactful events (e.g., extreme weather conditions), the larger uncertainties associated with these events may naturally demand greater attention. In such scenarios, the CRPS’s sensitivity to scale can be an advantage, as it prioritizes minimizing errors for these high-variance predictions.</p>
<p>When evaluating the predictive performance of a model <span class="math inline">\(M\)</span>, we proceed as follows. Let <span class="math inline">\(\left(x_{1}^{(i)}, \ldots, x_{m_i}^{(i)}\right)\)</span> represent the set of locations in the <span class="math inline">\(i\)</span>-th test set, for <span class="math inline">\(i=1, \ldots, T\)</span>. For each location, we compute the score—either CRPS or SCRPS—and denote it as <span class="math inline">\(r_{M}\left(x_{j}^{(i)}\right)\)</span>.</p>
<p>To assess the overall performance of model <span class="math inline">\(M\)</span>, we calculate a weighted average of the scores across all test sets, where the weights are proportional to the sample size of each test set. The final score assigned to model <span class="math inline">\(M\)</span> is given by: <span id="eq-average-score"><span class="math display">\[
\frac{1}{\sum_{i=1}^T m_i} \sum_{i=1}^{T} \sum_{j=1}^{m_i} r_{M}\left(x_{j}^{(i)}\right).  \tag{5.6}\]</span></span></p>
<p>Models assumed to be well-calibrated and achieving a lower score based on the above expression are considered to provide sharper predictions and, consequently, better predictive performance.</p>
<section id="example-mapping-riverblindness-in-liberia-continuing-from-sec-liberia-anpit" class="level4" data-number="5.5.3.1"><h4 data-number="5.5.3.1" class="anchored" data-anchor-id="example-mapping-riverblindness-in-liberia-continuing-from-sec-liberia-anpit">
<span class="header-section-number">5.5.3.1</span> Example: mapping riverblindness in Liberia (continuing from <a href="#sec-liberia-anpit" class="quarto-xref"><span>Section 5.5.2.1</span></a>)</h4>
<p>In <a href="#sec-liberia-anpit" class="quarto-xref"><span>Section 5.5.2.1</span></a>, we have assessed the calibration of models <span class="math inline">\(M_0\)</span> and <span class="math inline">\(M_0\)</span> and found these to be reasonably well calibrated models. We now compare the predictive performance of the two, using both the CRPS and SCRPS metrics introduced previously.</p>
<p>The <code>assess_pp</code> function also allows the user to compute the CRPS and SCRPS through the argument <code>which_metric</code> as shown below.</p>
<div class="cell">
<div class="sourceCode" id="cb31" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">regularized_scores</span> <span class="op">&lt;-</span> </span>
<span><span class="fu">assess_pp</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>M0 <span class="op">=</span> <span class="va">M0_fit</span>, M1 <span class="op">=</span> <span class="va">M1_fit</span><span class="op">)</span>,</span>
<span>          which_metric <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"CRSP"</span>, <span class="st">"SCRPS"</span><span class="op">)</span>, </span>
<span>          method <span class="op">=</span> <span class="st">"regularized"</span>, min_dist <span class="op">=</span> <span class="fl">20</span>,</span>
<span>          n_size <span class="op">=</span> <span class="fl">9</span>, iter <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></span>
<span></span>
<span><span class="va">cluster_scores</span> <span class="op">&lt;-</span> </span>
<span><span class="fu">assess_pp</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>M0 <span class="op">=</span> <span class="va">M0_fit</span>, M1 <span class="op">=</span> <span class="va">M1_fit</span><span class="op">)</span>,</span>
<span>          which_metric <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"CRSP"</span>, <span class="st">"SCRPS"</span><span class="op">)</span>, </span>
<span>          method <span class="op">=</span> <span class="st">"cluster"</span>, fold <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Note that that <code>assess_pp</code> can be run once in order to obtain both the AnPIT diagnostic, introduced in <a href="#sec-anpit" class="quarto-xref"><span>Section 5.5.2</span></a>; by default <code>which_metric = c("AnPIT", "CRSP", "SCRPS")</code> which computes all three diagnostic using the same test sets. The reason we have separated the AnPIT and the scores computations is only for pedagogical purposes.</p>
<p>By doing a <code>summary</code> of the output in <code>regularized_scores</code> and <code>cluster_scores</code>, we obtain the average score across all test sets as defined in <a href="#eq-average-score" class="quarto-xref">Equation&nbsp;<span>5.6</span></a>.</p>
<div class="cell">
<div class="sourceCode" id="cb32" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rspatial.github.io/terra/reference/summary.html">summary</a></span><span class="op">(</span><span class="va">regularized_scores</span>, view_all <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="co">## Summary of Cross-Validation Scores</span></span>
<span><span class="co">## ----------------------------------</span></span>
<span><span class="co">## Model: M0</span></span>
<span><span class="co">##   Overall average across test sets:</span></span>
<span><span class="co">##     CRPS: -0.0384</span></span>
<span><span class="co">##     SCRPS: 0.2488</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Model: M1</span></span>
<span><span class="co">##   Overall average across test sets:</span></span>
<span><span class="co">##     CRPS: -0.0415</span></span>
<span><span class="co">##     SCRPS: 0.2091</span></span>
<span></span>
<span><span class="fu"><a href="https://rspatial.github.io/terra/reference/summary.html">summary</a></span><span class="op">(</span><span class="va">cluster_scores</span>, view_all <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="co">## Summary of Cross-Validation Scores</span></span>
<span><span class="co">## ----------------------------------</span></span>
<span><span class="co">## Model: M0</span></span>
<span><span class="co">##   Overall average across test sets:</span></span>
<span><span class="co">##     CRPS: -0.0464</span></span>
<span><span class="co">##     SCRPS: 0.1635</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Model: M1</span></span>
<span><span class="co">##   Overall average across test sets:</span></span>
<span><span class="co">##     CRPS: -0.0446</span></span>
<span><span class="co">##     SCRPS: 0.1683</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In the code above, we have set <code>view_all = FALSE</code> to display only the overall average. If <code>view_all = TRUE</code>, the scores are instead reported for each test set, in addition to the overall average. The results from the <code>summary</code> suggest that the two models have a similar predictive performance in terms of both CRPS and SCRPS, regardless of the sampling scheme used to create the test sets. To examine this further we can plot a point map of the CRPS and SCRPS using the locations of the test sets.</p>
<div class="cell">
<div class="sourceCode" id="cb33" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Define ranges for the color scales</span></span>
<span></span>
<span><span class="va">crps_range</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/range.html">range</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/unlist.html">unlist</a></span><span class="op">(</span><span class="va">cluster_scores</span><span class="op">$</span><span class="va">model</span><span class="op">$</span><span class="va">M0</span><span class="op">$</span><span class="va">score</span><span class="op">$</span><span class="va">CRPS</span><span class="op">)</span>,</span>
<span>                      <span class="fu"><a href="https://rdrr.io/r/base/unlist.html">unlist</a></span><span class="op">(</span><span class="va">cluster_scores</span><span class="op">$</span><span class="va">model</span><span class="op">$</span><span class="va">M1</span><span class="op">$</span><span class="va">score</span><span class="op">$</span><span class="va">CRPS</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="va">scrps_range</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/range.html">range</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/unlist.html">unlist</a></span><span class="op">(</span><span class="va">cluster_scores</span><span class="op">$</span><span class="va">model</span><span class="op">$</span><span class="va">M0</span><span class="op">$</span><span class="va">score</span><span class="op">$</span><span class="va">SCRPS</span><span class="op">)</span>,</span>
<span>                      <span class="fu"><a href="https://rdrr.io/r/base/unlist.html">unlist</a></span><span class="op">(</span><span class="va">cluster_scores</span><span class="op">$</span><span class="va">model</span><span class="op">$</span><span class="va">M1</span><span class="op">$</span><span class="va">score</span><span class="op">$</span><span class="va">SCRPS</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> </span>
<span></span>
<span><span class="co"># Generate the plots with consistent color scales</span></span>
<span><span class="va">p1</span> <span class="op">&lt;-</span> <span class="fu">plot_score</span><span class="op">(</span><span class="va">cluster_scores</span>, </span>
<span>                 which_score <span class="op">=</span> <span class="st">"CRPS"</span>, which_model <span class="op">=</span> <span class="st">"M0"</span><span class="op">)</span> <span class="op">+</span>  </span>
<span>      <span class="fu">scale_color_viridis_c</span><span class="op">(</span>option <span class="op">=</span> <span class="st">"C"</span>, </span>
<span>      limits <span class="op">=</span> <span class="va">crps_range</span>, direction <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> </span>
<span><span class="va">p2</span> <span class="op">&lt;-</span> <span class="fu">plot_score</span><span class="op">(</span><span class="va">cluster_scores</span>, </span>
<span>                 which_score <span class="op">=</span> <span class="st">"CRPS"</span>, which_model <span class="op">=</span> <span class="st">"M1"</span><span class="op">)</span> <span class="op">+</span>       </span>
<span>      <span class="fu">scale_color_viridis_c</span><span class="op">(</span>option <span class="op">=</span> <span class="st">"C"</span>, </span>
<span>      limits <span class="op">=</span> <span class="va">crps_range</span>, direction <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> </span>
<span><span class="va">p3</span> <span class="op">&lt;-</span> <span class="fu">plot_score</span><span class="op">(</span><span class="va">cluster_scores</span>, </span>
<span>                 which_score <span class="op">=</span> <span class="st">"SCRPS"</span>, which_model <span class="op">=</span> <span class="st">"M0"</span><span class="op">)</span> <span class="op">+</span>  </span>
<span>      <span class="fu">scale_color_viridis_c</span><span class="op">(</span>option <span class="op">=</span> <span class="st">"C"</span>, </span>
<span>      limits <span class="op">=</span> <span class="va">scrps_range</span>, direction <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> </span>
<span><span class="va">p4</span> <span class="op">&lt;-</span> <span class="fu">plot_score</span><span class="op">(</span><span class="va">cluster_scores</span>, </span>
<span>                 which_score <span class="op">=</span> <span class="st">"SCRPS"</span>, which_model <span class="op">=</span> <span class="st">"M1"</span><span class="op">)</span> <span class="op">+</span></span>
<span>      <span class="fu">scale_color_viridis_c</span><span class="op">(</span>option <span class="op">=</span> <span class="st">"C"</span>, </span>
<span>      limits <span class="op">=</span> <span class="va">scrps_range</span>, direction <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> </span>
<span><span class="fu"><a href="https://rdrr.io/pkg/gridExtra/man/arrangeGrob.html">grid.arrange</a></span><span class="op">(</span><span class="va">p1</span>, <span class="va">p2</span>, <span class="va">p3</span>, <span class="va">p4</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div id="fig-scores-map" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-scores-map-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="05_geostatistical-prediction_files/figure-html/fig-scores-map-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-scores-map-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5.13: Point maps of the scores for model <span class="math inline">\(M_{0}\)</span> and <span class="math inline">\(M_{1}\)</span> across the test sets generated using a clusering approach for splitting the data. The upper panels are the map for the continuous ranked probability score (CRPS) and the lower panels for the scale CRPS (SCRPS).
</figcaption></figure>
</div>
</div>
</div>
<p>In the code above, we evaluated the cross-validation results generated using a clustering algorithm to split the original data-set. The map reveals that the scores across most locations are generally similar, with only three locations near the coast of Liberia showing slightly lower CRPS and SCRPS values for <span class="math inline">\(M_1\)</span>. This suggests a consistent predictive performance across the dataset, with some localized variations.</p>
</section></section></section><section id="simulation-based-assessment-of-predictive-performance" class="level2" data-number="5.6"><h2 data-number="5.6" class="anchored" data-anchor-id="simulation-based-assessment-of-predictive-performance">
<span class="header-section-number">5.6</span> Simulation-based assessment of predictive performance</h2>
<p>In <a href="#sec-compare-pp" class="quarto-xref"><span>Section 5.5</span></a>, we illustrated how to evaluate predictive performance in relative terms, specifically by comparing candidate models under consideration. In this section, we demonstrate how simulation studies can be used to assess the predictive performance of a geostatistical model in predicting a spatially continuous target within a region of interest. Since a spatially continuous target cannot be directly observed, simulations provide a way to generate such targets under specified assumptions. This approach allows us to evaluate how effectively the model can recover the underlying spatial surface using suitable predictive performance metrics.</p>
<section id="sec-sim-step1" class="level3" data-number="5.6.1"><h3 data-number="5.6.1" class="anchored" data-anchor-id="sec-sim-step1">
<span class="header-section-number">5.6.1</span> Step 1: Define the aim of the simulation study</h3>
<p>As previously stated, one of the main reasons for carrying out a simulation study is the ability to generate spatial surfaces, which are typically unobservable in the real world. The purpose of the simulation is generally to evaluate how well a given geostatistical model can recover that surface and/or draw inferences on some of its properties.</p>
<p>To fully understand the how to carry out a simulation study, it is essential to define its two main components: the <em>true model</em> and the <em>candidate models</em> (which can indeed include multiple options).</p>
<p>The <strong>true model</strong> represents the underlying stochastic process that generates the data. In a simulation study, the true model is assumed to be known because it is explicitly specified by us. It serves as the benchmark against which other models are assessed.</p>
<p>The <strong>candidate models</strong> are the geostatistical models that are tested or evaluated during the simulation study. These models are proposed alternatives to approximate or recover the true spatial surface or its properties. Candidate models may differ in terms of their assumptions and model complexity.</p>
<p>It is important to highlight that the true model not only serves as a benchmark but can also be included among the candidate models. However, the true model does not always necessarily outperform other candidate models. In some cases, certain candidate models may provide better approximations of the spatial surface or its properties, particularly when the true model’s complexity is too high relative to the available sample size. Here, <em>model complexity</em> refers to the number of parameters in a model. For instance, a true geostatistical model with high complexity may include numerous covariates or a highly parameterised covariance function. When the sample size is insufficient to reliably estimate these parameters, simpler candidate models can sometimes yield better performances.</p>
<p>Consider an extreme example where the true model is a spatial Gaussian process <span class="math inline">\(S(x)\)</span> with a scale parameter of <span class="math inline">\(\phi = 1\)</span>. If only a very small fraction of sampled locations are at distances below 1, estimating <span class="math inline">\(\phi\)</span> accurately becomes highly challenging, especially with a small sample size. In particular the sparsity of close pairs reduces the information available to estimate the spatial dependence structure, making the estimation of <span class="math inline">\(\phi\)</span> imprecise or even unreliable. In this case, a candidate model that does not attempt to explicitly estimate the spatial dependence (e.g., a model that relies solely on spatial covariates to interpolate the surface) might perform better in recovering the spatial structure. This example suggests that a simpler or alternative model can sometimes outperform the true model under specific sampling and data constraints.</p>
<p>At this point, a natural question arises: how should we choose the true model for a simulation study? The answer depends on the specific objectives of the study and what we aim to demonstrate. We now provide an example to demonstrate this point.</p>
<section id="example" class="level4" data-number="5.6.1.1"><h4 data-number="5.6.1.1" class="anchored" data-anchor-id="example">
<span class="header-section-number">5.6.1.1</span> Example</h4>
<p>In our analysis of the river blindness dataset, we now aim to evaluate the effectiveness of using elevation as a spatial predictor. To achieve this, we conduct a simulation study to compare the performance of two geostatistical models: one that incorporates elevation as a predictor and another that excludes it. This example will be revisited throughout the steps outlined in this section on simulation. We can chose the following true model (henceforth <span class="math inline">\(M_T\)</span>) for the simulation <span id="eq-true-model-lib"><span class="math display">\[M_{T}: \:
\log\left\{\frac{p(x_i)}{1-p(x_i)}\right\} = \beta_{0} + \beta_{1}e(x_i) + \beta_{2}\max\{e(x_i)-150, 0\} + S(x_i).
\tag{5.7}\]</span></span> The true model, described by the equation above, assumes a nonlinear relationship with elevation based on a linear spline with a single knot at 150 meters. To simulate data from the true model, which constitutes the next step in our simulation study, we must first define the model parameter values. A reasonable approach is to use the maximum likelihood estimates obtained by fitting the binomial geostatistical model specified in <a href="#eq-true-model-lib" class="quarto-xref">Equation&nbsp;<span>5.7</span></a>. These estimates can be derived as shown below.</p>
<div class="cell">
<div class="sourceCode" id="cb34" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span>
<span><span class="va">true_model</span> <span class="op">&lt;-</span> <span class="fu">glgpm</span><span class="op">(</span><span class="va">npos</span> <span class="op">~</span> <span class="va">elevation</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">pmax</a></span><span class="op">(</span><span class="va">elevation</span> <span class="op">-</span> <span class="fl">150</span>, <span class="fl">0</span><span class="op">)</span> <span class="op">+</span> </span>
<span>                           <span class="fu">gp</span><span class="op">(</span><span class="va">long</span>, <span class="va">lat</span><span class="op">)</span>,</span>
<span>                    den <span class="op">=</span> <span class="va">ntest</span>,</span>
<span>                    crs <span class="op">=</span> <span class="fl">4326</span>, </span>
<span>                    convert_to_crs <span class="op">=</span> <span class="fl">32629</span>,</span>
<span>                    family <span class="op">=</span> <span class="st">"binomial"</span>,</span>
<span>                    data <span class="op">=</span> <span class="va">liberia</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode" id="cb35" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># The parameters of the true model</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/stats/coef.html">coef</a></span><span class="op">(</span><span class="va">true_model</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre data-code-line-numbers=""><code>$beta
             (Intercept)                elevation pmax(elevation - 150, 0) 
            -2.002985655              0.003160402             -0.001706721 

$sigma2
[1] 0.3181267

$phi
[1] 41.02334</code></pre>
</div>
</div>
<p>A natural candidate model to evaluate the usefulness of elevation as a covariate is an intercept-only model (referred to here as <span class="math inline">\(M_C\)</span>). This model is defined as: <span class="math display">\[M_{C}: \:
\log\left\{\frac{p(x_i)}{1-p(x_i)}\right\} = \beta_{0} + S(x_i).
\]</span> where no covariates are included. This approach makes <span class="math inline">\(M_C\)</span> a suitable baseline model, commonly selected when the objective is to assess the contribution of covariates to spatial prediction.</p>
</section></section><section id="step-2-simulate-the-spatial-surface-and-the-data-from-the-true-model" class="level3" data-number="5.6.2"><h3 data-number="5.6.2" class="anchored" data-anchor-id="step-2-simulate-the-spatial-surface-and-the-data-from-the-true-model">
<span class="header-section-number">5.6.2</span> Step 2: Simulate the spatial surface and the data from the true model</h3>
<p>In <a href="03_model-fitting.html#sec-bootstrap" class="quarto-xref"><span>Section 3.3.3</span></a>, we have shown how to simulate from a geostatistical model, when the goal is simulate data at the observed locations. When we want to simulate a spatial surface, a similar approach can be used. First of all, we need to generate a regular grid, say <span class="math inline">\(\tilde{X}\)</span>, covering the study region of interest, say <span class="math inline">\(A\)</span>. Based on the notation used so far, we use <span class="math inline">\(X\)</span> to denote the set of observed locations which are used to simulate the outcome data <span class="math inline">\(Y\)</span>. Finally, we use <span class="math inline">\(X_{+} = (X, \tilde{X})\)</span> to denote the full set of locations both on the grid and at the data points. We can then proceed through the following steps to simultaneously simulate values of the surface of interest over <span class="math inline">\(\tilde{X}\)</span> and <span class="math inline">\(X\)</span>.</p>
<ol type="1">
<li><p>Compute the covariance matrix <span class="math inline">\(\Sigma_{+}\)</span> using the combined set of locations <span class="math inline">\(X_{+}\)</span>.</p></li>
<li><p>If covariates are used, compute the covariates effects <span class="math inline">\(d(x)^\top \beta\)</span> for all the locations in <span class="math inline">\(X_{+}\)</span>.</p></li>
<li><p>Simulate <span class="math inline">\(B\)</span>-times from a multivariate Gaussian distribution with mean vector 0 and covariance <span class="math inline">\(\Sigma_{+}\)</span> as previously defined. We denote the output form this step as <span class="math inline">\(S_{(j)}(\tilde{x})\)</span>, for simulations generate on <span class="math inline">\(\tilde{X}\)</span>, and with <span class="math inline">\(S_{(j)}(x)\)</span> for simulations on <span class="math inline">\(X\)</span>, respectively, for <span class="math inline">\(j=1,\ldots,B\)</span>.</p></li>
<li><p>Compute the linear predictor at each locations of <span class="math inline">\(X_{+}\)</span>, by adding the covariates effects in 3 to the simulated random effects in 4, hence <span class="math inline">\(g\{\mu_{(j)}(\tilde{x})\} = d(\tilde{x})^\top + S_{(j)}(\tilde{x})\)</span> for <span class="math inline">\(\tilde{X}\)</span>, and <span class="math inline">\(g\{\mu_{(j)}(x)\} = d(x)^\top + S_{(j)}(x)\)</span> for <span class="math inline">\(X\)</span>.</p></li>
<li><p>Only for locations of the data <span class="math inline">\(X\)</span>, perform the steps 5A to 7A as explained in <a href="03_model-fitting.html#sec-bootstrap" class="quarto-xref"><span>Section 3.3.3</span></a>, to simulate the data <span class="math inline">\(Y\)</span>.</p></li>
</ol>
<p>The function <code>surf_sim</code> in <code>RiskMap</code> can be used to carry out all these steps automatically as shown next.</p>
<section id="example-1" class="level4" data-number="5.6.2.1"><h4 data-number="5.6.2.1" class="anchored" data-anchor-id="example-1">
<span class="header-section-number">5.6.2.1</span> Example</h4>
<p>Following the steps previously outlined, we first create a grid within the boundaries of Liberia and extract the values of elevation on the grid from a raster.</p>
<div class="cell">
<div class="sourceCode" id="cb37" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/wmgeolab/rgeoboundaries">rgeoboundaries</a></span><span class="op">)</span></span>
<span><span class="va">shp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/rgeoboundaries/man/geoboundaries.html">geoboundaries</a></span><span class="op">(</span>country <span class="op">=</span> <span class="st">"liberia"</span>, adm_lvl <span class="op">=</span> <span class="st">"adm0"</span><span class="op">)</span></span>
<span><span class="va">shp</span> <span class="op">&lt;-</span> <span class="fu">st_transform</span><span class="op">(</span><span class="va">shp</span>, crs<span class="op">=</span> <span class="fl">32629</span><span class="op">)</span></span>
<span></span>
<span><span class="va">pred_grid</span> <span class="op">&lt;-</span> <span class="fu">create_grid</span><span class="op">(</span><span class="va">shp</span>, spat_res <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span>
<span><span class="va">pred_grid</span> <span class="op">&lt;-</span> <span class="fu">st_as_sf</span><span class="op">(</span><span class="va">pred_grid</span><span class="op">)</span></span>
<span><span class="va">liberia_elev</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/elevatr/man/get_elev_raster.html">get_elev_raster</a></span><span class="op">(</span>locations <span class="op">=</span> <span class="va">shp</span>,</span>
<span>                                z <span class="op">=</span> <span class="fl">5</span>, clip <span class="op">=</span> <span class="st">"locations"</span><span class="op">)</span></span>
<span></span>
<span><span class="va">pred_grid</span><span class="op">$</span><span class="va">elevation</span> <span class="op">&lt;-</span> <span class="fu">terra</span><span class="fu">::</span><span class="fu"><a href="https://rspatial.github.io/terra/reference/extract.html">extract</a></span><span class="op">(</span><span class="va">liberia_elev</span>, <span class="fu">st_coordinates</span><span class="op">(</span><span class="va">pred_grid</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The function <code>surf_sim</code> also requires a sampling functions that generates the locations <span class="math inline">\(X\)</span> from which data <span class="math inline">\(Y\)</span> are simulated. In this example, we shall consider a sampling function that simply returns the locations of the original data.</p>
<div class="cell">
<div class="sourceCode" id="cb38" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">sampling_f_lib</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">coords_sf</span> <span class="op">&lt;-</span> <span class="fu">st_as_sf</span><span class="op">(</span><span class="va">liberia</span><span class="op">[</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"ntest"</span>, <span class="st">"long"</span>, <span class="st">"lat"</span><span class="op">)</span><span class="op">]</span>,</span>
<span>                        coords <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"long"</span>, <span class="st">"lat"</span><span class="op">)</span>, crs <span class="op">=</span> <span class="fl">4326</span><span class="op">)</span></span>
<span>  <span class="va">coords_sf</span> <span class="op">&lt;-</span> <span class="fu">st_transform</span><span class="op">(</span><span class="va">coords_sf</span>, <span class="fl">32629</span><span class="op">)</span></span>
<span>  <span class="va">coords_sf</span><span class="op">$</span><span class="va">units_m</span> <span class="op">&lt;-</span> <span class="va">coords_sf</span><span class="op">$</span><span class="va">ntest</span></span>
<span>  <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="va">coords_sf</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The output of the sampling function must be an <code>sf</code> object that must contain the number of tested people and its corresponding column must be named <code>units_m</code>. Also, the returned <code>sf</code> object must have a projection that correspond to the one used when fitting the model.</p>
<p>We are now ready to run the <code>surf_sim</code> function.</p>
<div class="cell">
<div class="sourceCode" id="cb39" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">lib_surf_sim</span> <span class="op">&lt;-</span> <span class="fu">surf_sim</span><span class="op">(</span>n_sim <span class="op">=</span> <span class="fl">200</span>,</span>
<span>                         pred_grid <span class="op">=</span> <span class="va">pred_grid</span>,</span>
<span>                         formula <span class="op">=</span> <span class="op">~</span> <span class="va">elevation</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">pmax</a></span><span class="op">(</span><span class="va">elevation</span> <span class="op">-</span> <span class="fl">150</span>,<span class="fl">0</span><span class="op">)</span> <span class="op">+</span></span>
<span>                                     <span class="fu">gp</span><span class="op">(</span>kappa<span class="op">=</span><span class="fl">0.5</span><span class="op">)</span>,</span>
<span>                         sampling_f <span class="op">=</span> <span class="va">sampling_f_lib</span>,</span>
<span>                         family <span class="op">=</span> <span class="st">"binomial"</span>,</span>
<span>                         par0 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/coef.html">coef</a></span><span class="op">(</span><span class="va">true_model</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In the above function, we have simulated <span class="math inline">\(B = 200\)</span> simulations from the true model as specified in <code>formula</code>. The argument <code>par0</code> is used to pass the values of the parameters of the true model.</p>
<p>We can now inspect the individual simulated surfaces using the <code>plot_sim_surf</code> function, as demonstrated below, which produces <a href="#fig-surf-sim" class="quarto-xref">Figure&nbsp;<span>5.14</span></a>. This step is useful verifying that the simulations are consistent with expectations and free from any warning signs or anomalies.</p>
<div class="cell">
<div class="sourceCode" id="cb40" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">plot_sim_surf</span><span class="op">(</span><span class="va">lib_surf_sim</span>, sim <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fig-surf-sim" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-surf-sim-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./figures/sim_surf1.jpeg" class="img-fluid quarto-figure quarto-figure-center figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-surf-sim-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5.14: Simulated surface for the linear predictor, with locations of the simulated data noted by solid black points.
</figcaption></figure>
</div>
</section></section><section id="sec-sim-step3" class="level3" data-number="5.6.3"><h3 data-number="5.6.3" class="anchored" data-anchor-id="sec-sim-step3">
<span class="header-section-number">5.6.3</span> Step 3: Fit the candidate models to the simulated data and predict the target</h3>
<p>To summarize, the results obtained from Step 1 and Step 2 are as follows:</p>
<ol type="1">
<li>Simulated values for the linear predictor of the true model (<span class="math inline">\(M_T\)</span>) over a grid covering the study area.</li>
<li>Simulated values for the linear predictor of <span class="math inline">\(M_T\)</span> at the data locations.</li>
<li>Simulated realizations of the data at the data locations.</li>
</ol>
<p>Next, we use the third output listed above to fit the candidate models (<span class="math inline">\(M_C\)</span>) and make predictions over the grid. Note that each of the outputs above has been generated <span class="math inline">\(B\)</span> times, which denotes the number of simulations.</p>
<p>Using the notation introduced in <a href="#sec-spat-cont-target" class="quarto-xref"><span>Section 5.3</span></a>, let <span class="math inline">\(T(x)\)</span> denote the spatially continuous target. When the predictive target is at the areal level, the necessary adjustments to Step 3 and Step 4 will be detailed in <a href="#sec-sim-assessment" class="quarto-xref"><span>Section 5.6.5</span></a>.</p>
<p>The outputs generated in these steps include predictive samples of the target over the grid, represented by <span class="math inline">\(T_{(j)}^{(h)}(\tilde{x})\)</span>, where: <span class="math inline">\(j\)</span> is the index of the <span class="math inline">\(j\)</span>-th simulated data-set, for <span class="math inline">\(j = 1, \ldots, B\)</span>; <span class="math inline">\(h\)</span> is the index of the Monte Carlo samples, for <span class="math inline">\(h = 1, \ldots, N\)</span>, generated by the Monte Carlo Markov Chain (MCMC) algorithm for a given data-set <span class="math inline">\(j\)</span>.</p>
<p>An example in R for Step 3 will be provided in the next section, where we shall use the function <code>assess_sim</code>, from the <code>RiskMap</code> package, which combines Step 3 and Step 4 into a single step.</p>
</section><section id="step-4-summarize-the-results-using-a-pre-defined-objective-function" class="level3" data-number="5.6.4"><h3 data-number="5.6.4" class="anchored" data-anchor-id="step-4-summarize-the-results-using-a-pre-defined-objective-function">
<span class="header-section-number">5.6.4</span> Step 4: Summarize the results using a pre-defined objective function</h3>
<p>In this final step, we compare the predictions of the target <span class="math inline">\(T(x)\)</span> against its true values, originally simulated in Step 1. To do this, we need a metric to summarize the results across all <span class="math inline">\(B\)</span> simulations for each candidate model <span class="math inline">\(M_C\)</span>.</p>
<p>One approach is to use the predictive mean from <span class="math inline">\(M_C\)</span> in each simulation and evaluate how it differs from <span class="math inline">\(T(x)\)</span>. A natural choice for this comparison is the mean squared error (MSE), defined as:</p>
<p><span id="eq-mse"><span class="math display">\[
\frac{1}{B} \sum_{j=1}^B \sum_{i=1}^q \left(T(\tilde{x}_i) - \hat{T}_{C}(\tilde{x}_i)\right)^2
\tag{5.8}\]</span></span></p>
<p>where <span class="math inline">\(\tilde{x}_i\)</span> is the <span class="math inline">\(i\)</span>-th location on the grid <span class="math inline">\(\tilde{X}\)</span>, <span class="math inline">\(T(\tilde{x}_i)\)</span> represents the true value of the target, and <span class="math inline">\(\hat{T}_{C}(\tilde{x}_i)\)</span> is the predictive mean from <span class="math inline">\(M_C\)</span> at location <span class="math inline">\(\tilde{x}_i\)</span>.</p>
<p>Other options for summarizing the results include using the bias or the absolute median deviation. The bias measures the systematic error between the predicted and true values and is defined as:</p>
<p><span class="math display">\[
\frac{1}{B} \sum_{j=1}^B \sum_{i=1}^q \left(T(\tilde{x}_i) - \hat{T}_{C}(\tilde{x}_i)\right)
\]</span></p>
<p>The median absolute deviation (MAD) focuses on the central tendency of the errors, providing a robust measure of variability. It is defined as:</p>
<p><span class="math display">\[
\text{median}\left(\left|T(\tilde{x}_i) - T^*_{C}(\tilde{x}_i)\right|\right),
\]</span> where <span class="math inline">\(T^*_{C}(\tilde{x}_i)\)</span> is the median across all <span class="math inline">\(N\)</span> the Monte Carlo samples <span class="math inline">\(T_{(j)}^{(h)}(\tilde{x})\)</span>.</p>
<section id="example-2" class="level4" data-number="5.6.4.1"><h4 data-number="5.6.4.1" class="anchored" data-anchor-id="example-2">
<span class="header-section-number">5.6.4.1</span> Example</h4>
<p>Using the output from the <code>surf_sim</code> function, named <code>lib_surf_sim</code>, we can use as the input to the function <code>assess_sim</code> which performs Step 3 and Step 4, previously outlined.</p>
<div class="cell">
<div class="sourceCode" id="cb41" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">res_sim_grid</span> <span class="op">&lt;-</span> <span class="fu">assess_sim</span><span class="op">(</span><span class="va">lib_surf_sim</span>,</span>
<span>                      models <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>M_T <span class="op">=</span> <span class="op">~</span>  <span class="va">elevation</span> <span class="op">+</span></span>
<span>                                             <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">pmax</a></span><span class="op">(</span><span class="va">elevation</span> <span class="op">-</span> <span class="fl">150</span>, <span class="fl">0</span><span class="op">)</span> <span class="op">+</span></span>
<span>                                             <span class="fu">gp</span><span class="op">(</span><span class="va">long</span>, <span class="va">lat</span><span class="op">)</span>,</span>
<span>                                    M_C <span class="op">=</span> <span class="op">~</span> <span class="fu">gp</span><span class="op">(</span><span class="va">long</span>, <span class="va">lat</span><span class="op">)</span><span class="op">)</span>,</span>
<span>                      f_grid_target <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">/</span><span class="op">(</span><span class="fl">1</span><span class="op">+</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span>,</span>
<span>                      pred_objective <span class="op">=</span> <span class="st">"mse"</span>,</span>
<span>                      spatial_scale <span class="op">=</span> <span class="st">"grid"</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In this function, we specify the models to be assessed using the <code>models</code> argument, which is a list of <code>formula</code> objects. The formula <code>M_T</code> represents the true model <span class="math inline">\(M_T\)</span>, while <code>M_C</code> corresponds to the intercept-only model. Note that the coordinate names used in the <code>gp()</code> function within the formulas are converted according to the CRS specified in <code>lib_suf_sim</code>.</p>
<p>The argument <code>f_grid_target</code> defines our target function <span class="math inline">\(T(x)\)</span> over the grid as a transformation of the linear predictor. Specifically, <code>exp(x) / (1 + exp(x))</code> expresses disease prevalence as our predictive target over the grid. The <code>pred_objective</code> argument specifies the objective function from Step 4, with <code>pred_objective = "mse"</code> setting it to the mean squared error from <a href="#eq-mse" class="quarto-xref">Equation&nbsp;<span>5.8</span></a>. Finally, <code>spatial_scle = "grid"</code> indicates that the objective function applies to a pixel-level target according to the grid stored in <code>lib_surf_sim</code>.</p>
<p>We can now look at the summary of <code>res_sim_grid</code>.</p>
<div class="cell">
<div class="sourceCode" id="cb42" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rspatial.github.io/terra/reference/summary.html">summary</a></span><span class="op">(</span><span class="va">res_sim_grid</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre data-code-line-numbers=""><code>Summary of Simulation Results

Mean Squared Error (MSE):
    Model    MSE_mean       MSE_sd
M_T   M_T 0.004426811 0.0009040507
M_C   M_C 0.004390553 0.0008564500</code></pre>
</div>
</div>
<p>The results reported here present the average and standard deviation across 200 simulations for the models <span class="math inline">\(M_C\)</span> and <span class="math inline">\(M_T\)</span>. The differences between the two models are negligible, indicating that the point predictions generated by <span class="math inline">\(M_C\)</span> and <span class="math inline">\(M_T\)</span> perform similarly in recovering the true prevalence surface for river blindness in Liberia.</p>
<p>This result should not be surprising, as estimating regression relationships with prevalence data can be challenging, potentially limiting their predictive advantage. However, incorporating covariates enhances model interpretability, allowing us to understand why the model makes certain predictions in specific areas, which an intercept-only model cannot provide. Thus, even if the model with covariates does not achieve the best predictive performance, we may still choose to retain the covariates, in this case elevation, for their interpretative value.</p>
</section></section><section id="sec-sim-assessment" class="level3" data-number="5.6.5"><h3 data-number="5.6.5" class="anchored" data-anchor-id="sec-sim-assessment">
<span class="header-section-number">5.6.5</span> Assessessment of threshold-based classification of spatial units using geostatistical models</h3>
<p>In this section, we address the specific problem of evaluating how effectively a geostatistical model classifies areal units into predefined categories of a disease indicator, such as prevalence. This issue is particularly relevant when dealing with areal-level targets (<a href="#sec-areal-target" class="quarto-xref"><span>Section 5.4</span></a>) as opposed to spatially continuous targets (<a href="#sec-spat-cont-target" class="quarto-xref"><span>Section 5.3</span></a>). This prediction problem arises when policy decisions regarding interventions are often based on the classification of the areal-level target into predefined categories at the level of administrative regions; see, for example, <span class="citation" data-cites="johnson2021">Johnson et al. (<a href="references.html#ref-johnson2021" role="doc-biblioref">2021</a>)</span> and <span class="citation" data-cites="puranik2024">Puranik et al. (<a href="references.html#ref-puranik2024" role="doc-biblioref">2024</a>)</span>.</p>
<p>To formalize this problem mathematically, let <span class="math inline">\(\mathcal{M}_i\)</span> represent the true value of the areal-level target (e.g., the average prevalence over a district), and let <span class="math inline">\(\hat{\mathcal{M}}_{C,i}\)</span> denote the corresponding prediction produced by the candidate model <span class="math inline">\(M_C\)</span>. Note that <span class="math inline">\(\mathcal{M}_i\)</span> can be easily calculated in Step 1 during simulations from the true model (<a href="#sec-sim-step1" class="quarto-xref"><span>Section 5.6.1</span></a>).</p>
<p>Now, consider that the target <span class="math inline">\(\mathcal{M}_i\)</span> is categorized into predefined classes, which are typically thresholds or ranges of the disease indicator (such as values that define low, medium, and high levels). Denote the true membership class of areal unit <span class="math inline">\(i\)</span> by <span class="math inline">\(\mathcal{D}_i\)</span>, which is determined based on <span class="math inline">\(\mathcal{M}_i\)</span>, and the predicted membership class by <span class="math inline">\(\hat{\mathcal{D}}_{C,i}\)</span>, determined based on <span class="math inline">\(\hat{\mathcal{M}}_{C,i}\)</span>. The goal is to assess the overall quality of the classification, which involves evaluating how well the predicted classes <span class="math inline">\(\hat{\mathcal{D}}_{C,i}\)</span> agree with the true classes <span class="math inline">\(\mathcal{C}_i\)</span> across all areal units and simulations. This assessment provides insight into the model’s ability to accurately classify regions according to the chosen disease indicator and thus guide effective policy decisions.</p>
<p>The required changes to Step 3 (<a href="#sec-sim-step3" class="quarto-xref"><span>Section 5.6.3</span></a>) consist of simply carrying the predictions over the areal units as explained in <a href="#sec-areal-target" class="quarto-xref"><span>Section 5.4</span></a>.</p>
<p>For Step 4, which concerns how we summarize the agreement between the classification generated by <span class="math inline">\(M_C\)</span> and the true classes <span class="math inline">\(\mathcal{D}_i\)</span>, we can proceed as follows. First, we distinguish between indicators that can be computed for a given region and those that summarize performance across all regions.</p>
<p>Assessing classification performance can be approached similarly to evaluating a diagnostic test. Here, true positives, true negatives, false positives, and false negatives are defined at the level of individual spatial units that subdivide the study area. Hence, key indicators include:</p>
<ol type="1">
<li><p><em>Sensitivity</em>: The proportion of areal units correctly classified as belonging to the true membership class when conditioned on that true class:<br><span class="math display">\[
\text{Sensitivity} = \frac{\text{True Positives (TP)}}{\text{True Positives (TP)} + \text{False Negatives (FN)}}
\]</span></p></li>
<li><p><em>Specificity</em> (True Negative Rate): The proportion of areal units not belonging to a given membership class that are correctly classified as not being in that class:<br><span class="math display">\[
\text{Specificity} = \frac{\text{True Negatives (TN)}}{\text{True Negatives (TN)} + \text{False Positives (FP)}}
\]</span></p></li>
<li><p><em>Positive Predictive Value (PPV)</em>: The proportion of areal units predicted to belong to a membership class that are correctly classified, conditioned on the predicted membership class:<br><span class="math display">\[
\text{PPV} = \frac{\text{True Positives (TP)}}{\text{True Positives (TP)} + \text{False Positives (FP)}}
\]</span></p></li>
<li><p><em>Negative Predictive Value (NPV)</em>: The proportion of areal units predicted not to belong to a membership class that are correctly classified, conditioned on the predicted membership class:<br><span class="math display">\[
\text{NPV} = \frac{\text{True Negatives (TN)}}{\text{True Negatives (TN)} + \text{False Negatives (FN)}}
\]</span></p></li>
<li><p><em>Correct Classification Rate</em>: The overall proportion of areal units whose predicted membership class matches the true membership class:<br><span class="math display">\[
\text{Correct Classification Rate} = \frac{\text{True Positives (TP)} + \text{True Negatives (TN)}}{\text{Total Cases (TP + TN + FP + FN)}}
\]</span></p></li>
</ol>
<p>Note that for multiple classes, the indicators above are computed by comparing each class in turn against all other classes combined. This allows us to create a 2 by 2 table, enabling the calculation of the indicators above.</p>
<p>The choice between sensitivity, specificity, PPV, and NPV depends on the specific public health context and the priorities of the decision-making process. Sensitivity and specificity are conditioned on the <em>true membership class</em>, making them useful for assessing the model’s performance in terms of correctly identifying or excluding true positives or negatives. PPV and NPV are conditioned on the <em>predicted membership class</em>, making them more informative about the trustworthiness of predictions, especially when prevalence varies significantly across regions.</p>
<p>We can thus summarize the difference of each indicator as follows.</p>
<ul>
<li><p>Sensitivity is most appropriate when the priority is to ensure that true positive cases (e.g., high-prevalence regions) are not missed. Sensitivity is useful in contexts where failing to identify true cases could have severe consequences, such as delaying critical interventions or underestimating resource needs. For example, during an outbreak, ensuring all high-risk areas are flagged is crucial, even if this increases the number of false positives.</p></li>
<li><p>Specificity is more suitable when the focus is on minimizing false positives, which is critical in contexts where over-classification could lead to unnecessary interventions or misallocation of resources. Specificity may be particularly important in low-prevalence scenarios, where the cost of acting on false alarms could outweigh the benefits of capturing all true positives.</p></li>
<li><p>PPV is appropriate when the emphasis is on the reliability of positive predictions, i.e., how confident we can be that regions classified as high-prevalence are truly high-prevalence. PPV is heavily influenced by the prevalence of the condition being classified, making it especially relevant in scenarios where actionable decisions depend on the certainty of a positive classification.</p></li>
<li><p>NPV is most relevant when it is critical to trust negative predictions, i.e., ensuring that regions predicted as low-prevalence are indeed low-prevalence. NPV is particularly important in low-prevalence settings, where a high proportion of predicted negatives are true negatives.</p></li>
</ul>
<p>Ultimately, the selection of indicators should result from a dialogue between statisticians, epidemiologists, and policy makers, ensuring alignment with the specific priorities and policy decisions being informed by the model’s classifications.</p>
<section id="example-3" class="level4" data-number="5.6.5.1"><h4 data-number="5.6.5.1" class="anchored" data-anchor-id="example-3">
<span class="header-section-number">5.6.5.1</span> Example</h4>
<p>Using the same models, <span class="math inline">\(M_T\)</span> and <span class="math inline">\(M_C\)</span>, from the river blindness example in Liberia, we now compare their performance in classifying admin level 1 regions into two prevalence categories, <span class="math inline">\((0, 0.2)\)</span> and $(0.2, 1) $. The assessment is conducted using <code>assess_sim</code>, where the prevalence surface is first aggregated at the areal level before classification.</p>
<div class="cell">
<div class="sourceCode" id="cb44" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Admin level 1 shape files</span></span>
<span><span class="va">shp_adm</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/rgeoboundaries/man/geoboundaries.html">geoboundaries</a></span><span class="op">(</span>country <span class="op">=</span> <span class="st">"liberia"</span>, adm_lvl <span class="op">=</span> <span class="st">"adm1"</span><span class="op">)</span></span>
<span><span class="va">shp_adm</span> <span class="op">&lt;-</span> <span class="fu">st_transform</span><span class="op">(</span><span class="va">shp_adm</span>, crs<span class="op">=</span> <span class="fl">32629</span><span class="op">)</span></span>
<span></span>
<span><span class="va">res_sim_area</span> <span class="op">&lt;-</span> <span class="fu">assess_sim</span><span class="op">(</span><span class="va">lib_surf_sim</span>,</span>
<span>                      models <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>M_T <span class="op">=</span> <span class="op">~</span>  <span class="va">elevation</span> <span class="op">+</span></span>
<span>                                      <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">pmax</a></span><span class="op">(</span><span class="va">elevation</span> <span class="op">-</span> <span class="fl">150</span>, <span class="fl">0</span><span class="op">)</span> <span class="op">+</span></span>
<span>                                      <span class="fu">gp</span><span class="op">(</span><span class="va">long</span>, <span class="va">lat</span><span class="op">)</span>,</span>
<span>                                    M_C <span class="op">=</span> <span class="op">~</span> <span class="fu">gp</span><span class="op">(</span><span class="va">long</span>, <span class="va">lat</span><span class="op">)</span><span class="op">)</span>,</span>
<span>                      f_grid_target <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">/</span><span class="op">(</span><span class="fl">1</span><span class="op">+</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span>,</span>
<span>                      f_area_target <span class="op">=</span> <span class="va">mean</span>,</span>
<span>                      pred_objective <span class="op">=</span> <span class="st">"classify"</span>, shp <span class="op">=</span> <span class="va">shp_adm</span>,</span>
<span>                      categories <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">0.2</span>,<span class="fl">1</span><span class="op">)</span>,</span>
<span>                      spatial_scale <span class="op">=</span> <span class="st">"area"</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The implementation first loads the admin level 1 shapefiles for Liberia, transforming them to the appropriate coordinate reference system. The arugment <code>f_area_target</code> is set to <code>mean</code>, ensuring that the target prevalence for each region is computed as the average over the area, corresponding to<br><span class="math display">\[
\frac{1}{|A|} \int_A T(x) \, dx
\]</span> The classification is performed by specifying <code>pred_objective = "classify"</code>, meaning the models are evaluated based on their ability to assign regions to the correct prevalence class. The <code>categories</code> argument defines the classification thresholds, requiring at least three values to distinguish between two classes. The <code>spatial_scale</code> is set to <code>"area"</code>, meaning predictions are made at the level of administrative regions which are specified by the shapefile <code>shp_adm</code>, passed to the argument <code>shp</code>.</p>
<p>Finally, we can examine the results of the simulation through the summary function.</p>
<div class="cell">
<div class="sourceCode" id="cb45" data-source-line-numbers="nil" data-code-line-numbers="nil"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rspatial.github.io/terra/reference/summary.html">summary</a></span><span class="op">(</span><span class="va">res_sim_area</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre data-code-line-numbers=""><code>Summary of Simulation Results

Classification Results:

Model: M_T

Averages across simulations by Category:
  Sensitivity Specificity       PPV       NPV        CC   Class
1   0.9020851   0.8151707 0.8923583 0.8654312 0.9020851 (0,0.2]
2   0.8151707   0.9020851 0.8654312 0.8923583 0.8151707 (0.2,1]

Proportion of Correct Classification (CC) across categories:
Mean: 0.871, 95% CI: [0.665, 1.000]

Model: M_C

Averages across simulations by Category:
  Sensitivity Specificity       PPV       NPV        CC   Class
1   0.9048404   0.7974989 0.8890838 0.8581346 0.9048404 (0,0.2]
2   0.7974989   0.9048404 0.8581346 0.8890838 0.7974989 (0.2,1]

Proportion of Correct Classification (CC) across categories:
Mean: 0.868, 95% CI: [0.600, 1.000]</code></pre>
</div>
</div>
<p>In this example, the performance of models <span class="math inline">\(M_T\)</span>​ and <span class="math inline">\(M_C\)</span>​ is comparable across all considered indicators. This similarity arises for the same reasons previously discussed examining the quality of prevalence surface predictions.</p>
</section></section></section><section id="sec-theory-prediction" class="level2" data-number="5.7"><h2 data-number="5.7" class="anchored" data-anchor-id="sec-theory-prediction">
<span class="header-section-number">5.7</span> Theory</h2>
<section id="sec-pred-distr-theory" class="level3" data-number="5.7.1"><h3 data-number="5.7.1" class="anchored" data-anchor-id="sec-pred-distr-theory">
<span class="header-section-number">5.7.1</span> Expression of the predictive distribution for a linear geostatistical model</h3>
<p>In this section, we consider the simple case of a linear geostatistical model with a single observation per location.</p>
<p>Let <span class="math inline">\(Y = (Y_1, \ldots, Y_n)^\top\)</span> be the vector of data associated with spatial locations <span class="math inline">\(x_1, \ldots, x_n\)</span>. The model assumes that:</p>
<p><span class="math display">\[\begin{equation}
Y_i = d(x_i)^\top {\beta} + S(x_i) + Z_i, \quad i = 1, \ldots, n,
\end{equation}\]</span></p>
<p>where <span class="math inline">\(d(x_i)\)</span> is a vector of covariates at location <span class="math inline">\(x_i\)</span>, <span class="math inline">\({\beta}\)</span> is a vector of regression coefficients, <span class="math inline">\(S(x)\)</span> is a stationary Gaussian process with mean zero and Matern correlation function <span class="math inline">\(\rho(u)\)</span> (where <span class="math inline">\(u\)</span> is the distance between locations), and <span class="math inline">\(Z_i \sim \mathcal{N}(0, \tau^2)\)</span> represents independent measurement errors (nugget effect).</p>
<p>We first consider the simple case of a linear target, hence <span class="math inline">\(T(x) = d(x)^\top {\beta} + S(x)\)</span>. The goal is to predict the unobserved process <span class="math inline">\(T^* = (T_{n+1}, \ldots, T_{n+q})^\top\)</span> at new locations <span class="math inline">\(x_{n+1}, \ldots, x_{n+q}\)</span>. The predictive distribution of <span class="math inline">\(T^*\)</span>, conditional on the observed data <span class="math inline">\(Y\)</span>, follows a multivariate Gaussian distribution:</p>
<p><span class="math display">\[\begin{equation}
T^* | Y \sim \mathcal{N}(\mu^*, \Sigma^*),
\end{equation}\]</span></p>
<p>where the conditional mean and covariance are given by:</p>
<p><span class="math display">\[\begin{align}
\mu^* &amp;= D^* {\beta} + C \Sigma^{-1} (Y - D {\beta}), \\
{\Sigma}^* &amp;= V - C \Sigma^{-1} C^\top.
\end{align}\]</span></p>
<p>Here, <span class="math inline">\(D^*\)</span> is the design matrix for the prediction locations, <span class="math inline">\(C\)</span> is the cross-covariance matrix between <span class="math inline">\(T^*\)</span> and <span class="math inline">\(Y\)</span>, <span class="math inline">\(\Sigma\)</span> is the covariance matrix of <span class="math inline">\(Y\)</span>, and <span class="math inline">\(V\)</span> is the covariance matrix of <span class="math inline">\(T^*\)</span>. Using a multivariate Gaussian distribution with mean <span class="math inline">\(\mu^*\)</span> and covariance matrix <span class="math inline">\(\Sigma^*\)</span>, we are now able to predict <span class="math inline">\(T^*\)</span> and obtain summaries of uncertainties.</p>
<p>For non-linear prediction targets, i.e.&nbsp;targets that involve non-linear transformations of the spatial process <span class="math inline">\(S(x)\)</span>, say <span class="math inline">\(W(T^*)\)</span>, Monte Carlo methods can be employed. More specifically, we generate samples <span class="math inline">\(T_{(j)}^*\)</span>, for <span class="math inline">\(j=1,\ldots,B\)</span> from the predictive distribution <span class="math inline">\(T^* | Y\)</span> using the multivariate Gaussian distribution with mean <span class="math inline">\(\boldsymbol{\mu}^*\)</span> and covariance <span class="math inline">\(\boldsymbol{\Sigma}^*\)</span>. For each sample <span class="math inline">\(T^{*}_{(j)}\)</span>, the non-linear transformation <span class="math inline">\(W(T^{*}_{(j)} = W^{*}_{(j)}\)</span> of interest is then computed. The predictive summary statistics, such as the mean, variance, or quantiles of <span class="math inline">\(W(T^*)\)</span>, are then estimated by averaging over the simulated samples, e.g.</p>
<p><span class="math display">\[\begin{align}
E[W(T^*) | Y] &amp;\approx  \frac{1}{B} \sum_{J=1}^B W^{*}_{(j)}), \\
\mathrm{Var}[W(T^*) | Y] &amp;\approx \frac{1}{B-1} \sum_{j=1}^B \left( W^{*}_{(j)} - E[W(T^*)] \right)^2.
\end{align}\]</span></p>
<p>For more detailed explanations on this we refer you to Chapter 6 of <span class="citation" data-cites="diggle2007book">P. Diggle and Ribeiro (<a href="references.html#ref-diggle2007book" role="doc-biblioref">2007</a>)</span>.</p>
</section><section id="a-brief-overview-of-scoring-rules" class="level3" data-number="5.7.2"><h3 data-number="5.7.2" class="anchored" data-anchor-id="a-brief-overview-of-scoring-rules">
<span class="header-section-number">5.7.2</span> A brief overview of scoring rules</h3>
<p>We now provide an overview of the theoretical framework of <em>scoring rules</em>, of which the continuous ranked probability score (CRPS) and its scaled variant (SCRPS), previously presented, are an example. Scoring rules are a tool used in the evaluation of probabilistic forecasts. As shown for CRPS and SCRPS, scoring rules are designed to measure how well a predictive distribution aligns with observed outcomes, balancing both <em>calibration</em> and <em>sharpness</em>.</p>
<p>In general, a scoring rule is a function <span class="math inline">\(G(F, y)\)</span> that assigns a numerical score to a predictive distribution <span class="math inline">\(F\)</span> and an observed outcome <span class="math inline">\(y\)</span>. Lower scores typically indicate better predictive performance, as they reflect a closer match between the predicted distribution and the observed value.</p>
<p>A central concept in the theory of scoring rules is that of <em>proper scoring rules</em>. A scoring rule is said to be <em>proper</em> if it favours honest predictions or, in other words, if the expected score is minimized when the predictive distribution <span class="math inline">\(F\)</span> matches the true data-generating distribution <span class="math inline">\(F^*\)</span>. More formally, a scoring rule <span class="math inline">\(G\)</span> is proper if, for all distributions <span class="math inline">\(F\)</span> and <span class="math inline">\(F^*\)</span>, we have: <span class="math display">\[
E_{Y \sim F^*}[G(F^*, Y)] \leq E_{Y \sim F^*}[G(F, Y)],
\]</span> with equality if and only if <span class="math inline">\(F = F^*\)</span> when the rule is <em>strictly proper</em>. This property is crucial because it ensures that forecasters cannot improve their scores by manipulating their predictions to deviate from their true beliefs.</p>
<p>Proper scoring rules encourage the selection of models that yield predictions that are both well-calibrated (reflecting the true distribution of outcomes) and sharp (concentrated around likely values). However, this does not imply that predictions from the (unknown) true model <span class="math inline">\(F^*\)</span> will always be favoured in practice, when dealing with finite samples. In other words, even if two scoring rules are proper, this does not guarantee that the true data-generating model will always achieve a lower score compared to a misspecified model in finite samples. <em>Sample variability</em> can in fact lead to the selection of a misspecified model by chance, especially when the sample size is small or the data are noisy. <em>Model complexity</em> is another important factor. If the true model <span class="math inline">\(F^*\)</span> is highly parameterised and the sample size is insufficient to estimate its parameters accurately, it may perform poorly in predictive tasks due to overfitting or parameter estimation error. In contrast, a simpler misspecified model, despite not capturing the full complexity of the data-generating process, might generalize better in such scenarios. This is related to the bias-variance trade-off, where a model with higher bias (due to misspecification) can still achieve lower overall predictive error if it has substantially lower variance.</p>
<p>The CRPS and SCRPS are examples of a strictly proper scoring rule for continuous outcomes. Other scoring rules are the following:</p>
<ul>
<li><p><em>Logarithmic Score (or Log Score):</em> For a predictive density <span class="math inline">\(f(y)\)</span>, the log score is defined as: <span class="math display">\[
G_{\text{log}}(f, y) = -\log f(y).
\]</span> This rule heavily penalizes low-probability predictions for observed outcomes, making it sensitive to the tails of the predictive distribution.</p></li>
<li><p><em>Brier Score:</em> For binary outcomes, the Brier score measures the mean squared difference between the predicted probability <span class="math inline">\(p\)</span> of an event and the actual outcome <span class="math inline">\(y \in \{0, 1\}\)</span>: <span class="math display">\[
G_{\text{Brier}}(p, y) = (p - y)^2.
\]</span> The Brier score is both proper and easy to interpret, with connections to mean squared error in classical regression.</p></li>
<li><p><em>Energy Score:</em> A generalization of the CRPS to multivariate outcomes, the energy score for a predictive distribution <span class="math inline">\(F\)</span> and observation <span class="math inline">\(y\)</span> is given by: <span class="math display">\[
G_{\text{energy}}(F, y) = E_{X, X' \sim F}[\|X - X'\|] - 2 E_{X \sim F}[\|X - y\|],
\]</span> where <span class="math inline">\(\|\cdot\|\)</span> denotes a norm, typically the Euclidean norm. The energy score is particularly useful for evaluating spatial or multivariate forecasts.</p></li>
</ul>
<p>Many proper scoring rules, including the CRPS, can be decomposed into components that separately capture calibration and sharpness. This decomposition helps to understand the different aspects of predictive performance. Specifically, the expected score can often be expressed as: <span class="math display">\[
E[G(F, Y)] = \underbrace{\text{Uncertainty}}_{\text{inherent in data}} - \underbrace{\text{Resolution}}_{\text{sharpness of predictions}} + \underbrace{\text{Reliability}}_{\text{calibration error}},
\]</span> where: - <em>Uncertainty</em> represents the inherent variability in the data, independent of the model. - <em>Resolution</em> quantifies the model’s ability to produce sharp, confident forecasts. - <em>Reliability</em> (or calibration error) measures the degree to which the forecast probabilities align with observed frequencies.</p>
<p>This decomposition highlights an important trade-off: improving sharpness without compromising calibration is the hallmark of a good probabilistic model. A model that produces overly sharp forecasts may suffer from poor calibration, while a model that is perfectly calibrated but overly diffuse lacks resolution.</p>
<p>As we have shown in this chapter, scoring rules are particularly appropriate in cross-validation frameworks, where the goal is to evaluate how well a model predicts future data realizations. When instead conducting simulation studies, we generate data from a known simulated true surface which becomes our benchmark. Hence, in simulation studies, we do not perform cross-validation but, for a given simulation, we compare the model predictions against the true surface. In such cases, scoring rules are not used because they are designed to assess predictive performance based on observed data, where both calibration and sharpness are critical considerations. Hence, in simulation studies, prediction performance metrics, such as bias, mean squared error (MSE), or other distance-based metrics that directly quantify the deviation from the known truth can be used to quantify the predictive performance of a model.</p>
<p>For a more detailed explanation of scoring rules, <span class="citation" data-cites="gneiting2007">Gneiting, Balabdaoui, and Raftery (<a href="references.html#ref-gneiting2007" role="doc-biblioref">2007</a>)</span> is a recommended read.</p>
</section></section><section id="summary" class="level2" data-number="5.8"><h2 data-number="5.8" class="anchored" data-anchor-id="summary">
<span class="header-section-number">5.8</span> Summary</h2>
<p>In this chapter, we have demonstrated how geostatistical models can be used to draw predictive inference for targets that are spatially continuous (e.g., a prevalence surface within a study region) and aggregated at the areal level (e.g., the average disease prevalence in a district). The fundamental concept underpinning geostatistical prediction is that of the <strong>predictive distribution</strong>, which we define as the distribution of the target <span class="math inline">\(T(x)\)</span> conditioned on the data <span class="math inline">\(y\)</span>. This distribution is the key element that enables the derivation and computation of point predictions, predictive intervals and the probability that the target falls within a pre-specified interval or above/below a given threshold.</p>
<p>To assess the predictive performance of a geostatistical model, we have considered two complementary approaches: <strong>cross-validation</strong> and <strong>simulation studies</strong>.</p>
<p>In the cross-validation framework, the concepts of <strong>calibration</strong> and <strong>sharpness</strong> are introduced to evaluate the quality of spatial predictions. Calibration refers to the agreement between the predicted probability of an event occurring and its actual observed frequency. Sharpness, on the other hand, quantifies the concentration of the predictive distribution around its point estimate. However, sharper predictions are not necessarily better; they must be well-calibrated to be meaningful. Thus, it is appropriate to discuss sharpness only in the context of well calibrated models.</p>
<p>A simulation study, unlike cross-validation, allows us to assess the ability of our model to predict an entire spatial surface within a study area or a predictive target defined over spatial units (e.g., districts) that make up the study area. This is possible because, in a simulation study, we can generate data from a <strong>true model</strong> and then evaluate the quality of inferences from <strong>candidate models</strong> on the simulated surface. The way we summarize predictive performance in a simulation study depends on the objective. If the goal is to assess how closely our point predictions align with the true surface, we can use metrics such as the mean squared error (<a href="#eq-mse" class="quarto-xref">Equation&nbsp;<span>5.8</span></a>), averaged over the grid used to approximate the surface. Conversely, if the objective is to evaluate classification performance by categorizing spatial units into predefined health outcome categories, we can use sensitivity, specificity, negative predictive value, and positive predictive value. The choice of metric depends on whether the priority is minimizing errors in detecting true positives or true negatives (sensitivity and specificity), or ensuring that the spatial units classified as positive or negative are truly so (positive predictive value and negative predictive value). A summary of the metrics considered in this chapter is given in <a href="#tbl-summary-pp-diag" class="quarto-xref">Table&nbsp;<span>5.2</span></a>.</p>
<div id="tbl-summary-pp-diag" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-summary-pp-diag-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;5.2: Summary of the different diagnostic tools and metrics, that are used to assess the predictive performance of a geostatistical model using both cross-validation and simulatoin-based approaches.
</figcaption><div aria-describedby="tbl-summary-pp-diag-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<colgroup>
<col style="width: 41%">
<col style="width: 30%">
<col style="width: 27%">
</colgroup>
<thead><tr class="header">
<th>Diagnostic/Metric</th>
<th>Performance characteristic</th>
<th>Recommended use in</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Bias</td>
<td>Accuracy</td>
<td>Simulation</td>
</tr>
<tr class="even">
<td>Continuous ranked probability score (CRPS)</td>
<td>Calibration and sharpness</td>
<td>Cross-validation</td>
</tr>
<tr class="odd">
<td>Coverage probability</td>
<td>Calibration</td>
<td>Cross-validation and simulation</td>
</tr>
<tr class="even">
<td>Mean square error</td>
<td>Accuracy</td>
<td>Simulation</td>
</tr>
<tr class="odd">
<td>Nonrandomized probability integral transform (PIT)</td>
<td>Calibration</td>
<td>Cross-validation</td>
</tr>
<tr class="even">
<td>PIT</td>
<td>Calibration</td>
<td>Cross-validation</td>
</tr>
<tr class="odd">
<td>Scaled CRPS</td>
<td>Calibration and sharpness</td>
<td>Cross-validation</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
</section><section id="faqs" class="level2" data-number="5.9"><h2 data-number="5.9" class="anchored" data-anchor-id="faqs">
<span class="header-section-number">5.9</span> FAQs</h2>
<ul>
<li><em>What should be the spatial resolution of the grid used for prediction?</em></li>
</ul>
<p>The choice of spatial resolution for the prediction grid involves a trade-off between computational efficiency and the ability to capture spatial correlation. Higher spatial resolution provides more detailed predictions but increases computational demands. A reasonable approach is to ensure that the distance between adjacent grid pixels is small enough to maintain a high spatial correlation. For instance, selecting a resolution where the correlation between neighboring pixels is at least 0.95 can be a useful guideline. However, this threshold is somewhat arbitrary, similar to the convention of using 0.95 in confidence intervals. Ultimately, the resolution should be chosen based on the spatial scale of variation in the data, while avoiding excessive computational burden.</p>
<ul>
<li><em>I have covariates with different spatial resolutions. Which spatial resolution should I use?</em></li>
</ul>
<p>Two main approaches can be considered for handling covariates at different spatial resolutions in geostatistical analysis. The first involves aggregating all covariates to the coarsest resolution, ensuring consistency and avoiding artificial detail. This prevents high-resolution predictions based on low-resolution data but may sacrifice fine-scale spatial variation. The second approach disaggregates covariates to the finest resolution, enabling higher-detail predictions but risking false precision and artifacts if the data do not support such resolution. To assess the impact on inferences, one might apply both approaches and evaluate how they influence the final results.</p>
<ul>
<li><em>My prediction map looks like noise. What could be the error?</em></li>
</ul>
<p>The prediction map appearing noisy could be due to several factors. First, one should verify that the spatial grid was created correctly by plotting it alongside the original data to ensure alignment and consistency. Second, the spatial correlation in the data might be very small relative to the resolution of the grid, causing the model to struggle with capturing meaningful patterns. To address this, increasing the spatial resolution of the grid may help, as finer resolution can better capture the underlying spatial structure.</p>
<ul>
<li><em>The main goal of my analysis is to carry out predictions of the main outcome. However, can I also use the model to draw inferences on the association between the outcome and the covariates that I have included in the model?</em></li>
</ul>
<p>The model developed for prediction, in theory, should not be primarily used to draw inferences on the regression relationships between the outcome and covariates. Understanding regression relationships and making predictions are distinct goals that often require different modeling approaches. While it is possible to interpret the estimated regression coefficients, caution is necessary, as these associations are not causative. Predictive models are optimized for accuracy in predicting th outcome rather than for identifying or explaining underlying relationships, so any inferences drawn should be treated as exploratory rather than definitive. An recommended reading on this topic is <span class="citation" data-cites="shmueli2010">Shmueli (<a href="references.html#ref-shmueli2010" role="doc-biblioref">2010</a>)</span>.</p>
<ul>
<li><em>In my model I have some covariates that are attached to the individual (e.g.&nbsp;age, gender, occupation, etc.). How do I specify them when doing prediction?</em></li>
</ul>
<p>The answer to this question is given in <a href="#sec-non-spar-covariates" class="quarto-xref"><span>Section 5.3.2</span></a>.</p>
</section><section id="review-questions" class="level2" data-number="5.10"><h2 data-number="5.10" class="anchored" data-anchor-id="review-questions">
<span class="header-section-number">5.10</span> Review questions</h2>
<ul>
<li>What are the steps that needs to taken when performing spatial prediction?</li>
<li>Define the predictive distribution of a predictive target and explain how this is used to answer a research question.</li>
<li>Distinguish between spatially continuous and areal-level targets, giving at least two examples for each.</li>
<li>Explain the difference between marginal and joint predictions, and for which targets each can be used.</li>
<li>Define predictive performance in terms of calibration and sharpness.</li>
<li>Explain how calibration can be assessed using graphical tools, by distinguishing between continuous and count outcomes.</li>
<li>Give examples of metrics that can be used to evaluate calibration and sharpness.</li>
<li>Explain how simulation studies can be carried to assess the predictive performance of geostatistical models and how this differ from cross-validation.</li>
</ul></section><section id="exercises" class="level2" data-number="5.11"><h2 data-number="5.11" class="anchored" data-anchor-id="exercises">
<span class="header-section-number">5.11</span> Exercises</h2>
<ol type="1">
<li><p><em>Parametric bootstrap.</em> Using the model fitted to the Anopheles gambiae mosquitoes in <a href="03_model-fitting.html#sec-anopheles-fit" class="quarto-xref"><span>Section 3.3.2</span></a>, simulate 1000 data-sets using the <code>glgpm_sim</code> function and estimate the model to each of the simulated data-set. Use the resulting 1000 estimates to compute 95<span class="math inline">\(\%\)</span> confidence intervals for each of the model parameters and compare this with the confidence intervals obtained from the model summary.</p></li>
<li><p>Using the code from <a href="#sec-compare-pp" class="quarto-xref"><span>Section 5.5</span></a>, redraw the plot of <a href="#fig-anpit" class="quarto-xref">Figure&nbsp;<span>5.10</span></a> by choosing different values for the dispersion parameter of the Negative Binomial distribution. What happens when <span class="math inline">\(\alpha\)</span> is close to 0 and why?</p></li>
<li><p>Consider the example in <a href="#sec-liberia-anpit" class="quarto-xref"><span>Section 5.5.2.1</span></a>. Fit a third model, that extends <span class="math inline">\(M1\)</span> by adding a nugget effect, hence <span class="math display">\[
M_{2} \: : \: \log\left\{\frac{p(x_i)}{1-p(x_i)}\right\} = \beta_0 + \beta_{1}e(x_i) + \beta_{2}\max\{e(x_i) - 150, 0\} + S(x_i) + Z_i.
\]</span> Generate the AnPIT plot for <span class="math inline">\(M_2\)</span> and compare it to those of <span class="math inline">\(M_0\)</span> and <span class="math inline">\(M_1\)</span>. Make sure to apply the function <code>assess_pp</code> to all three models so that the same test sets are used. Is <span class="math inline">\(M_2\)</span> showing a better calibration? Why?</p></li>
<li><p>In the analysis of the <em>Anopheles gambiae</em> moqsuitoes data, consider two models. One that uses elavation, with linear predictor <span class="math display">\[
M_1\: : \: \log\{\lambda(x_i)\} = \beta_0 + \beta_1 e(x_i) + S(x_i)
\]</span> where <span class="math inline">\(e(x)\)</span> is the elevation in meters at location <span class="math inline">\(x\)</span> and <span class="math inline">\(S(x_i)\)</span> is a stationary and isotropic Gaussian process with variance <span class="math inline">\(\sigma^2\)</span> and exponential correlation function <span class="math inline">\(\rho(u) = \exp\{-u/\phi\}, \phi&gt;0\)</span>. Consider also an intercept only model <span class="math display">\[
M_0\: : \: \log\{\lambda(x_i)\} = \beta_0 +  S(x_i).
\]</span> After fitting both models to the data, assess if they are well calibrated models using the average nonrandomized probability integral transform (AnPIT). Assuming both models are well-calibrated, compare the predictive performance using continuous ranked probability score (CRPS) and the scaled CRPS. In doing this, use different sampling schemes to split the data, as illustrated in <a href="#sec-split-data" class="quarto-xref"><span>Section 5.5.1</span></a>, and assess if and how the adopted approach to split the data affects the results.</p></li>
<li><p>Consider the Liberia data-set on riverblindess. Carry out a simulation study where the objective is to assess the impact of mispecifying non-linear relationships between elevation and prevalence. Consider <a href="#eq-true-model-lib" class="quarto-xref">Equation&nbsp;<span>5.7</span></a> as the true model and a model that specifies the relationship as linear on the logit scale as the candidate model, hence <span class="math display">\[M_{C}: \:
\log\left\{\frac{p(x_i)}{1-p(x_i)}\right\} = \beta_{0} + \beta_{1}e(x_i) + S(x_i).
\]</span> Carry out 200 iterations in the simulation and define a suitable metric of predictive performance to compare the two models. Provide a clear answer on the impact of assuming a linear relationship with elevation when this is not valid.</p></li>
</ol>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-amazigo2008" class="csl-entry" role="listitem">
Amazigo, U. 2008. <span>“The African Programme for Onchocerciasis Control (APOC).”</span> <em>Ann Trop Med Parasitol</em> 102 (Suppl 1): 19–22. <a href="https://doi.org/10.1179/136485908X337436">https://doi.org/10.1179/136485908X337436</a>.
</div>
<div id="ref-bates2015" class="csl-entry" role="listitem">
Bates, Douglas, Martin Mächler, Ben Bolker, and Steve Walker. 2015. <span>“Fitting Linear Mixed-Effects Models Using <span class="nocase">lme4</span>.”</span> <em>Journal of Statistical Software</em> 67 (1): 1–48. <a href="https://doi.org/10.18637/jss.v067.i01">https://doi.org/10.18637/jss.v067.i01</a>.
</div>
<div id="ref-bishop2006" class="csl-entry" role="listitem">
Bishop, Christopher M. 2006. <em>Pattern Recognition and Machine Learning</em>. Springer.
</div>
<div id="ref-bolin2023" class="csl-entry" role="listitem">
Bolin, David, and Jonas Wallin. 2023. <span>“<span class="nocase">Local scale invariance and robustness of proper scoring rules</span>.”</span> <em>Statistical Science</em> 38 (1): 140–59. <a href="https://doi.org/10.1214/22-STS864">https://doi.org/10.1214/22-STS864</a>.
</div>
<div id="ref-bowman1997" class="csl-entry" role="listitem">
Bowman, A. W. 1997. <em>Applied Smoothing Techniques for Data Analysis : The Kernel Approach with s-Plus Illustrations</em>. Oxford Statistical Science Series ; 18. Oxford : New York: Clarendon Press ; Oxford University Press.
</div>
<div id="ref-breslow1993" class="csl-entry" role="listitem">
Breslow, N. E., and D. G. Clayton. 1993. <span>“Approximate Inference in Generalized Linear Mixed Models.”</span> <em>Journal of the American Statistical Association</em> 88: 9–25.
</div>
<div id="ref-brooks2011handbook" class="csl-entry" role="listitem">
Brooks, Steve, Andrew Gelman, Galin L. Jones, and Xiao-Li Meng. 2011. <em>Handbook of Markov Chain Monte Carlo</em>. CRC Press.
</div>
<div id="ref-chilesdelfiner2016" class="csl-entry" role="listitem">
Chilès, J-P, and P. Delfiner. 2016. <em>Geostatistics (Second Edition)</em>. Hoboken: Wiley.
</div>
<div id="ref-christensen2006" class="csl-entry" role="listitem">
Christensen, OF, GO Roberts, and M Sköld. 2006. <span>“Robust Markov Chain Monte Carlo Methods for Spatial Generalized Linear Mixed Models.”</span> <em>Journal of Computational and Graphical Statistics</em> 15 (1): 1–17.
</div>
<div id="ref-christensen2004" class="csl-entry" role="listitem">
Christensen, Ole F. 2004. <span>“Monte Carlo Maximum Likelihood in Model-Based Geostatistics.”</span> <em>Journal of Computational and Graphical Statistics</em> 13 (3): 702–18.
</div>
<div id="ref-cowles1996markov" class="csl-entry" role="listitem">
Cowles, Mary Kathryn, and Bradley P. Carlin. 1996. <span>“Markov Chain Monte Carlo Convergence Diagnostics: A Comparative Review.”</span> <em>Journal of the American Statistical Association</em> 91 (434): 883–904.
</div>
<div id="ref-cressie1991" class="csl-entry" role="listitem">
Cressie, N. A. C. 1991. <em>Statistics for Spatial Data</em>. New York: Wiley.
</div>
<div id="ref-cressie1985" class="csl-entry" role="listitem">
Cressie, Noel. 1985. <span>“Fitting Variogram Models by Weighted Least Squares.”</span> <em>Mathematical Geology</em> 17 (5): 563–86.
</div>
<div id="ref-czado2009" class="csl-entry" role="listitem">
Czado, Claudia, Tilmann Gneiting, and Leonhard Held. 2009. <span>“<span class="nocase">Predictive Model Assessment for Count Data</span>.”</span> <em>Biometrics</em> 65 (4): 1254–61. <a href="https://doi.org/10.1111/j.1541-0420.2009.01191.x">https://doi.org/10.1111/j.1541-0420.2009.01191.x</a>.
</div>
<div id="ref-dawid1984" class="csl-entry" role="listitem">
Dawid, A. P. 1984. <span>“Statistical Theory: The Prequential Approach.”</span> <em>Journal of the Royal Statistical Society: Series A (General)</em> 147 (2): 278–92.
</div>
<div id="ref-diggleBook2019" class="csl-entry" role="listitem">
Diggle, P J, and E Giorgi. 2019. <em>Model-Based Geostatistics for Global Public Health : Methods and Applications.</em> Chapman and Hall/CRC Interdisciplinary Statistics Ser. Milton: Chapman; Hall/CRC.
</div>
<div id="ref-diggle1998" class="csl-entry" role="listitem">
Diggle, P. J., J. A. Tawn, and R. A. Moyeed. 1998. <span>“Model-Based Geostatistics.”</span> <em>Journal of the Royal Statistical Society: Series C (Applied Statistics)</em> 47 (3): 299–350. <a href="https://doi.org/10.1111/1467-9876.00113">https://doi.org/10.1111/1467-9876.00113</a>.
</div>
<div id="ref-diggle2007book" class="csl-entry" role="listitem">
Diggle, Peter, and Paulo Justiniano Ribeiro. 2007. <em>Model-Based Geostatistics</em>. Springer Series in Statistics. Springer.
</div>
<div id="ref-dobson2008" class="csl-entry" role="listitem">
Dobson, A. J., and A. Barnett. 2008. <em>An Introduction to Generalized Linear Models</em>. Third. Chapman; Hall/CRC.
</div>
<div id="ref-evans2021" class="csl-entry" role="listitem">
Evans, Jeffrey S., and Melanie A. Murphy. 2021. <em>spatialEco</em>. <a href="https://github.com/jeffreyevans/spatialEco">https://github.com/jeffreyevans/spatialEco</a>.
</div>
<div id="ref-fernandez2000" class="csl-entry" role="listitem">
Fernández, J. A, A Rey, and A Carballeira. 2000. <span>“An Extended Study of Heavy Metal Deposition in Galicia (NW Spain) Based on Moss Analysis.”</span> <em>Science of The Total Environment</em> 254 (1): 31–44. <a href="https://doi.org/10.1016/S0048-9697(00)00431-9">https://doi.org/10.1016/S0048-9697(00)00431-9</a>.
</div>
<div id="ref-gelman2013bayesian" class="csl-entry" role="listitem">
Gelman, Andrew, John B. Carlin, Hal S. Stern, David B. Dunson, Aki Vehtari, and Donald B. Rubin. 2013. <em>Bayesian Data Analysis</em>. 3rd ed. CRC Press.
</div>
<div id="ref-gelman1992inference" class="csl-entry" role="listitem">
Gelman, Andrew, and Donald B Rubin. 1992. <span>“Inference from Iterative Simulation Using Multiple Sequences.”</span> <em>Statistical Science</em> 7 (4): 457–72.
</div>
<div id="ref-geweke1992evaluating" class="csl-entry" role="listitem">
Geweke, John. 1992. <span>“Evaluating the Accuracy of Sampling‐based Approaches to the Calculation of Posterior Moments.”</span> Edited by Jose M. Bernardo, James O. Berger, A. Philip Dawid, and Adrian F. M. Smith, 169–93.
</div>
<div id="ref-geyer1991" class="csl-entry" role="listitem">
Geyer, Charles J. 1991. <span>“Markov Chain Monte Carlo Maximum Likelihood.”</span> <em>Journal of Computational and Graphical Statistics</em> 1 (4): 39–55.
</div>
<div id="ref-geyer1994" class="csl-entry" role="listitem">
Geyer, Charles J. 1994. <span>“Likelihood and Exponential Families.”</span> <em>Department of Statistics, University of Minnesota</em>.
</div>
<div id="ref-geyer1996" class="csl-entry" role="listitem">
———. 1996. <span>“Markov Chain Monte Carlo Maximum Likelihood.”</span> <em>Department of Statistics, University of Minnesota</em>.
</div>
<div id="ref-geyer2019handbook" class="csl-entry" role="listitem">
———. 2019. <span>“Monte Carlo Methods in MCMC.”</span> In <em>Handbook of MCMC</em>, edited by Steve Brooks, Andrew Gelman, Galin L. Jones, and Xiao-Li Meng, 3–48. CRC Press.
</div>
<div id="ref-gneiting2007" class="csl-entry" role="listitem">
Gneiting, Tilmann, Fadoua Balabdaoui, and Adrian E Raftery. 2007. <span>“Probabilistic Forecasts, Calibration and Sharpness.”</span> <em>Journal of the Royal Statistical Society: Series B (Statistical Methodology)</em> 69 (2): 243–68.
</div>
<div id="ref-gneiting2007jasa" class="csl-entry" role="listitem">
Gneiting, Tilmann, and Adrian E Raftery. 2007. <span>“Strictly Proper Scoring Rules, Prediction, and Estimation.”</span> <em>Journal of the American Statistical Association</em> 102 (477): 359–78. <a href="https://doi.org/10.1198/016214506000001437">https://doi.org/10.1198/016214506000001437</a>.
</div>
<div id="ref-hastie2001" class="csl-entry" role="listitem">
Hastie, Trevor, Robert Tibshirani, and Jerome Friedman. 2001. <em>The Elements of Statistical Learning</em>. Springer Series in Statistics. New York, NY, USA: Springer New York Inc.
</div>
<div id="ref-hastings1970monte" class="csl-entry" role="listitem">
Hastings, W. K. 1970. <span>“Monte Carlo Sampling Methods Using Markov Chains and Their Applications.”</span> <em>Biometrika</em> 57 (1): 97–109.
</div>
<div id="ref-johnson2021" class="csl-entry" role="listitem">
Johnson, Olatunji, Claudio Fronterre, Benjamin Amoah, Antonio Montresor, Emanuele Giorgi, Nicholas Midzi, Masceline Jenipher Mutsaka-Makuvaza, et al. 2021. <span>“Model-Based Geostatistical Methods Enable Efficient Design and Analysis of Prevalence Surveys for Soil-Transmitted Helminth Infection and Other Neglected Tropical Diseases.”</span> <em>Clinical Infectious Diseases</em> 72 (Supplement_3): S172–79. <a href="https://doi.org/10.1093/cid/ciab192">https://doi.org/10.1093/cid/ciab192</a>.
</div>
<div id="ref-gates2020" class="csl-entry" role="listitem">
Katz, Elizabeth, and Bill &amp; Melinda Gates Foundation. 2020. <span>“Gender and Malaria Evidence Reivew.”</span> Bill &amp; Melinda Gates Foundation. <a href="https://www.gatesgenderequalitytoolbox.org/wp-content/uploads/BMGF_Malaria-Review_FC.pdf">https://www.gatesgenderequalitytoolbox.org/wp-content/uploads/BMGF_Malaria-Review_FC.pdf</a>.
</div>
<div id="ref-krige1951" class="csl-entry" role="listitem">
Krige, D. G. 1951. <span>“A Statistical Approach to Some Basic Mine Valuation Problems on the Witwatersrand.”</span> <em>Journal of the Chemical, Metallurgical and Mining Society of South Africa</em> 52: 119–39.
</div>
<div id="ref-mahoney2023" class="csl-entry" role="listitem">
Mahoney, Michael J, Lucas K Johnson, Julia Silge, Hannah Frick, Max Kuhn, and Colin M Beier. 2023. <span>“Assessing the Performance of Spatial Cross-Validation Approaches for Models of Spatially Structured Data.”</span> <a href="https://doi.org/10.48550/arXiv.2303.07334">https://doi.org/10.48550/arXiv.2303.07334</a>.
</div>
<div id="ref-matern2013" class="csl-entry" role="listitem">
Matern, B. 2013. <em>Spatial Variation</em>. Lecture Notes in Statistics. Springer New York. <a href="https://books.google.co.uk/books?id=HrbSBwAAQBAJ">https://books.google.co.uk/books?id=HrbSBwAAQBAJ</a>.
</div>
<div id="ref-matheron1963" class="csl-entry" role="listitem">
Matheron, G. 1963. <span>“Principles of Geostatistics.”</span> <em>Economic Geology</em> 58: 1246–66.
</div>
<div id="ref-metropolis1953equation" class="csl-entry" role="listitem">
Metropolis, Nicholas, Arianna W. Rosenbluth, Marshall N. Rosenbluth, Augusta H. Teller, and Edward Teller. 1953. <span>“Equation of State Calculations by Fast Computing Machines.”</span> <em>The Journal of Chemical Physics</em> 21 (6): 1087–92.
</div>
<div id="ref-nelder1972" class="csl-entry" role="listitem">
Nelder, J. A., and R. W. M. Wedderburn. 1972. <span>“Generalized Linear Models.”</span> <em>Journal of the Royal Statistical Society A</em> 135: 370–84.
</div>
<div id="ref-pawitan2001" class="csl-entry" role="listitem">
Pawitan, Yudi. 2001. <em>In All Likelihood : Statistical Modelling and Inference Using Likelihood</em>. Oxford ; New York: Clarendon Press : Oxford University Press.
</div>
<div id="ref-puranik2024" class="csl-entry" role="listitem">
Puranik, Amitha, Peter J. Diggle, Maurice R. Odiere, Katherine Gass, Stella Kepha, Collins Okoyo, Charles Mwandawiro, et al. 2024. <span>“Understanding the Impact of Covariates on the Classification of Implementation Units for Soil-Transmitted Helminths Control: A Case Study from Kenya.”</span> <em>BMC Medical Research Methodology</em> 24 (1): 294. <a href="https://doi.org/10.1186/s12874-024-02420-1">https://doi.org/10.1186/s12874-024-02420-1</a>.
</div>
<div id="ref-ripley1981" class="csl-entry" role="listitem">
Ripley, B. D. 1981. <em>Spatial Statistics</em>. New York: Wiley.
</div>
<div id="ref-roberts1996exponential" class="csl-entry" role="listitem">
Roberts, Gareth O., and Richard L. Tweedie. 1996. <span>“Exponential Convergence of Langevin Distributions and Their Discrete Approximations.”</span> <em>Bernoulli</em> 2 (4): 341–63.
</div>
<div id="ref-ross2013" class="csl-entry" role="listitem">
Ross, Sheldon. 2013. <em>First Course in Probability, a.</em> 9th ed. Harlow: Pearson Education UK.
</div>
<div id="ref-rossky1978brownian" class="csl-entry" role="listitem">
Rossky, Peter J., J. D. Doll, and Harold L. Friedman. 1978. <span>“Brownian Dynamics as Smart Monte Carlo Simulation.”</span> <em>The Journal of Chemical Physics</em> 69 (10): 4628–33.
</div>
<div id="ref-rue2009" class="csl-entry" role="listitem">
Rue, H., S. Martino, and N. Chopin. 2009. <span>“Approximate Bayesian Inference for Latent Gaussian Models by Using Integrated Nested Laplace Approximations.”</span> <em>Journal of the Royal Statistical Society: Series B (Statistical Methodology)</em> 71 (2): 319–92. <a href="https://doi.org/10.1111/j.1467-9868.2008.00700.x">https://doi.org/10.1111/j.1467-9868.2008.00700.x</a>.
</div>
<div id="ref-shmueli2010" class="csl-entry" role="listitem">
Shmueli, Galit. 2010. <span>“To Explain or to Predict?”</span> <em>Statistical Science</em> 25 (3): 289–310.
</div>
<div id="ref-smith2007" class="csl-entry" role="listitem">
Smith, David L, Carlos A Guerra, Robert W Snow, and Simon I Hay. 2007. <span>“Standardizing Estimates of the Plasmodium Falciparum Parasite Rate.”</span> <em>Malaria Journal</em> 6 (1): 131–31.
</div>
<div id="ref-stein1999" class="csl-entry" role="listitem">
Stein, Michael L. 1999. <em>Interpolation of Spatial Data Some Theory for Kriging</em>. 1st ed. 1999. Springer Series in Statistics. New York, NY: Springer New York : Imprint: Springer.
</div>
<div id="ref-stevenson2013" class="csl-entry" role="listitem">
Stevenson, Gillian H. AND Gitonga, Jennifer C. AND Stresman. 2013. <span>“Reliability of School Surveys in Estimating Geographic Variation in Malaria Transmission in the Western Kenyan Highlands.”</span> <em>PLOS ONE</em> 8 (10). <a href="https://doi.org/10.1371/journal.pone.0077641">https://doi.org/10.1371/journal.pone.0077641</a>.
</div>
<div id="ref-fossog2015" class="csl-entry" role="listitem">
Tene Fossog, Billy, Diego Ayala, Pelayo Acevedo, Pierre Kengne, Ignacio Ngomo Abeso Mebuy, Boris Makanga, Julie Magnus, et al. 2015. <span>“Habitat Segregation and Ecological Character Displacement in Cryptic African Malaria Mosquitoes.”</span> <em>Evolutionary Applications</em> 8 (4): 326–45. <a href="https://doi.org/10.1111/eva.12242">https://doi.org/10.1111/eva.12242</a>.
</div>
<div id="ref-tobler1970" class="csl-entry" role="listitem">
Tobler, W. R. 1970. <span>“A Computer Movie Simulating Urban Growth in the Detroit Region.”</span> <em>Economic Geography</em> 46: 234–40.
</div>
<div id="ref-watson1971" class="csl-entry" role="listitem">
Watson, G. S. 1971. <span>“Trend -Surface Analysis.”</span> <em>Mathematical Geology</em> 3: 215–26.
</div>
<div id="ref-watson1972" class="csl-entry" role="listitem">
———. 1972. <span>“Trend Surface Analysis and Spatial Correlation.”</span> <em>Geological Society of America Special Paper</em> 146: 39–46.
</div>
<div id="ref-weisberg2014" class="csl-entry" role="listitem">
Weisberg, Sanford. 2014. <em>Applied Linear Regression</em>. Fourth. Hoboken <span>NJ</span>: Wiley. <a href="http://z.umn.edu/alr4ed">http://z.umn.edu/alr4ed</a>.
</div>
<div id="ref-yin2024" class="csl-entry" role="listitem">
Yin, Hui, Yutong Wang, Yuxin Wang, Zihan Li, Yujie Li, and Yuxin Wang. 2024. <span>“A Rapid Review of Clustering Algorithms.”</span> <em>arXiv Preprint arXiv:2401.07389</em>.
</div>
<div id="ref-zhang2002" class="csl-entry" role="listitem">
Zhang, Hao. 2002. <span>“On Estimation and Prediction for Spatial Generalized Linear Mixed Models.”</span> <em>Biometrics</em> 58 (1): 129–36.
</div>
<div id="ref-zhang2004" class="csl-entry" role="listitem">
———. 2004. <span>“Inconsistent Estimation and Asymptotically Equal Interpolations in Model-Based Geostatistics.”</span> <em>Journal of the American Statistical Association</em> 99 (465): 250–61.
</div>
<div id="ref-zoure2014" class="csl-entry" role="listitem">
Zouré, Honorat GM, Mounkaila Noma, Afework H Tekle, Uche V Amazigo, Peter J Diggle, Emanuele Giorgi, and Jan HF Remme. 2014. <span>“Geographic Distribution of Onchocerciasis in the 20 Participating Countries of the African Programme for Onchocerciasis Control: (2) Pre-Control Endemicity Levels and Estimated Number Infected.”</span> <em>Parasites &amp; Vectors</em> 7 (1): 326–26.
</div>
</div>
</section><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr>
<ol>
<li id="fn1"><p>Here, we are overlooking the fact that when <span class="math inline">\(T(x)\)</span> is a linear transformation of <span class="math inline">\(S(x)\)</span> and the the model fitted to the data is a linear geostatistical model, then we can derive any summary of the predictive distribution analytically, without the need of carrying out any simulation. Although this may displease some of our fellow statisticians who care about computational efficiency, for pedagogical reasons, here we have chosen to explain only the Monte Carlo based approach, which works in all scenarios.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>The convex hull of a set of spatial locations is the smallest possible shape (usually a polygon) that completely encloses all the points, such that if you take any two points inside the shape, the straight line connecting them is also entirely inside the shape. In simple terms, it can be thought of as stretching a rubber band around the outermost points in a set, and the shape the rubber band forms is the convex hull.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol></section></main><!-- /main --><script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><nav class="page-navigation"><div class="nav-page nav-page-previous">
      <a href="./04_residuals-analysis.html" class="pagination-link" aria-label="Model validation through residuals analysis">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Model validation through residuals analysis</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./06_case-studies.html" class="pagination-link" aria-label="Case studies">
        <span class="nav-page-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Case studies</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->



<script src="site_libs/quarto-contrib/line-highlight-1.0.0/line-highlight.js" defer="true"></script>
</body></html>