---
execute: 
  freeze: auto
fig-width: 5
fig-asp: 0.75
---

```{r, eval=TRUE, echo=FALSE,message=FALSE}
library(malariaAtlas)
library(dplyr)
library(tidyr)
library(sf)
library(rgee)
library(terra)
library(rgeoboundaries)
library(terra)
library(grid)
library(RiskMap)

waz_fit <- readRDS("data/waz_fit.rds")
haz_fit <- readRDS("data/haz_fit.rds")
stunting_prev <- readRDS("data/stuntin_prev.rds")
underw_prev <- readRDS("data/underw_prev.rds")
assess_haz <- readRDS("data/assess_haz.rds")
assess_waz <- readRDS("data/assess_waz.rds")
load("data/case_study2.RData")
mlw_admin0_sf <- readRDS("data/mlw_admin0_sf.rds")
mlw_sf <- readRDS("data/mlw_sf.rds")
mlw_pfpr <- readRDS("data/mlw_pfpr.rds")
out_file <- "data/malawi_covariates_2006.tif"
r_covs <- rast(out_file)
vals <- terra::extract(r_covs, vect(mlw_sf))
mlw_sf <- bind_cols(mlw_sf, vals[, -1])  # remove ID column
mlw_crs <- propose_utm(mlw_sf)
mlw_sf <- st_transform(mlw_sf, crs = mlw_crs)

mlw_sf <- mlw_sf[, colSums(!is.na(mlw_sf)) > 0]

mod_all_cov <- readRDS("data/mod_all_cov.rds")
mod_pca <- readRDS("data/mod_pca.rds")
pred_all_cov_prev <- readRDS("data/pred_all_cov_prev.rds")
pred_pca_prev <- readRDS("data/pred_pca_prev.rds")
assess_pred_mlw <- readRDS("data/assess_pred_mlw.rds")

assess_pred_mlw$model$pca$score$SCRPS <- NULL
assess_pred_mlw$model$all_cov$score$SCRPS <- NULL

simulate_random_effects <- function(model, nsim = 1000, grid_range = c(-10, 10), grid_length = 5000) {
  # Extract fixed effects and RE variance
  beta_hat <- fixef(model)
  sigma2_hat <- as.numeric(VarCorr(model)[[1]][1])
  
  # Extract model frame and grouping
  mf <- model@frame
  group_var <- names(ranef(model))[1]
  group_ids <- mf[[group_var]]
  unique_groups <- unique(group_ids)
  ngroups <- length(unique_groups)
  
  # Design matrix for fixed effects
  X <- model.matrix(model)
  
  # Create result matrix
  u_samples <- matrix(NA, nrow = ngroups, ncol = nsim)
  rownames(u_samples) <- unique_groups
  
  # Log-predictive density function for one group
  log_pd_u <- function(u, y_j, X_j, beta_hat, sigma2_hat) {
    eta <- as.vector(X_j %*% beta_hat) + u
    loglik <- sum(dpois(y_j, lambda = exp(eta), log = TRUE))
    logprior <- dnorm(u, mean = 0, sd = sqrt(sigma2_hat), log = TRUE)
    return(loglik + logprior)
  }
  
  # For each group, compute predictive samples of u_j
  for (j in seq_along(unique_groups)) {
    gid <- unique_groups[j]
    idx <- which(group_ids == gid)
    y_j <- model@resp$y[idx]
    X_j <- X[idx, , drop = FALSE]
    
    # Create grid and compute log predictive density
    u_grid <- seq(grid_range[1], grid_range[2], length.out = grid_length)
    logdens <- sapply(u_grid, log_pd_u, y_j = y_j, X_j = X_j,
                      beta_hat = beta_hat, sigma2_hat = sigma2_hat)
    logdens <- logdens - max(logdens)
    dens <- exp(logdens)
    pdf_u <- dens / sum(dens)
    cdf_u <- cumsum(pdf_u)
    cdf_u <- cdf_u / max(cdf_u)
    
    # Drop duplicated CDF values (necessary for approx)
    keep <- !duplicated(cdf_u)
    u_samples[j, ] <- approx(cdf_u[keep], u_grid[keep], xout = runif(nsim), rule = 2)$y
    
  }
  
  return(u_samples)
}


```

# Case studies {#sec-case-studies}

## Mapping stunting and underwieght risk in Ghana {#sec-ghana}

Malnutrition remains a critical public health issue in many low- and middle-income countries, particularly affecting children under five years of age. It can have long-term consequences on physical growth, cognitive development, and susceptibility to disease. Monitoring childhood nutritional status is essential for evaluating the effectiveness of health interventions and informing policy decisions.

Two widely used anthropometric indicators derived from child growth measurements are:

-   Height-for-Age Z-score (HAZ): A measure of stunting, which reflects chronic malnutrition. Children with a HAZ below -2 standard deviations from the WHO growth reference median are considered stunted, indicating long-term nutritional deprivation or repeated infections.

-   Weight-for-Age Z-score (WAZ): A composite indicator of underweight, capturing both acute and chronic malnutrition. Children with WAZ below -2 are considered underweight. This measure is commonly used in population-based surveys because it is relatively easy to collect and interpret.

These Z-scores are calculated by comparing individual anthropometric measurements to the WHO Child Growth Standards, which were developed based on data from healthy children under optimal environmental and nutritional conditions [@who2006].

Geostatistical models applied to HAZ and WAZ, or to the prevalence of stunting and underweight derived from these scores, can help answer critical questions such as: *Where is the burden of malnutrition highest? How does it relate to socioeconomic or environmental factors? And which areas should be prioritized for targeted nutritional interventions?*

In this case study, we analyse HAZ and WAZ as continuous outcomes to assess the spatial variation in child malnutrition across Ghana and its association with socioeconomic and demographic covariates.

### Exploratory analysis

We begin by loading the necessary R packages and the `malnutrition` dataset. This geostatistical dataset is derived from the 2014 Ghana Demographic and Health Survey (DHS) [@ghanaDHS2014], which provides nationally representative data on child health and nutrition. The dataset includes anthropometric measurements, household characteristics, and georeferenced sampling cluster coordinates, making it suitable for spatial analysis of child malnutrition.

```{r}
# Load packages
library(RiskMap)
library(ggplot2)
library(dplyr)
library(patchwork)

# Load the data
data(malnutrition)
```

The explanatory variables considered in this analysis are `age` and `wealth`. Figure @fig-maln-expl displays scatterplots of the two nutritional outcomes (`HAZ` and `WAZ`) against age, alongside boxplots stratified by the three levels of the `wealth` variable.

To explore the relationship between age and nutritional status, the code below applies locally estimated scatterplot smoothing (LOESS) to highlight potential non-linear trends. In addition, we fit linear splines using the function `pmax()` to model a change in slope at specified knots—2 months for HAZ and 1 month for WAZ. These change points were selected heuristically based on visual inspection of the LOESS curves.

As shown in Figure @fig-maln-expl, the linear splines (green dashed lines) closely follow the LOESS fits (solid red lines), indicating that the piecewise linear models provide an adequate approximation of the age-nutrition relationship.

```{r}
#| label: fig-maln-expl
#| fig-cap: "Exploratory analysis of HAZ and WAZ by age and wealth. The red lines correspond to LOESS smoothed curves and the green lines to linear splines with change points at 2 months (HAZ) and 1 month (WAZ) of age. Boxplots show variation by household wealth group."  

# Filter complete cases for relevant variables
mal <- malnutrition %>%
  filter(!is.na(HAZ), !is.na(WAZ), !is.na(age), !is.na(wealth))

# Fit spline model for HAZ with knot at 2 months
mod_haz <- lm(HAZ ~ age + pmax(age - 2, 0), data = mal)

# Fit spline model for WAZ with knot at 1 month
mod_waz <- lm(WAZ ~ age + pmax(age - 1, 0), data = mal)

# Prediction grid for HAZ
newdat_haz <- data.frame(age = seq(min(mal$age), max(mal$age), length.out = 200)) 
newdat_haz$fit <- predict(mod_haz, newdata = newdat_haz)

# Prediction grid for WAZ
newdat_waz <- data.frame(age = seq(min(mal$age), max(mal$age), length.out = 200)) 
newdat_waz$fit <- predict(mod_waz, newdata = newdat_waz)

# Plot HAZ vs Age
p1 <- ggplot(mal, aes(x = age, y = HAZ)) +
  geom_point(alpha = 0.3) +
  geom_smooth(method = "loess", colour = "red", se = FALSE) +
  geom_line(data = newdat_haz, aes(x = age, y = fit), 
            colour = "green", linetype = "dashed", linewidth = 1.2) +
  labs(title = "HAZ vs Age", x = "Age (months)", y = "HAZ") +
  theme_minimal()

# Plot WAZ vs Age
p2 <- ggplot(mal, aes(x = age, y = WAZ)) +
  geom_point(alpha = 0.3) +
  geom_smooth(method = "loess", colour = "red", se = FALSE) +
  geom_line(data = newdat_waz, aes(x = age, y = fit), 
            colour = "green", linetype = "dashed", linewidth = 1.2) +
  labs(title = "WAZ vs Age", x = "Age (months)", y = "WAZ") +
  theme_minimal()

# Boxplots for HAZ and WAZ by wealth
p3 <- ggplot(mal, aes(x = factor(wealth), y = HAZ)) +
  geom_boxplot(fill = "lightblue") +
  labs(title = "HAZ by Wealth Group", x = "Wealth (1 = Poor, 3 = Rich)", y = "HAZ") +
  theme_minimal()

p4 <- ggplot(mal, aes(x = factor(wealth), y = WAZ)) +
  geom_boxplot(fill = "lightgreen") +
  labs(title = "WAZ by Wealth Group", x = "Wealth (1 = Poor, 3 = Rich)", y = "WAZ") +
  theme_minimal()

# Combine plots
(p1 | p2) / (p3 | p4)

```

We begin by fitting a non-spatial model to assess whether there is residual spatial correlation that remains after accounting for the effects of age and wealth. Let $Y_{ij}$ represent either the HAZ or WAZ score for the $j$-th child in the $i$-th cluster. The model takes the following form:

$$
Y_{ij} = \beta_0 + \beta_1 a_{ij} + \beta_2 \max\{a_{ij} - c, 0\} + \beta_3 w_i + Z_i + U_{ij},
$$ {#eq-model-haz-waz}

where $a_{ij}$ denotes the age in months of child $j$ in cluster $i$, and $w_i$ is the wealth score associated with cluster $i$; as previously stated, the change point $c$ of the linear spline is set to 2 months for HAZ and 1 month for WAZ. The term $Z_i$ is a Gaussian random effect with mean zero and variance $\tau^2$, capturing between-cluster variation not explained by the covariates. The error term $U_{ij}$ represents child-specific residual variation and is assumed to be Gaussian with mean zero and variance $\omega^2$.

To fit this model, we create a cluster ID variable based on the sampling coordinates and include it as a random intercept in the `lmer` function to incorporate the term $Z_i$.

```{r}
# Create ID for the location
malnutrition <- malnutrition %>%
  group_by(lng, lat) %>%
  mutate(loc_id = cur_group_id()) %>%
  ungroup()
```

We then fit the models using the `lmer` function.

```{r}
library(lme4)
haz_lmer <- 
lmer(HAZ ~ age + pmax(age - 2, 0) + wealth + (1 | loc_id), data = malnutrition)

summary(haz_lmer)

waz_lmer <- 
  lmer(WAZ ~ age + pmax(age - 1, 0) + wealth + (1 | loc_id), data = malnutrition)
summary(waz_lmer)
```

Of particular interest in the summary of the fitted models above are the estimates of the variances associated with the random effects: $\tau^2$ for the cluster-level terms $Z_i$, and $\omega^2$ for the child-specific residuals $U_{ij}$. The estimates suggest that $\omega^2$ is more than twenty times larger than $\tau^2$, indicating that the majority of the unexplained variation occurs at the individual child level rather than between clusters. This has important implications for interpretation: any subsequent mapping of the prevalence of stunting or underweight should acknowledge the high degree of within-cluster variability as a limitation. In particular, predictions at unsampled locations may be subject to substantial uncertainty driven by this fine-scale heterogeneity.

### Assessing residual spatial correlation and model fitting

We next explore the residual spatial correlation through the empirical variogram. Hence, we extract the estimate of the random effects from @eq-model-haz-waz and input these into the `s_variogram` function that generates the empirical variogram.

```{r}
#| label: fig-maln-vari
#| fig-cap: "Empirical variograms for HAZ and WAZ based on the estimated random effects from @eq-model-haz-waz."  
#| 
# Extract random effects for HAZ and WAZ and combine them
re <- data.frame(
  loc_id = as.numeric(rownames(ranef(haz_lmer)$loc_id)),
  Z_hat_haz = ranef(haz_lmer)$loc_id[,1],
  Z_hat_waz = ranef(waz_lmer)$loc_id[,1]
)

# Extract one row per location with coordinates
loc_coords <- malnutrition %>%
  select(loc_id, lng, lat) %>%
  distinct()

# Merge coordinates into random effects
re <- left_join(re, loc_coords, by = "loc_id")

# Convert to sf and transform into UTM
library(sf)
re <- st_as_sf(re, coords = c("lng","lat"), crs = 4326)
re <- st_transform(re, crs = propose_utm(re))

# Variogram for HAZ
var_haz <- s_variogram(re, "Z_hat_haz", scale_to_km = TRUE,
                       n_permutation = 1000)
var_waz <- s_variogram(re, "Z_hat_waz", scale_to_km = TRUE,
                       n_permutation = 1000)
library(patchwork)

# Create ggplot objects
p_haz <- plot_s_variogram(var_haz, plot_envelope = TRUE) + 
  ggtitle("HAZ")

p_waz <- plot_s_variogram(var_waz, plot_envelope = TRUE) + 
  ggtitle("WAZ")

p_haz + p_waz
```

@fig-maln-vari shows the variogram for both HAZ and WAZ. In both cases, we observe that is residual spatial correlation in the data that is not explained by either age or the wealth index. We next extend the model in @eq-model-haz-waz to address this issue.

For our geostatistical analysis of HAZ and WAZ, we consider the following model:

$$
Y_{ij} = \beta_0 + \beta_1 a_{ij} + \beta_2 \max\{a_{ij} - c, 0\} + \beta_3 w_i + S(x_i) + U_{ij},
$$

where $S(x)$ is a zero-mean, stationary, and isotropic Gaussian process with variance $\sigma^2$ and an exponential correlation function with scale parameter $\phi$. In this geostatistical extension, we replace the cluster-level random effect $Z_i$ from @eq-model-haz-waz with the spatial process $S(x_i)$. The random effect $Z_i$ was previously used in the Binomial mixed model to account for unexplained variation between clusters. It is also possible to include both $S(x_i)$ and $Z_i$ in the model, so that the total unexplained variation between clusters is decomposed into a spatially structured component, $S(x_i)$, and an unstructured component, $Z_i$. However, this approach is not recommended in the initial model specification, as it may lead to identifiability issues. It can be considered later in the analysis if justified by model diagnostics.

```{r, eval=FALSE}

# Remove missing data from the WAZ outcome
malnutrition <- malnutrition[complete.cases(malnutrition[,"WAZ"]),]

# Converting the data-frame into an sf object
malnutrition_sf <- st_as_sf(malnutrition, coords = c("lng", "lat"), crs = 4326)
malnutrition_sf <- st_transform(malnutrition_sf, crs = propose_utm(malnutrition_sf))

# Maximum likelihood estimation for the HAZ and WAZ outcomes
haz_fit <- 
glgpm(HAZ ~ age + pmax(age - 1, 0) + wealth + gp(),
      data=malnutrition_sf, family = "gaussian")

waz_fit <- 
  glgpm(HAZ ~ age + pmax(age - 1, 0) + wealth + gp(),
        data=malnutrition_sf, family = "gaussian") 
```

We then summarize the fit of models.

```{r}
summary(haz_fit)

summary(waz_fit)
```

The spatial component of the models reveals a moderate degree of spatial structure in the HAZ and WAZ outcomes. For HAZ, the estimated spatial variance is approximately 0.069, while the individual-level radom effect's variance is substantially larger at around 1.437. For WAZ, the spatial variance is estimated at 0.050, compared to the variance of the individual-level radom effect's variance of 1.125. In both models, as already observed when fitting Binomial mixed models, this indicates that the majority of the residual variation is due to individual-level noise or unstructured heterogeneity rather than spatially structured effects. The relative contribution of the spatial process to the total unexplained variation is therefore relatively small. Nevertheless, geostatistical analysis remains valuable also in this context. Even when spatial effects explain only a modest proportion of the variation, the model still enables spatial prediction of the average spatial pattern for the outcome of interest across the study area. This is useful for identifying areas where child malnutrition is systematically higher or lower, guiding targeted interventions and informing resource allocation. We explore these implications further in the next section on geostatistical prediction for HAZ and WAZ.

### Prediction and assessment of model calibration

Stunting and underweight are standard indicators used to assess child malnutrition. A child is defined as \textit{stunted} if their height-for-age $z$-score (HAZ) is below $-2$ standard deviations from the median of the WHO Child Growth Standards, i.e., HAZ \< -2. Similarly, a child is considered \textit{underweight} if their weight-for-age $z$-score (WAZ) falls below $-2$, i.e., WAZ \< -2 [@sdg2201meta2025]. These thresholds are based on the World Health Organization (WHO) growth reference standards, which provide a normative basis for assessing nutritional status in children under five years of age [@who_underweight2024].

We now define the predictive targets for stunting and underweight prevalence in terms of the adopted geostatistical model. Both indicators correspond to the probability that a child's z-score falls below $-2$, that is, $Y(x) < -2$, where $Y(x)$ denotes either the HAZ or WAZ score at location $x$. Under the model specification, the prevalence is therefore defined as

$$
T(x) = P\left\{ Y(x) < -2 \,\middle|\, S(x) \right\} = \Phi\left( -\frac{\mu + S(x) + 2}{\omega} \right),
$$ {#eq-prev-maln}

where $\Phi(\cdot)$ is the cumulative distribution function of the standard normal distribution, $\mu$ is the linear predictor including the effects of covariates at individual- and cluster-level (as defined by the coefficients $\beta_1$ to $\beta_3$ of @eq-model-haz-waz) as well as the intercept, and $\omega^2$ is the variance of the individual-level residual term. In @eq-prev-maln, we condition on $S(x)$ because this allows us to define both stunting an underweight prevalence as a spatially varying predictive target.

To implement this in `RiskMap`, we begin by generating a predictive grid over the study region. In this case, we use a regular grid with 10 km by 10 km resolution. We then draw predictive samples of the spatial effect $S(x)$ at each grid location, conditional on the observed data. For the `age` variable, we fix it at 2 months for HAZ and 1 month for WAZ, respectively. The `wealth` variable is set to its lowest value of 1. These choices are made to visualize the predictive target for the subgroup of children most at risk of stunting and underweight, as identified through exploratory analysis and the estimated regression coefficients. The code below illustrates this procedure.

```{r, eval=FALSE}
# Boundaries of Ghana
library(rgeoboundaries)
ghana <- geoboundaries(country = "Ghana", adm_lvl = "adm0")
ghana <- st_transform(ghana, st_crs(malnutrition_sf))

ghana_grid <- create_grid(ghana, spat_res = 10)

n_pred <- nrow(st_coordinates(ghana_grid))

# Prediction of S(x) and covariates effects over the grid for

# HAZ
haz_pred_grid <- pred_over_grid(haz_fit,
                                grid_pred = ghana_grid,
                                predictors = data.frame(
                                  # Setting age to 2 months
                                  age = rep(2, n_pred),
                                  # Setting wealth to 1 (least wealthy)
                                  wealth = rep(1, n_pred)
                                ))
# WAZ
waz_pred_grid <- pred_over_grid(waz_fit,
                                grid_pred = ghana_grid,
                                predictors = data.frame(
                                  # Setting age to 1 month
                                  age = rep(1, n_pred),
                                  # Setting wealth to 1 (least wealthy)
                                  wealth = rep(1, n_pred)
                                ))
```

We then use the `pred_target_grid` function to generate predictive summaries of stunting and underweight prevalence, as defined in @eq-prev-maln. To quantify uncertainty in the predictions, we report the coefficient of variation, which provides a standardized measure of relative uncertainty across the prediction grid.

```{r, eval=FALSE}
# Prediction of stunting prevalence
sd_ind_haz <- sqrt(coef(haz_fit)$sigma2_me)
stunting_prev <-
pred_target_grid(haz_pred_grid,
                 f_target = list(prev = function(x) pnorm((-2-x)/sd_ind_haz)),
                 pd_summary = list(mean = mean,
                                       cv = function(x) sd(x)/mean(x)))

# Prediction of underweight prevalence
sd_ind_waz <- sqrt(coef(waz_fit)$sigma2_me)
underw_prev <-
  pred_target_grid(waz_pred_grid,
                   f_target = list(prev = function(x) pnorm((-2-x)/sd_ind_waz)),
                   pd_summary = list(mean = mean,
                                     cv = function(x) sd(x)/mean(x)))
```

Finally, we visualize the results in the map shown in @fig-maln-pred. The maps reveal a clear hotspot for both stunting and underweight, with predicted prevalence values reaching approximately $45\%$ and $24\%$, respectively. Notably, this same region also exhibits lower predictive uncertaint, measured by the coefficient of variation, compared to other areas in Ghana.

```{r}
#| label: fig-maln-pred
#| fig-cap: "Predictive mean and coefficient of variation for stunting and underweight prevalence estimates. The top row shows predictions for stunting, while the bottom row corresponds to underweight. For each indicator, the left panel shows the predictive mean and the right panel the coefficient of variation."
#| fig-width: 10
#| fig-height: 8

# Set up a 2x2 layout
layout(matrix(1:4, nrow = 2, byrow = TRUE))
par(mar = c(4, 4, 4, 5))  # Adjust margins

# Top row: stunting
plot(stunting_prev, which_target = "prev", which_summary = "mean",
     main = "Stunting: Predictive Mean")
plot(stunting_prev, which_target = "prev", which_summary = "cv",
     main = "Stunting: Coefficient of Variation")

# Bottom row: underweight
plot(underw_prev, which_target = "prev", which_summary = "mean",
     main = "Underweight: Predictive Mean")
plot(underw_prev, which_target = "prev", which_summary = "cv",
     main = "Underweight: Coefficient of Variation")
```

To assess the predictive performance and calibration of our geostatistical models for HAZ and WAZ, we perform a cross-validation exercise using the `assess_pp` function. Cross-validation is conducted by repeatedly splitting the data into training and testing sets, ensuring that prediction locations are at least 5 km away from the nearest training point. Specifically, we set `n_size = 100` prediction locations for the test set, impose a minimum distance constraint of 5 km (`min_dist = 5`), and repeat the process over 10 test sets randomly drawn under those conditions (`iter = 10`) using `method="regularized"` as the sampling method.

```{r, eval=FALSE}
# HAZ
assess_haz <-
assess_pp(list(HAZ = haz_fit),
          n_size = 100,
          min_dist = 5,
          iter = 10,
          method = "regularized")

# WAZ
assess_waz <-
  assess_pp(list(WAZ = waz_fit),
            n_size = 100,
            min_dist = 5,
            iter = 10,
            method = "regularized")

```

We note that for a Gaussian linear geostatistical model, the `assess_pp` function does not compute the average non-randomized probability integral transform (AnPIT, introduced in @sec-anpit), as this measure is specifically designed for count outcomes. Instead, it employs the standard probability integral transform (PIT), defined as $\text{PIT}(y) = F_{M}(y)$, where $F_{M}(y)$ is the cumulative distribution function of the predictive distribution evaluated at the observed value $y$. The PIT transforms the observed outcomes in the test set such that, if the model is well-calibrated, these transformed values should follow a uniform distribution. Deviations from uniformity indicate potential issues with calibration and predictive accuracy.

@fig-maln-pit shows the results of the cross-validation exercise visualized through PIT curves for HAZ and WAZ. Similarly to the way we have interpreted the AnPIT curves, the PIT curves indicate good calibration when they lie close to the identity line, meaning the predictive distributions accurately reflect the observed variability in the test sets. The results shown in @fig-maln-pit demonstrate that, for all ten test sets and for both HAZ and WAZ, the PIT curves closely align with the identity line, confirming that the models are well-calibrated and provide reliable uncertainty quantification.

```{r}
#| label: fig-maln-pit
#| fig-cap: "Assessment of the models calibration. The left panel shows the probability integral transform (PIT) curve for HAZ, and the right panel for WAZ. In both panels, the red dahsed line corresponds to the identity line."
#| fig-width: 10
#| fig-height: 4

# Generate PIT plots
p_haz <- plot_AnPIT(assess_haz, mode = "all")
p_waz <- plot_AnPIT(assess_waz, mode = "all")

# Arrange side-by-side
library(gridExtra)
grid.arrange(p_haz, p_waz, ncol = 2)
```

### Summary and conclusions

This case study demonstrated the utility of geostatistical modeling for mapping child malnutrition in Ghana using continuous anthropometric measurements, namely HAZ and WAZ Z-scores. By modeling these outcomes directly, we were able to define stunting and underweight prevalence as predictive probabilities based on threshold exceedance (e.g., HAZ \< -2), rather than by dichotomizing the data prior to analysis. This approach allowed us to retain the full information content of the measurements and to produce spatially resolved predictions of prevalence along with associated uncertainty estimates. Readers interested in a more in-depth treatment of this modeling strategy are referred to @kyomuhangi2021, which discusses the loss of information and degradation in predictive performance that can result from dichotomizing continuous outcomes in geostatistical settings.

More broadly, this case study illustrated how geostatistical models can be used to analyze individual-level outcomes while accounting for both child-level and household-level covariates. Aggregation of data across individuals, such as using average HAZ or WAZ scores per location, is not required and can in fact introduce several complications. In particular, the number of children per cluster varies, which implies that an analysis based on cluster-level averages would require a heteroscedastic specification for the residual term to appropriately reflect varying precision across locations. Ignoring this could lead to unreliable predictive inferences.

In conclusion, this analysis showed that neither dichotomization nor aggregation is necessary in geostaistical analysis. Instead, geostatistical models should be fitted to individual-level continuous outcomes, and suitable predictive targets and summaries of uncertainty can then be derived from the fitted model.

## Mapping malaria in Malawi

In this section, we demonstrate how to conduct a geostatistical analysis using Malaria Indicator Survey (MIS) data accessed through the `malariaAtlas` R package [@malariaAtlas]. This package provides streamlined access to a curated repository of georeferenced malaria data, including prevalence surveys and associated metadata, making it a valuable resource for spatial epidemiological studies. The primary aim here is to illustrate how relevant environmental covariates can be obtained via Google Earth Engine and incorporated into a geostatistical model for prevalence mapping. Although the analysis is not guided by a specific research question, its value lies in showcasing the full workflow and technical aspects introduced in previous chapters, including data preparation, covariate extraction, exploratory analysis, model fitting, and spatial prediction of disease prevalence.

### Downloading prevalence and raster data

This section illustrates how to access and visualize Malaria Indicator Survey data using the `malariaAtlas` R package, focusing on *Plasmodium falciparum* prevalence in Malawi for the year 2006. We walk through the steps to extract survey data, obtain country boundaries, and produce a basic map of raw prevalence data.

We begin by loading the necessary packages and initializing the Earth Engine API via the `rgee` package.

```{r, eval=FALSE}
# Load libraries
library(malariaAtlas)
library(dplyr)
library(tidyr)
library(sf)
library(rgee)
library(terra)
library(rgeoboundaries)
library(grid)

# Initialize Earth Engine
ee_Initialize()
```

We then use `rgeoboundaries` to obtain Malawi’s administrative boundary and extract P. falciparum prevalence survey data from the `malariaAtlas` package for surveys conducted in or overlapping the year 2006.

```{r, eval=FALSE}
# Get Malawi boundary
mlw_admin0_sf <- geoboundaries(country = "Malawi", adm_lvl = "adm0")
mlw_admin0_ee <- sf_as_ee(mlw_admin0_sf)

# Download PfPR survey data
mlw_pfpr <- getPR(country = "Malawi", species = "Pf") %>%
  filter(year_start <= 2006 & year_end >= 2006) %>%
  filter(!is.na(longitude) & !is.na(latitude))

# Convert to sf object
mlw_sf <- st_as_sf(mlw_pfpr, coords = c("longitude", "latitude"), crs = 4326)

# Convert to UTM 
mlw_crs <- propose_utm(mlw_sf)
mlw_sf <- st_transform(mlw_sf, crs = mlw_crs)

# Remove columns with all NAs
mlw_sf <- mlw_sf[, colSums(!is.na(mlw_sf)) > 0]
```

The following map displays the raw prevalence data at each survey location. The size and color of each point reflect the estimated malaria prevalence (pr) at that location.

```{r,collapse=TRUE}
#| label: fig-malawi-raw-map
#| fig-cap: "Raw PfPR survey data for Malawi in 2006. Each point represents a georeferenced survey location, with color and size indicating estimated prevalence."
#| fig-align: center

# Compute prevalence
# Compute observed prevalence
mlw_sf$pr <- mlw_sf$positive / mlw_sf$examined

# Plot raw PfPR data with uniform point size and no axis labels
ggplot() +
  geom_sf(data = mlw_admin0_sf, fill = "white", color = "black") +
  geom_sf(data = mlw_sf, aes(color = pr), size = 1, alpha = 0.8) +
  scale_color_viridis_c(name = "PfPR") +
  theme_minimal() +
  ggtitle("Malaria Prevalence in Malawi (2006)") +
  theme(
    legend.position = "right",
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  )


```

In the next step we retrieve a suite of environmental covariates that are mechanistically linked to malaria transmission and therefore commonly included in spatial risk-mapping studies. All layers are clipped to the Malawi national boundary and combined into a single multi-band image ready for extraction at the survey points.

These covariates are summarised in Table @tbl-covariates, which also explains their epidemiological relevance in the context of malaria transmission.

| Covariate | Source | Processing | Relevance |
|------------------|------------------|------------------|------------------|
| Precipitation | CHIRPS Daily | Annual mean (mm · day⁻¹) | Determines suitability of breeding sites for *Anopheles* mosquitoes. |
| Land-surface temperature | MODIS MOD11A2 | Kelvin converted to °C; annual mean | Affects mosquito survival and parasite development rates. |
| NDVI | MODIS MOD13A2 | Scaled to 0–1; annual mean | Proxy for habitat moisture and vegetation cover. |
| Elevation | SRTM DEM | 90 m; clipped to country boundary | Integrates climatic variation; highlands tend to have lower transmission. |
| Relative humidity | ERA5-Land | Derived from temperature and dew-point; annual mean (%) | High humidity increases mosquito survival. |
| Urbanicity (built-up areas) | MODIS MCD12Q1 | Binary indicator (class 13 = urban) | Urban areas generally have lower risk due to infrastructure and fewer breeding sites. |

: Environmental covariates extracted from Google Earth Engine and their relevance for malaria risk modelling. {#tbl-covariates}

We point out that in order to compute relative humidity, we first extract hourly estimates of air temperature and dew-point temperature at 2 meters above ground level from the ERA5-Land reanalysis product. These two quantities are then combined using a standard empirical formula derived from the Clausius–Clapeyron relation: $$
\text{RH} = 100 \times \left( \frac{e^{\frac{17.625 \cdot T_d}{243.04 + T_d}}}{e^{\frac{17.625 \cdot T}{243.04 + T}}} \right)
$$ where $T_d$ is the dew-point temperature and $T$ is the air temperature, both in degrees Celsius. This yields the mean annual relative humidity over the target region, expressed as a percentage.

@tbl-covariates does not provide an exhaustive list of covariates, and other factors such as soil moisture, land surface water, nighttime temperature, or socio-economic indicators like night-time light intensity and land surface emissivity, which may serve as proxies for human activity, infrastructure, or economic development, could also influence malaria risk. However, to maintain this illustrative analysis simpler, we restrict our attention to a core set of covariates that capture key climatic, ecological, and anthropogenic drivers.

In the code below, all layers are clipped to the boundary of Malawi and combined into a single multi-band image, ready to be extracted at survey point locations for subsequent modeling.

```{r, eval=FALSE}
# -------------------------------
# STEP 2: Covariates from Earth Engine
# -------------------------------
scale_m <- 1000

# Precipitation
precip <- ee$ImageCollection("UCSB-CHG/CHIRPS/DAILY")$
  filterDate("2006-01-01", "2006-12-31")$
  mean()$rename("precip")$clip(mlw_admin0_ee)$toFloat()

# Temperature
lst <- ee$ImageCollection("MODIS/061/MOD11A2")$
  filterDate("2006-01-01", "2006-12-31")$
  select("LST_Day_1km")$mean()$
  multiply(0.02)$subtract(273.15)$rename("lst_c")$
  clip(mlw_admin0_ee)$toFloat()

# NDVI
ndvi <- ee$ImageCollection("MODIS/061/MOD13A2")$
  filterDate("2006-01-01", "2006-12-31")$
  select("NDVI")$mean()$
  multiply(0.0001)$rename("ndvi")$
  clip(mlw_admin0_ee)$toFloat()

# Elevation
elev <- ee$Image("USGS/SRTMGL1_003")$
  rename("elev")$clip(mlw_admin0_ee)$toFloat()

# Humidity from ERA5 (computed from dewpoint and temperature)
era5 <- ee$ImageCollection("ECMWF/ERA5_LAND/HOURLY")$
  filterDate("2006-01-01", "2006-12-31")$
  select(c("dewpoint_temperature_2m", "temperature_2m"))$
  mean()$clip(mlw_admin0_ee)

td <- era5$select("dewpoint_temperature_2m")$subtract(273.15)
t <- era5$select("temperature_2m")$subtract(273.15)

rh <- td$expression(
  "100 * (exp((17.625 * TD)/(243.04 + TD)) / exp((17.625 * T)/(243.04 + T)))",
  list(TD = td, T = t)
)$rename("humidity")$toFloat()

# Use MODIS Land Cover, version 061
urban_raw <- ee$ImageCollection("MODIS/061/MCD12Q1")$
  filterDate("2006-01-01", "2006-12-31")$
  first()$select("LC_Type1")$clip(mlw_admin0_ee)

# Urban areas are class 13 in IGBP classification
built_up <- urban_raw$eq(13)$rename("built_up")$toFloat()



# Combine all covariates
covariates <- precip$
  addBands(lst)$
  addBands(ndvi)$
  addBands(elev)$
  addBands(rh)$
  addBands(built_up)
```

After defining the multi-band raster image `covariates` in Google Earth Engine, we download it as a GeoTIFF file using the `ee_as_rast()` function from the `rgee` package. The file is saved temporarily and clipped to the bounding box of Malawi. We then read the raster into R using the `terra`.

```{r, eval=FALSE}
# -------------------------------
# STEP 3: Download Earth Engine raster
# -------------------------------
out_file <- file.path(tempdir(), "malawi_covariates_2006.tif")
region <- mlw_admin0_ee$geometry()$bounds()

rgee::ee_as_rast(
  image = covariates,
  region = region,
  scale = scale_m,
  dsn = out_file,
  via = "drive"
)

# Load raster
r_covs <- rast(out_file)

# -------------------------------
# STEP 4: Extract covariates at survey locations
# -------------------------------
vals <- terra::extract(r_covs, vect(mlw_sf))
mlw_sf <- bind_cols(mlw_sf, vals[, -1])  # remove ID column
```

The following code generates six raster maps, one for each covariate, using ggplot2. We first convert the raster stack to a data frame and then create a separate ggplot object for each variable, ensuring a consistent and clean visual style across all maps. The plots in @fig-covariates-map are arranged in a 2 × 3 grid using the base grid package.

```{r}
#| label: fig-covariates-map
#| fig-cap: "Raster maps of environmental covariates extracted from Google Earth Engine for Malawi in 2006. Each panel shows one covariate: precipitation, land surface temperature (LST), vegetation cover (NDVI), elevation, relative humidity, and urbanicity. These layers are used as predictors in the geostatistical modelling of malaria prevalence."
#| fig-align: center

# 1. Prepare a data frame

r_df <- as.data.frame(r_covs, xy = TRUE, na.rm = TRUE)

# Rename layers for clarity
names(r_df) <- c("x", "y",
                 "Precipitation",          
                 "Temperature",            
                 "NDVI",                   
                 "Elevation",              
                 "Humidity",               
                 "Urbanicity")             

# Urbanicity as a factor for a discrete palette
r_df$Urbanicity <- factor(r_df$Urbanicity,
                          levels = c(0, 1),
                          labels = c("Rural", "Urban"))

# 2. Build one map per covariate, each with its own colour scale 
p_precip <- ggplot(r_df, aes(x, y, fill = Precipitation)) +
  geom_raster() +
  scale_fill_gradient(name = "mm", low = "lightblue", high = "darkblue") +
  coord_equal() + theme_void() + ggtitle("Precipitation")

p_temp <- ggplot(r_df, aes(x, y, fill = Temperature)) +
  geom_raster() +
  scale_fill_gradient(name = "°C", low = "lemonchiffon", high = "red3") +
  coord_equal() + theme_void() + ggtitle("LST")

p_ndvi <- ggplot(r_df, aes(x, y, fill = NDVI)) +
  geom_raster() +
  scale_fill_gradient(name = " ", low = "cornsilk", high = "darkgreen") +
  coord_equal() + theme_void() + ggtitle("NDVI")

p_elev <- ggplot(r_df, aes(x, y, fill = Elevation)) +
  geom_raster() +
  scale_fill_gradient(name = "m", low = "grey90", high = "sienna4") +
  coord_equal() + theme_void() + ggtitle("Elevation")

p_humid <- ggplot(r_df, aes(x, y, fill = Humidity)) +
  geom_raster() +
  scale_fill_gradient(name = "%", low = "white", high = "darkcyan") +
  coord_equal() + theme_void() + ggtitle("Humidity")

p_urban <- ggplot(r_df, aes(x, y, fill = Urbanicity)) +
  geom_raster() +
  scale_fill_manual(values = c("lightgrey", "black"),
                    name = " ") +
  coord_equal() + theme_void() + ggtitle("Urban vs Rural")

# 3. Arrange the six plots in a 2 × 3 grid using base 'grid'
grid.newpage()
pushViewport(viewport(layout = grid.layout(2, 3)))
vplayout <- function(row, col)
  viewport(layout.pos.row = row, layout.pos.col = col)

print(p_precip, vp = vplayout(1, 1))
print(p_temp,   vp = vplayout(1, 2))
print(p_ndvi,   vp = vplayout(1, 3))
print(p_elev,   vp = vplayout(2, 1))
print(p_humid,  vp = vplayout(2, 2))
print(p_urban,  vp = vplayout(2, 3))
```

### Exploratory analysis

To investigate how *Plasmodium falciparum* prevalence varies with environmental conditions, we begin by computing the empirical logit transformation of the observed prevalence at each survey location. Each covariate is then explored in relation to the empirical logit using scatterplots. For continuous covariates, we produce scatter plots with two fitted curves: a LOESS smoother shown in red, and a linear spline model with a single change point shown in blue. The LOESS curve serves as a flexible, nonparametric reference for assessing the general trend in the data. The spline model provides a simple parametric approximation to this trend, with the change point selected based on visual inspection of where the LOESS curve departs from linearity.

```{r,collapse=TRUE}
#| label: fig-elogit-vs-covariates
#| fig-cap: "Exploratory plots showing the relationship between the empirical logit of *P. falciparum* prevalence and the chosen environmental covariates. Scatter plots show continuous covariates with LOESS (red) and linear spline (blue) fits. A boxplot is used for the binary urbanicity variable. Change points for splines are based on graphical inspection of the LOESS fitted relationship."
#| fig-align: center


# 1. Prepare data
mlw_sf <- mlw_sf %>%
  mutate(
    elogit = log((positive + 0.5) / (examined - positive + 0.5)),
    `Precipitation` = precip,
    `Temperature (°C)` = lst_c,
    `NDVI` = ndvi,
    `Elevation (m)` = elev,
    `Humidity (%)` = humidity,
    `Urbanicity` = factor(built_up, levels = c(0, 1), labels = c("Rural", "Urban"))
  )

# 2. Drop geometry and reshape
plot_data_cont <- mlw_sf %>%
  select(elogit, `Precipitation`, `Temperature (°C)`, `NDVI`, `Elevation (m)`, `Humidity (%)`) %>%
  st_drop_geometry() %>%
  pivot_longer(cols = -elogit, names_to = "Covariate", values_to = "Value")

plot_data_cat <- mlw_sf %>%
  select(elogit, Urbanicity) %>%
  st_drop_geometry()

# 3. Define change points
knots <- c(
  "Precipitation" = Inf,
  "Temperature (°C)" = 33,
  "NDVI" = Inf,
  "Elevation (m)" = 400,
  "Humidity (%)" = 65
)

# 4. Create individual continuous plots
plots <- lapply(split(plot_data_cont, plot_data_cont$Covariate), function(df) {
  var <- unique(df$Covariate)
  knot <- knots[[var]]
  
  df <- df %>%
    mutate(
      linear_part = Value,
      spline_part = pmax(Value - knot, 0)
    )
  
  ggplot(df, aes(x = Value, y = elogit)) +
    geom_point(alpha = 0.5, size = 1) +
    geom_smooth(method = "loess", se = FALSE, color = "red", linewidth = 1) +
    geom_smooth(method = "lm",
                formula = y ~ x + pmax(x - knot, 0),
                se = FALSE, color = "blue", linewidth = 1) +
    labs(x = var, y = NULL) +
    theme_minimal()
})

# 5. Add Urbanicity boxplot
p_urban <- ggplot(plot_data_cat, aes(x = Urbanicity, y = elogit)) +
  geom_boxplot(outlier.size = 0.5) +
  labs(x = "Urbanicity", y = NULL) +
  theme_minimal()

# 6. Assemble 2 x 3 plot grid
final_plot <- (plots[[1]] | plots[[2]] | plots[[3]]) /
  (plots[[4]] | plots[[5]] | p_urban) +
  plot_annotation(title = "Empirical logit of prevalence vs environmental covariates")

final_plot

```

@fig-elogit-vs-covariates shows the results of this exploratory approach for the relationship between prevalence and covariates. For some variables, such as temperature, elevation, and humidity, there is a clear nonlinear association that is reasonably captured by a single change point. For others, including precipitation and NDVI, the relationship appears approximately linear, and for this reason no change point is used in the spline fit.

Urbanicity is treated separately as a binary covariate and visualized with a boxplot comparing the empirical logit of prevalence between rural and urban settings. The boxplot indicates that, as we expect, the level of prevalence in urban areas is considerable lower than in rural areas.

To assess the degree of correlation between covariates, we compute the pairwise Pearson correlation coefficients among the continuous environmental variables.

```{r}
#| label: fig-correlation-heatmap
#| fig-cap: "Pairwise Pearson correlation matrix between continuous environmental covariates."
#| fig-align: center

library(ggcorrplot)

# Select continuous covariates only
cont_vars <- mlw_sf %>%
  st_drop_geometry() %>%
  select(Precipitation = precip,
         Temperature = lst_c,
         NDVI = ndvi,
         Elevation = elev,
         Humidity = humidity)

# Compute correlation matrix
corr_mat <- cor(cont_vars, use = "complete.obs")

# Plot correlation matrix
ggcorrplot(corr_mat,
           method = "circle",
           type = "lower",
           lab = TRUE,
           lab_size = 3,
           colors = c("blue", "white", "red"),
           title = "Correlation between covariates",
           ggtheme = theme_minimal())
```

The correlations, shown in Figure @fig-correlation-heatmap, are generally moderate in magnitude, ranging from –0.66 between temperature and precipitation to 0.54 between elevation and relative humidity. These values indicate that collinearity is not a major concern in our model development. Each covariate is likely to provide complementary information about malaria risk, and the absence of strong dependencies also supports the reliability of the scatterplots used to explore their individual relationships with prevalence.

We also perform a principal component analysis (PCA) on the standardized continuous environmental covariates to assess the potential for reducing dimensionality in our model. The code below shows the implementation of the PCA.

```{r}
#| label: fig-pca-scree
#| fig-cap: "Proportion of variance explained by the principal components computed from standardized continuous environmental covariates."
#| fig-align: center

library(factoextra)

# Prepare only continuous covariates and standardize
pca_data <- mlw_sf %>%
  st_drop_geometry() %>%
  select(Precipitation = precip,
         Temperature = lst_c,
         NDVI = ndvi,
         Elevation = elev,
         Humidity = humidity) %>%
  scale()

# Perform PCA
pca_result <- prcomp(pca_data)

# Scree plot
fviz_eig(pca_result, addlabels = TRUE, barfill = "steelblue", barcolor = "grey30") +
  theme_minimal()
```

The scree plot in Figure @fig-pca-scree shows the proportion of variance explained by each principal component. The first principal component (PC1) explains approximately 50% of the total variation, suggesting it captures a substantial environmental gradient across the study region. Although additional components may carry useful information, PC1 stands out as a potential candidate for use in model building as a composite environmental index and spatial predictor of malaria prevalence.

```{r}
#| label: tbl-pca-loadings
#| tbl-cap: "Loadings of the first two principal components. Each value indicates the contribution of a standardized covariate to the corresponding component."
#| echo: false

loadings_df <- data.frame(
  Covariate = c("Precipitation", "Temperature", "NDVI", "Elevation", "Humidity"),
  PC1 = c(-0.480, 0.596, -0.338, -0.391, -0.385),
  PC2 = c(-0.339, 0.043, -0.605, 0.560, 0.451)
)

knitr::kable(loadings_df, align = "lcc")

```

Table @tbl-pca-loadings displays the loadings of the first two principal components. The sign and magnitude of each loading reflect how much each standardized covariate contributes to the corresponding component. PC1 shows strong positive loading for temperature and strong negative loadings for precipitation, humidity, and elevation. This suggests that PC1 represents a gradient from cool, humid, high-elevation areas with more rainfall to hotter, drier lowland regions. NDVI also contributes negatively, implying more vegetation cover in cooler, wetter zones. We can thus interpret PC1 as a general heat-aridity gradient, which well aligns with known ecological drivers of malaria risk.

```{r}
#| label: fig-pca1-map-scatter
#| fig-cap: "Left: Spatial distribution of the first principal component (PC1). Right: Empirical logit of malaria prevalence plotted against PC1 with LOESS (red) and linear spline (blue) fits."
#| fig-align: center

# Create raster for PC1
r_stack_std <- scale(r_covs[[c("precip", "lst_c", "ndvi", "elev", "humidity")]])
pc1_weights <- c(-0.480, 0.596, -0.338, -0.391, -0.385)
pc1_rast <- sum(r_stack_std * pc1_weights)
names(pc1_rast) <- "PC1"

# Extract PC1 values
pc1_vals <- terra::extract(pc1_rast, vect(mlw_sf))
mlw_sf$PC1 <- pc1_vals[, 2]

# Convert raster to df for ggplot
pc1_df <- as.data.frame(pc1_rast, xy = TRUE, na.rm = TRUE)
names(pc1_df) <- c("x", "y", "PC1")

# --- Create PC1 map plot ---
p_map <- ggplot(pc1_df, aes(x = x, y = y, fill = PC1)) +
  geom_raster() +
  scale_fill_viridis_c(option = "C") +
  coord_equal() +
  theme_void() +
  ggtitle("PC1: Environmental Gradient")

# --- Create scatterplot with LOESS and spline ---
knot_pc1 <- 0.75
scatter_df <- mlw_sf %>%
  mutate(spline_part = pmax(PC1 - knot_pc1, 0))

p_scatter <- ggplot(scatter_df, aes(x = PC1, y = elogit)) +
  geom_point(alpha = 0.5, size = 1) +
  geom_smooth(method = "loess", se = FALSE, color = "red", linewidth = 1) +
  geom_smooth(method = "lm", formula = y ~ x + pmax(x - knot_pc1, 0),
              se = FALSE, color = "blue", linewidth = 1) +
  theme_minimal() +
  labs(x = "PC1", y = "Empirical logit") +
  ggtitle("Empirical logit vs PC1")

# --- Combine using patchwork ---
# Also add some margin space
p_map <- p_map + theme(plot.margin = margin(r = 20))
p_scatter <- p_scatter + theme(plot.margin = margin(l = 20))
p_map + p_scatter

```

@fig-pca1-map-scatter displays the map of PC1 alongside its relationship with malaria prevalence. As done previously, to aid interpretation, we fit a LOESS curve (red) to visualise the general trend, and a linear spline (blue) with a change point at 0.75 to capture a simplified parametric relationship. The spline fit suggests a nonlinear association: malaria risk increases with PC1 up to around 0.75, after which it begins to decline. This pattern implies that malaria prevalence is highest in areas with intermediate PC1 values, i.e. environments that are neither too cold and wet nor too hot and arid. In other words, there appears to be an optimal range of environmental conditions, as summarised by PC1, that are most conducive to malaria transmission. Beyond this range, particularly in more heat-arid regions, the risk may decline due to ecological constraints on mosquito survival or parasite development.

In the next section, we compare two modelling approaches. The first model includes the original environmental covariates using the linear spline specifications identified during our exploratory analysis. The second model replaces these covariates with PC1 alone, treating it as a composite spatial predictor that summarises the dominant environmental gradient in the study area. In both models, we include urbanicity as a separate fixed effect. Urbanicity is excluded from the PCA because it is a binary variable and highly unbalanced, with most survey locations classified as rural. Modelling it separately ensures that its distinct contribution to malaria risk, more linked to infrastructure, housing conditions, and land use, is properly accounted for.

### Model fitting and spatial prediction

In this section, we fit two geostatistical models to malaria prevalence data from Malawi, comparing the effects of using separate environmental covariates versus summarizing them into a principal component.

The first model (`mod_all_cov`) includes all environmental covariates as separate predictors. Namely these are precipitation $d_{\text{prec}}(x)$, NDVI $d_{\text{ndvi}}(x)$, temperature $d_{\text{temp}}(x)$, elevation $d_{\text{elev}}(x)$, humidity $d_{\text{hum}}(x)$, and urbanicity $d_{\text{urb}}(x)$. Following from the results of the exploratory analysis, nonlinear effects for temperature, elevation, and humidity are modeled using linear splines with thresholds at 33°C, 400 m, and 65%, respectively. The logit-linear model is:

$$
\begin{aligned}
\log\left\{\frac{p(x)}{1 - p(x)}\right\} =\; & 
\beta_0 + 
\beta_1 d_{\text{prec}}(x) +
\beta_2 d_{\text{ndvi}}(x) +
\beta_3 d_{\text{temp}}(x) + \beta_4 \max\{d_{\text{temp}}(x) - 33,\; 0\} \\\\
& +
\beta_5 d_{\text{elev}}(x) + \beta_6 \max\{d_{\text{elev}}(x) - 400,\; 0\} \\\\
& +
\beta_7 d_{\text{hum}}(x) + \beta_8 \max\{d_{\text{hum}}(x) - 65,\; 0\} \\\\
& +
\beta_9 d_{\text{urb}}(x) + S(x)
\end{aligned}
$$.


The second model (`mod_pca`) replaces the continuous covariates with their first principal component $\text{PC}_1(x)$, allowing for a spline above 0.75. The model becomes:

$$
\log\left\{\frac{p(x)}{1-p(x)}\right\} = \beta_0 + 
\beta_1 \text{PC}_1(x) + 
\beta_2 \max\{\text{PC}_1(x) - 0.75,0\} +
\beta_3 d_{\text{urb}}(x) + S(x)
$$

This formulation allows us to assess whether the dimensionality reduction via PCA retains the essential variation in environmental risk while simplifying the model structure.


```{r, eval=FALSE}
# Model with all the covariates as separate predictors
mod_all_cov <-
glgpm(positive ~
    precip +
    ndvi +
    lst_c + pmax(lst_c - 33, 0) +
    elev + pmax(elev - 400, 0) +
    humidity + pmax(humidity - 65, 0) +
    built_up + gp(),
    den = examined,
    data = mlw_sf,
    family = "binomial")

# Model with all the covariates (except `built_up`)
# combined into PC1 which is then used as predictor
mod_pca <-
  glgpm(positive ~
          PC1 + pmax(PC1 - 0.75, 0) +
          built_up + gp(),
        den = examined,
        data = mlw_sf,
        family = "binomial")
```

After fitting the two models, when can then compare the summaries of the fits.
```{r}
summary(mod_all_cov)
summary(mod_pca)
```

In the output above, we see that, compared to the model using all covariates as separate predictors, the model including only PC1 exhibits both a larger estimated spatial correlation scale and higher spatial variance. This indicates that replacing the original covariates with PC1 captures a smaller proportion of the spatial variation in prevalence, leaving the spatial Gaussian process to account for more of the structured residual variability.

We then compare the predicted prevalence from each model using a regular 5 by 5 km grid covering the whole of Malawi, and display the results in @fig-pred_models. The maps show broadly similar spatial patterns, with both models identifying areas of high and low predicted prevalence in the southern region of the country. However, these visual comparisons do not allow us to determine which model performs better. We address this question in the next stage of the analysis by formally assessing the calibration and sharpness of the predictions generated by each model.


```{r, eval=FALSE}
# Create a 5 by 5 regular grid 
grid_mlw <- create_grid(mlw_admin0_sf, spat_res = 5)

# Extract the covariates over the grid
r_covs <- terra::project(r_covs, paste0("epsg:",mlw_crs))
pc1_rast <- terra::project(pc1_rast, paste0("epsg:",mlw_crs))

predictors <- cbind(terra::extract(r_covs,  st_coordinates(grid_mlw)),
                    terra::extract(pc1_rast,  st_coordinates(grid_mlw)))

# Prevalence prediction over the grid for the two fitted models 
pred_all_cov <- pred_over_grid(mod_all_cov,
                               grid_pred = grid_mlw,
                               predictors = predictors)

pred_pca <- pred_over_grid(mod_pca,
                           grid_pred = grid_mlw,
                           predictors = predictors)

pred_all_cov_prev <- pred_target_grid(pred_all_cov,
                                      f_target = list(prev = function(x) exp(x)/(1+exp(x))))

pred_pca_prev <- pred_target_grid(pred_pca,
                             f_target = list(prev = function(x) exp(x)/(1+exp(x))))

```

```{r}
#| label: fig-pred_models
#| fig-cap: "Predictive mean of prevalence obtained from geostatistical models using all covariates ('all_cov') versus the first principal component ('pca') of the standardized continuous environmental variables."
#| fig-align: center


par(mfrow = c(1,2))
plot(pred_all_cov_prev, which_target = "prev", which_summary = "mean",
     main = "Model: 'all_cov'", range = c(0,1))
plot(pred_pca_prev, which_target = "prev", which_summary = "mean",
     main = "Model: 'pca'", range = c(0,1))

```

### Comparison of the predictive performance between models

To evaluate predictive performance, we use three spatially distinct hold-out test sets corresponding to the Northern, Central, and Southern regions of Malawi, as illustrated in @fig-mlw-tests. These were constructed using the `assess_pp` function with `method = "cluster"` and `fold = 3`, ensuring geographically stratified cross-validation. 

```{r, eval=FALSE}
assess_pred_mlw <-
assess_pp(list(all_cov = mod_all_cov,
               pca = mod_pca),
          method = "cluster",
          which_metric = c("AnPIT", "CRPS"),
          iter = 1,
          fold = 3)
```
```{r, echo=FALSE, out.width="80%"}
#| label: fig-mlw-tests
#| fig-cap: "Geographic distribution of sampled locations in Malawi, coloured by their assignment to one of three cross-validation test sets."
knitr::include_graphics("figures/mlw_tests.png")
```
The CRPS score shows that the model including all environmental covariates achieves better predictive accuracy across all test sets. Specifically, it yields a lower average CRPS. This improvement is consistent across the three hold-out data, with particularly notable gains in Test Set 1. Additionally, the non-randomized probability integral transform (AnPIT) plot, shown in @fig-pit-mlw, demonstrates that the full covariate model is better calibrated: its cumulative distribution curves lie closer to the identity line, suggesting that the predicted probabilities align more closely with observed prevalence.

```{r, fig.width=7, fig.height=5}
#| label: fig-pit-mlw
#| fig-cap: "Plot of the average non-randomized probability integral transform (AnPIT) function to assess the calibration of the two geostatistical models ('all_cov' and 'pca') for the malaria prevalence data from Malawi."
plot_AnPIT(assess_pred_mlw, mode = "all")

summary(assess_pred_mlw)
```


### Summary and conclusions

In this case study, we have walked through the full pipeline of conducting a geostatistical analysis of malaria prevalence using Malaria Indicator Survey data from Malawi. We began by downloading geo-referenced survey data from the `malariaAtlas` R package and retrieving relevant environmental covariates from Google Earth Engine. These covariates, selected for their mechanistic relevance to malaria transmission, were processed, clipped to the national boundary, and extracted at survey locations to be used as predictors in subsequent modelling.

A critical step in the analysis involved the exploration of relationships between environmental conditions and malaria prevalence. Through scatterplots and spline fits, we identified key nonlinearities in variables such as temperature, elevation, and humidity, which informed the functional form of covariate effects in the regression model. This exploratory work is essential not only for model formulation but also for understanding the ecological underpinnings of disease risk.

To address potential collinearity and reduce the complexity of the model, we also illustrated the use of PCA as a method for dimensionality reduction. The first principal component (PC1) captured a dominant environmental gradient, summarizing variation across temperature, humidity, elevation, and vegetation, which was then used as a composite predictor in a reduced model. A simpler alternative is to let the data guide you through stepwise selection based on p-values—for example, adding or removing covariates until all retained terms meet a preset significance threshold. When the pool of candidate predictors is large relative to the sample size, however, stepwise methods can become unstable and over-fit; in such cases penalised approaches (e.g. ridge, lasso) or resampling-based strategies are usually preferred. A thorough discussion of these issues, with practical recommendations, is given in Section 4.7 of @harrell2015.

We compared two geostatistical models: one using all environmental covariates as separate predictors (with spline terms for nonlinear effects), and another using PC1 as a summary predictor. Cross-validation based on geographically stratified folds revealed that the full model was better calibrated and achieved sharper predictions, as measured by lower CRPS and AnPIT curves closer to the identity line.

We encourage the reader to explore Exercise 2 at the end of this chapter, where you will investigate whether including a second principal component (PC2) alongside PC1 leads to improved predictive performance. This offers an opportunity to assess whether PCA-based dimensionality reduction can match or exceed the predictive accuracy of models that include all covariates, while potentially offering greater parsimony.

## Mapping the entomological incoluation rate for West Nile Virus in the Sacramento Metropolitan Area, United States

In this section, we use entomological surveillance data from the `vectorsurvR` R package, which provides detailed records of mosquito collections, species identification, trapping effort, and pathogen testing across multiple locations in the United States. The dataset includes mosquito pool-level information such as counts, species, trap dates and locations, and test results for several arboviruses.

This analysis focuses on the mosquito species *Culex pipiens* in areas across the Sacramento Metropolitan Area (SMA), California, over the period 2015 to 2021. *Cx. pipiens* is one of the primary vector species responsible for the transmission of West Nile Virus (WNV) in North America. This time-aggregated subset allows us to investigate spatial patterns of mosquito abundance and WNV presence over several years of surveillance.

West Nile Virus is an arbovirus maintained in an enzootic transmission cycle between *Culex* mosquitoes and birds, with humans and other mammals acting as incidental, dead-end hosts. Human infections can range from asymptomatic to severe neurological disease. Surveillance of both vector abundance and WNV positivity is therefore critical for anticipating human risk and targeting public health interventions. In particular, understanding spatial variation in entomological indicators—such as the expected number of infected mosquitoes—can help identify areas of elevated transmission potential and guide vector control strategies.

### Exploratory analysis

We begin by loading the necessary libraries and the data provided by the `vectorsurvR` package. The main dataset, `sample_pools`, contains information on mosquito pool species, collection date, location, and pathogen testing results. Additional trap-level metadata, including trapping effort, is provided in the `sample_collections` dataset.


```{r, collapse=TRUE}
rm(list = ls())

library(vectorsurvR)
library(dplyr)
library(sf)
library(ggplot2)
library(tigris)
library(patchwork)

options(tigris_use_cache = TRUE)

data(sample_pools)
data(sample_collections)
```

We restrict the data to mosquito pools identified as Cx pipiens and tested for WNV, across all years available in the dataset, from 2015 to 2021.

```{r, collapse=TRUE}
species_name <- "Cx pipiens"

merged <- sample_pools %>%
  filter(species_display_name == species_name,
         test_target_acronym == "WNV") %>%
  left_join(sample_collections %>% select(collection_id, trap_nights),
            by = c("id" = "collection_id", "surv_year"))

library(rgeoboundaries)
ca_counties <- geoboundaries("United States of America", adm_lvl = "ADM2")
sma_names <- c("Sacramento", "Placer", "El Dorado")
sma_boundaries <- ca_counties[ca_counties$shapeName %in% sma_names, ]

```

We then group the filtered data by trap location, computing the year of the survey, the total number of mosquitoes captured, the number of pools tested for WNV, and the number of pools that tested positive. The WNV positivity rate is computed as the proportion of confirmed positive pools out of all pools tested at each site. We convert the grouped data into an `sf` object for spatial plotting and further geostatistical analysis.

```{r, collapse=TRUE}

wnv_summary <- merged %>%
  group_by(pool_longitude, pool_latitude) %>%
  summarise(
    year = unique(surv_year),
    total_mosquitoes = sum(num_count, na.rm = TRUE),
    pools_tested = n(),
    positive_pools = sum(test_status_name == "Confirmed", na.rm = TRUE),
    total_trap_nights = sum(trap_nights, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(wnv_detected = positive_pools > 0) %>%
  st_as_sf(coords = c("pool_longitude", "pool_latitude"), crs = 4326)

bbox <- st_bbox(wnv_summary)
```
To provide spatial context, we use the `rgeoboundaries` package to download second-level administrative boundaries (ADM2) for the United States. We extract the boundaries for Placer, El Dorado and Sacrament counties which make up the SMA.

```{r, collapse=TRUE}
library(rgeoboundaries)

# Get California ADM2 units and filter to relevant counties
ca_counties <- geoboundaries("United States of America", adm_lvl = "ADM2")
sma_names <- c("Sacramento", "Placer", "El Dorado")
sma_boundaries <- ca_counties[ca_counties$shapeName %in% sma_names, ]

```
We then visualize the data using three panels, shown in @fig-wnv-panels. The first shows the location of mosquito traps over the SMA boundary. The second shows the total number of mosquitoes captured at each location. The third displays the proportion of pools testing positive for WNV. All panels use a consistent bounding box and suppress axis ticks for cleaner comparison.

```{r, collapse=TRUE}
#| label: fig-wnv-panels
#| fig-cap: "Spatial summary of *Cx. pipiens* surveillance data in the Sacramento Metropolitan Area (2015–2021). The left panel shows trap locations, the middle panel shows mosquito abundance, and the right panel indicates whether West Nile Virus was detected at each site."
#| fig-width: 14
#| fig-height: 10

# Panel 1: Trap locations
p1 <- ggplot() +
  geom_sf(data = sma_boundaries, fill = "grey95", color = "black", size = 0.3) +
  geom_sf(data = wnv_summary, color = "black", alpha = 0.6, size = 0.4) +
  theme_minimal() +
  labs(title = "Trap locations") +
  theme(
    plot.title = element_text(size = 13, face = "bold", hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  )

# Panel 2: Mosquito counts (scaled)
p2 <- ggplot() +
  geom_sf(data = sma_boundaries, fill = NA, color = "black", size = 0.3) +
  geom_sf(data = wnv_summary, aes(size = total_mosquitoes), color = "red", alpha = 0.6) +
  coord_sf(
    xlim = c(bbox["xmin"] - 0.005, bbox["xmax"] + 0.005),
    ylim = c(bbox["ymin"] - 0.005, bbox["ymax"] + 0.005)
  ) +
  scale_size_continuous(name = "Mosquitoes captured", range = c(0.8, 4)) +
  theme_minimal() +
  labs(title = "Cx. pipiens counts") +
  theme(
    plot.title = element_text(size = 13, face = "bold", hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  )

# Panel 3: WNV detection
p3 <- ggplot() +
  geom_sf(data = sma_boundaries, fill = NA, color = "black", size = 0.3) +
  geom_sf(data = wnv_summary, aes(color = wnv_detected), size = 2.4, alpha = 0.7) +
  scale_color_manual(name = "WNV detected", values = c("FALSE" = "grey60", "TRUE" = "blue")) +
  coord_sf(
    xlim = c(bbox["xmin"] - 0.005, bbox["xmax"] + 0.005),
    ylim = c(bbox["ymin"] - 0.005, bbox["ymax"] + 0.005)
  ) +
  theme_minimal() +
  labs(title = "WNV detection") +
  theme(
    plot.title = element_text(size = 13, face = "bold", hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  )

# Combine the panels
(p1 | p2 | p3) +
  plot_layout(guides = "collect") +
  plot_annotation(
    title = "Mosquito Surveillance in the Sacramento Metropolitan Area (2015–2021)",
    theme = theme(
      plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
      plot.caption = element_text(size = 9, hjust = 0.5, margin = margin(t = 10))
    )
  )


```
Given the time span of the data, it is important to consider the potential for temporal variation in mosquito abundance and infection prevalence. Changes in environmental conditions, climate, or vector control efforts may lead to substantial year-to-year fluctuations in mosquito populations. Additionally, if different geographic areas were sampled in different years, this could introduce spatial confounding, making it difficult to disentangle spatial from temporal effects.

The top panel of @fig-wnv-years reveals that while some spatial variation in sampling locations is present across years, there remains sufficient geographic overlap to enable estimation of temporal trends in mosquito counts. The bottom panel shows a clear temporal pattern: mosquito abundance was highest in 2015, remained relatively stable from 2016 to 2018, and then declined noticeably from 2019 to 2021. The observed decline in Cx. pipiens abundance from 2019 to 2021 likely reflects two key drivers: reduced availability of aquatic breeding sites due to drought, and intensified vector control efforts. @bhattachan2023drought showed that *Cx. pipiens* populations in southern California dropped by about $40\%$ during the 2012–2016 drought, linked to water-use restrictions that limited larval habitat in storm drains and catch basins. At the same time, vector control districts expanded targeted interventions. For example, the Sacramento–Yolo district treated over 160,000 drains in 2018 alone [@sacramento2018annual], and the statewide response plan formalised such practices as part of integrated mosquito management [@cdph2025response].  This temporal feature of the data will thus need to be acknowledged in the next stage of the analysis of the data.

```{r}
#| label: fig-wnv-years
#| fig-cap: "Spatial and temporal overview of *Cx. pipiens* surveillance in the Sacramento Metropolitan Area from 2015 to 2021. The top panel shows the spatial distribution of trap locations for each year. The bottom panel displays the annual average number of mosquitoes captured per trap, illustrating variation in abundance over time."
#| fig-align: "center"
#| fig-width: 18
#| fig-height: 25


# Panel 1: Faceted trap locations by year (larger points and titles)
p_locs <- ggplot(wnv_summary) +
  geom_sf(data = sma_boundaries, fill = NA, color = "black", size = 0.3) +
  geom_sf(color = "black", alpha = 0.8, size = 0.8) +
  facet_wrap(~year, ncol = 4) +
  theme_minimal() +
  labs(title = "Trap locations by year") +
  theme(
    strip.text = element_text(size = 13, face = "bold"),
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  )

# Summary for bar plot
annual_summary <- wnv_summary %>%
  group_by(year) %>%
  summarise(
    total_mosquitoes = sum(total_mosquitoes, na.rm = TRUE),
    total_traps = n(),  # each row in wnv_summary corresponds to a trap location
    mosq_per_trap = total_mosquitoes / total_traps,
    .groups = "drop"
  )

# Panel 2: Average mosquitoes per trap event by year
p_pertrap <- ggplot(annual_summary, aes(x = factor(year), y = mosq_per_trap)) +
  geom_col(fill = "steelblue") +
  theme_minimal() +
  labs(title = "Average mosquitoes per trap", x = "Year", y = "Mosquitoes per trap") +
  theme(
    plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 11)
  )

# Combine panels: faceted maps on top, bar chart on bottom
(p_locs / p_pertrap) +
  plot_layout(heights = c(3, 1)) +
  plot_annotation(
    theme = theme(
      plot.title = element_text(size = 16, face = "bold", hjust = 0.5)
    )
  )


```

### Predicting the average number of mosquitoes

We aim to assess whether there is residual spatial correlation in mosquito counts by fitting the following Poisson mixed-effects model. Let $Y_i$ denote the number of mosquitoes trapped at location $x_i$ and year $t_i$. Conditionally on independent and identically distributed zero-mean Gaussian random effects $Z_i \sim \mathcal{N}(0, \sigma^2)$, we assume:
$$
Y_i \mid Z_i \sim \text{Poisson}(\lambda_i),
$$
with the log-intensity $\lambda_i$ modelled as:
$$
\begin{aligned}
\log\{\lambda_i\} = & 
\beta_1 \, I(t_i = 2015) + 
\beta_2 \, I(2016 \leq t_i \leq 2018) + \\\\
&
\beta_3 \, I(2019 \leq t_i \leq 2021) + 
Z_i \\\\
=& \mu_i + Z_i
\end{aligned}
$$ {#eq-wvn-counts}
We thus fit this model using the `glmer` function from the `lme4` package as follows.
```{r}

# Creation of the indicator functions the different year categories
wnv_summary$group_year <- factor(case_when(
  wnv_summary$year == 2015 ~ "2015",
  wnv_summary$year %in% 2016:2018 ~ "2016–2018",
  wnv_summary$year %in% 2019:2021 ~ "2019–2021",
  TRUE ~ NA_character_
), levels = c("2015", "2016–2018", "2019–2021"))


# ID of the locations
wnv_summary$loc <- 1:nrow(wnv_summary)

# Model fitting
glmer_wvn <- glmer(total_mosquitoes ~ -1 + group_year + (1 | loc),
                   data = wnv_summary, family = poisson,
                   nAGQ = 100)

# Summar of the model fit
summary(glmer_wvn)
```
The summary of the model fit above shows that, as expected, the average mosquito counts were highest in 2015, declined moderately between 2016 and 2018, and were lowest during 2019–2021. The relatively large estimate of the variance $\sigma^2$ of the random effect $Z_i$ suggests substantial extra-Poisson variation between traps that is not explained by year alone. 

We then use the empirical variogram computed on the estimated $Z_i$ to assess the presence of residual spatial correlation. 
```{r, eval=FALSE}

# Extracting the estimates of the random effects
wnv_summary$Z_hat <- ranef(glmer_wvn)$loc[,1]

# Computing the empirical variogram
variogram_wnv <- 
s_variogram(data = wnv_summary, 
            variable = "Z_hat",
            n_permutation = 1000,
            scale_to_km = TRUE,
            bins = seq(0,10, length = 15))

```
We then plot the empirical variogram and add the envelope generated under the assumption of absence of spatial correlation.
```{r,echo=FALSE}
variogram_wnv <- readRDS("data/variogram_wnv.rds")
```
```{r,collapse=TRUE}
#| label: fig-wnv-variogram
#| fig-cap: "Empirical variogram (black line) for based on the random effects fitted from the model in @eq-wvn-counts. The shaded blue area correspond to the envelope of spatial independence at 95% confidence level generated using a permuation test. "
#| fig-align: "center"
#| fig-width: 10
#| fig-height: 15
plot_s_variogram(variogram_wnv, plot_envelope = TRUE)
```

The empirical variogram shown in @fig-wnv-variogram lies entirely within the simulation envelope, indicating no detectable spatial correlation in the residuals. This lack of evidence may be due to the fact that mosquito abundance is influenced by very local environmental conditions such as vegetation, drainage, or breeding site availability, which vary at spatial scales smaller than 1 km. Since only a few trap locations in the dataset are spaced closely enough to capture such fine-scale variation, the analysis may lack the resolution needed to detect spatial dependence. Therefore, although a geostatistical model is not justified in this case, we can still pursue our objective of estimating the average number of mosquitoes at the sampled locations using @eq-wvn-counts. 

The principles used in this case to derive the predictive distribution of $\lambda(x_i)$, the expected number of mosquitoes at a sampled location $x_i$, are similar to those applied in geostatistical models. However, they take a simplified form here because we do not need to account for spatial correlation. The predictive distribution is given by:
$$
\left[\lambda(x_i) \:\middle | \: Y_i = y_i \right] = \int [Z_i] \, [Y_i \mid Z_i] \, dZ_i
$$ {#eq-pred-distr}
In this expression, $[Z_i]$ denotes the density of a Gaussian distribution with mean zero and variance $\sigma^2$, and $[Y_i \mid Z_i]$ is the likelihood from a Poisson model with mean $\lambda(x_i)$. The integral in @eq-pred-distr can be computed numerically in R with relative efficiency. This approach also allows for direct simulation from the predictive distribution, enabling us to compute any desired summary statistics.

For this analysis, we use a custom function called `simulate_random_effects`, which can be copied from @sec-sim-re and pasted into an R script, as it is not included in the `RiskMap` package. Further details of its implementation are provided in @sec-sim-re; here, we focus solely on the analysis.

Hence, we first simulate 1000 samples from the predictive distribution of $Z_i$ and denote those by $Z_i^{(j)}$, for $i=1,\ldots,598$, and $j=1\ldots,1000$.
```{r,eval=FALSE}
n_samples <- 1000
samples_z <- simulate_random_effects(glmer_wvn, n_sim = n_samples)
```

We then obtain predictive samples for $\lambda(x_i)$ by applying the exponential transformation to the linear predictor $\hat{\mu}_i + Z_{i}^{(j)}$, where in $\hat{\mu}_i$ we have plugged in the maximum likelihood estimates of the regression coefficients. 

```{r,eval=FALSE}
beta_hat <- glmer_wvn@beta
D <- model.matrix(glmer_wvn)
mu_hat <- as.numeric(D%*%beta_hat)

# Linear predictor samples
eta_samples <- sapply(1:n_samples,
                      function(i) mu_hat+samples_z[,i])

# Predictive samples of the mean number of mosquitoes
mean_nmosq <- exp(eta_samples)
```
Finally, we compute the predictive mean, including lower and upper bounds of the $95\%$ coverage prediction intervals.
```{r,eval=FALSE}
# Predictive summaries
mosq_mean <- rowMeans(mean_nmosq)
mosq_lower <- apply(mean_nmosq, 1, quantile, probs = 0.025)
mosq_upper <- apply(mean_nmosq, 1, quantile, probs = 0.975)

```


```{r,echo=FALSE, collapse=TRUE}
mosq_mean <- readRDS("data/mosq_mean.rds")
mosq_lower <- readRDS("data/mosq_lower.rds")
mosq_upper <- readRDS("data/mosq_upper.rds")
```

The posterior predictions shown in @fig-mosq-predictions indicate that the pattern of the mean number of mosquitoes across sampled locations is broadly comparable across the three time periods defined by `group_year`. While some small variation in magnitude is visible,  the predictive means and the dispersion around them are similar across time.
```{r, collapse=TRUE}
#| label: fig-mosq-predictions
#| fig-cap: "Predictive mean number of mosquitoes per location with associated 95% prediction intervals, stratified by groups of years, namely 2015, 2016-2018 and 2019-2021. For each panel, locations are ordered by decreasing predictive mean for the number of mosquitoes. The shaded areas represent the uncertainty in the predicted means across the sampled locations."
#| fig-align: "center"
#| fig-width: 10
#| fig-height: 15

# Create dataframe
mosq_df <- data.frame(
  id = 1:length(mosq_mean),
  mean = mosq_mean,
  lower = mosq_lower,
  upper = mosq_upper
)

# Order by descending mean
mosq_df <- mosq_df[order(-mosq_df$mean), ]
mosq_df$id_ordered <- factor(seq_len(nrow(mosq_df)), levels = seq_len(nrow(mosq_df)))
mosq_df$id_sorted <- seq_len(nrow(mosq_df))
mosq_df$group_year <- wnv_summary$group_year[match(mosq_df$id, wnv_summary$loc)]

ggplot(mosq_df, aes(x = id_sorted, y = mean)) +
  geom_line() +
  geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2) +
  facet_wrap(~group_year, scales = "free_x") +
  labs(x = "Location (ordered)", y = "Mean mosquitoes") +
  theme_minimal()

```

### Predicting the entomological incolutation rate

```{r, echo=FALSE}
inf_fit <- readRDS("data/inf_fit.rds")
pred_inf_grid <- readRDS("data/pred_inf_grid.rds")
pred_S_obs_loc <- readRDS("data/pred_S_obs_loc.rds")
eic_df <- readRDS("data/eic_df.rds")
```

```{r,eval=FALSE}
inf_fit <-
glgpm(positive_pools ~ -1 + group_year + gp(),
      par0 = coef(inf_fit), start_pars = coef(inf_fit),
      data = wnv_summary,
      family = "binomial")
```

```{r}
summary(inf_fit)
```

```{r}
# Compute convex hull
geom_union <- st_union(inf_fit$data_sf)
chull_sf <- st_convex_hull(geom_union)
chull_sf <- st_as_sf(data.frame(geometry = st_sfc(chull_sf)),
                     crs = st_crs(inf_fit$data_sf))

# Plot points and convex hull
ggplot() +
  geom_sf(data = inf_fit$data_sf, color = "blue", size = 1) +
  geom_sf(data = chull_sf, fill = NA, color = "red", linewidth = 1) +
  theme_minimal()
```

```{r,eval=FALSE}

grid_pred_sac <- create_grid(chull_sf, spat_res = 0.25)

predictors_sac <- data.frame(group_year =
                               factor(rep("2019–2021", nrow(st_coordinates(grid_pred_sac))),
                                          levels = levels(inf_fit$data_sf$group_year)))
pred_S_inf <- pred_over_grid(inf_fit, predictors = predictors_sac,
                         grid_pred = grid_pred_sac)

pred_inf_grid <- pred_target_grid(pred_S_inf,
                             f_target = list(prev = function(x) exp(x)/(1+exp(x))))
```

```{r,eval=TRUE}
plot(pred_inf_grid,"prev")
```

```{r,eval=FALSE}
pred_S_obs_loc <- pred_over_grid(inf_fit)
```

```{r,eval=FALSE}
mu_hat_inf <- as.numeric(inf_fit$D%*%coef(inf_fit)$beta)
prev_inf_samples <- 1/(1+exp(-(mu_hat_inf +
                        pred_S_obs_loc$S_samples)))

# EIC samples (elementwise)
eic_samples <- mean_nmosq * prev_inf_samples
# eic_samples should be locations x draws

# Calculate EIC summaries
eic_mean  <- apply(eic_samples, 1, mean, na.rm = TRUE)
eic_lower <- apply(eic_samples, 1, quantile, probs = 0.025, na.rm = TRUE)
eic_upper <- apply(eic_samples, 1, quantile, probs = 0.975, na.rm = TRUE)

# Build dataframe directly from original wnv_summary order
eic_df <- data.frame(
  loc_id     = wnv_summary$loc,
  group_year = wnv_summary$group_year,
  mean       = eic_mean,
  lower      = eic_lower,
  upper      = eic_upper
)
```

```{r}
# Order by mean but keep mapping intact
eic_df <- eic_df[order(-eic_df$mean), ]
eic_df$id_sorted <- seq_len(nrow(eic_df))

# Plot
ggplot(eic_df, aes(x = id_sorted, y = mean)) +
  geom_line() +
  geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2) +
  facet_wrap(~group_year, scales = "free_x") +
  labs(x = "Location (ordered)", y = "Entomological Inoculation Rate (EIC)") +
  theme_minimal()
```

## Theory

### Explanaiton of the `simulate_random_effects` function {#sec-sim-re}

In this section, we provide a detailed explanation of the simulate_random_effects function used in this case study.

Simulating from the conditional distribution of $Z_i$​ given the observed counts $y_i$​ under a Poisson mixed model can be done in several ways in R, often more efficiently than the approach illustrated here. However, our goal is not to present the fastest implementation, but to offer a transparent, step-by-step example. This level of detail is useful for readers who wish to understand the underlying computations, or who may want to adapt and generalize the function for other analyses. From a pedagogical perspective, dissecting such a function provides a hands-on introduction to computational methods for generalized linear mixed models and illustrates ideas that are extended in more advanced Bayesian and likelihood-based approaches.

The function is reproduced below:
```{r, eval=FALSE}
simulate_random_effects <- function(model, nsim = 1000, grid_range = c(-10, 10), grid_length = 5000) {
  # Extract fixed effects and RE variance
  beta_hat <- fixef(model)
  sigma2_hat <- as.numeric(VarCorr(model)[[1]][1])
  
  # Extract model frame and grouping
  mf <- model@frame
  group_var <- names(ranef(model))[1]
  group_ids <- mf[[group_var]]
  unique_groups <- unique(group_ids)
  ngroups <- length(unique_groups)
  
  # Design matrix for fixed effects
  D <- model.matrix(model)
  
  # Create result matrix
  u_samples <- matrix(NA, nrow = ngroups, ncol = nsim)
  rownames(u_samples) <- unique_groups
  
  # Log-predictive density function for one group
  log_pd_u <- function(u, y_j, D_j, beta_hat, sigma2_hat) {
    eta <- as.vector(D_j %*% beta_hat) + u
    loglik <- sum(dpois(y_j, lambda = exp(eta), log = TRUE))
    logprior <- dnorm(u, mean = 0, sd = sqrt(sigma2_hat), log = TRUE)
    return(loglik + logprior)
  }
  
  # For each group, compute predictive samples of u_j
  for (j in seq_along(unique_groups)) {
    gid <- unique_groups[j]
    idx <- which(group_ids == gid)
    y_j <- model@resp$y[idx]
    D_j <- D[idx, , drop = FALSE]
    
    # Create grid and compute log predictive density
    u_grid <- seq(grid_range[1], grid_range[2], length.out = grid_length)
    logdens <- sapply(u_grid, log_pd_u, y_j = y_j, D_j = D_j,
                      beta_hat = beta_hat, sigma2_hat = sigma2_hat)
    logdens <- logdens - max(logdens)
    dens <- exp(logdens)
    pdf_u <- dens / sum(dens)
    cdf_u <- cumsum(pdf_u)
    cdf_u <- cdf_u / max(cdf_u)
    
    # Drop duplicated CDF values (necessary for approx)
    keep <- !duplicated(cdf_u)
    u_samples[j, ] <- approx(cdf_u[keep], u_grid[keep], xout = runif(nsim), rule = 2)$y
    
  }
  
  return(u_samples)
}
```
Below, we break down the function step by step.

First, we extract the fixed-effect estimates and the random effect variance from the fitted model:
```r
beta_hat <- fixef(model)                        # Fixed effect coefficients (MLEs)
sigma2_hat <- as.numeric(VarCorr(model)[[1]][1])# Estimated variance of random intercepts
```
These parameters will be treated as known when simulating the predictive of the random effects. Next, we identify the grouping variable for the random effects and compute the fixed-effects design matrix:
```r
mf <- model@frame                      # Model frame containing the data
group_var <- names(ranef(model))[1]     # Name of the grouping variable
group_ids <- mf[[group_var]]            # Group ID for each observation
unique_groups <- unique(group_ids)      # Unique group levels
ngroups <- length(unique_groups)        # Number of groups

D <- model.matrix(model)                # Fixed-effects design matrix
```
Here, `group_ids` associates each observation with its random effect, and `D` is the design matrix used to compute the linear predictor for the fixed effects.

We initialize a results matrix to store the predictive samples for each group:

```r
u_samples <- matrix(NA, nrow = ngroups, ncol = nsim)
rownames(u_samples) <- unique_groups
```

Each row corresponds to a group and each column to a predictive sample of $u_j$.

We then define a helper function to compute the unnormalized log-predictive density of a single random effect $u_j$ given the data for that group:

```r
log_pd_u <- function(u, y_j, D_j, beta_hat, sigma2_hat) {
  eta <- as.vector(D_j %*% beta_hat) + u      # Linear predictor
  loglik <- sum(dpois(y_j, lambda = exp(eta), log = TRUE))   # Poisson likelihood
  logprior <- dnorm(u, mean = 0, sd = sqrt(sigma2_hat), log = TRUE) # Normal prior
  return(loglik + logprior)                   # Unnormalized log-posterior
}
```

This combines the Poisson likelihood for the observations in group $j$ with the Gaussian prior on the random effect.

For each group, we first compute the predictive on a grid of $u$ values, then normalize it to form a cumulative distribution function (CDF), and finally draw samples using inverse CDF sampling.

```r
for (j in seq_along(unique_groups)) {
  gid <- unique_groups[j]
  idx <- which(group_ids == gid)
  y_j <- model@resp$y[idx]
  D_j <- D[idx, , drop = FALSE]

  # Step 1: Compute predictive density on a grid
  u_grid <- seq(grid_range[1], grid_range[2], length.out = grid_length)
  logdens <- sapply(u_grid, log_pd_u, y_j = y_j, D_j = D_j,
                    beta_hat = beta_hat, sigma2_hat = sigma2_hat)
  logdens <- logdens - max(logdens)    # Stabilize exponentiation
  dens <- exp(logdens)
  pdf_u <- dens / sum(dens)

  # Step 2: Compute cumulative distribution
  cdf_u <- cumsum(pdf_u) / sum(pdf_u)

  # Step 3: Sample from predictive using inverse CDF
  keep <- !duplicated(cdf_u)  # Remove duplicates to avoid interpolation warnings
  u_samples[j, ] <- approx(cdf_u[keep], u_grid[keep], xout = runif(nsim), rule = 2)$y
}
```

The function uses a grid-based approximation, evaluating the predictive on a fine grid to avoid running MCMC for these one-dimensional distributions.  
The computation `logdens - max(logdens)` provides numerical stabilization, preventing underflow when exponentiating very small log-likelihood values.  
Finally, the function `approx()` performs inverse transform sampling. This works by first computing the CDF of the random effect on a fine grid, which maps each candidate value of the random effect to its cumulative probability. We then draw random numbers from a uniform distribution on $[0,1]$ and use `approx()` to interpolate the CDF to find the corresponding values of the random effect. In other words, we are transforming uniform draws into samples from the desired predictive distribution by inverting the CDF numerically, a method commonly known as the inverse transform method; for a thorough explanation of this approach, @robert2004 is a highly recommended reading.

As a self-directed learning activity for readers interested in the computational aspects of model fitting, we invite them to work through Exercise 4 at the end of this chapter.

## Exercises

1. Re-analyse the Ghana malnutrition data set (see @sec-ghana) after dichotomising the height-for-age Z-score (HAZ) and weight-for-age Z-score (WAZ). Define two binary outcomes:

    - `HAZ_bin` = 1 if HAZ < −2, and 0 otherwise  
    - `WAZ_bin` = 1 if WAZ < −2, and 0 otherwise
    
    Fit binomial geostatistical models to the individual-level data and compare the point estimates and spatial predictions to those obtained from the geostatistical models described in @sec-ghana. Discuss which model provides a better fit and why.

2. In the Malawi prevalence mapping analysis, we used the first principal component (PC1) of the environmental covariates to summarize covariate variation and reduce dimensionality. In this exercise, you will investigate whether including the second principal component (PC2) improves the model.

    - Compute the second principal component (PC2) from the same set of standardized covariates used to derive PC1. What is the interpretation of PC2? What kind of relationship does PC2 show with the empirical logit?

    - Fit a geostatistical model that includes both PC1 and PC2 as covariates. How do the covariance parameters of the spatial process change after including PC2 compared to the model with PC1 only?

    - Compare this model to:
        - the model using only PC1, and
        - the model using all covariates as separate predictors.  
      
      Use the AnPIT plot and CRPS/SCRPS scores to assess predictive performance.

    - Discuss whether adding PC2 captures additional meaningful variation or introduces multicollinearity or overfitting. What implications does this have for model interpretability and parsimony?


3. In this exercise, you will repeat the full analysis pipeline developed for Malawi using data from a different country.

    - Choose a different country available in the `malariaAtlas` package (e.g., Zambia or Nigeria), and download parasite prevalence survey data for a specific year.

    - Obtain the same set of environmental covariates used in the Malawi analysis, and prepare them for analysis (e.g., resample, standardize, and extract values at survey locations).

    - Fit and compare two geostatistical models:
        - A model using the environmental covariates as separate fixed effects.
        - A model using the first principal component (PC1) as a synthetic covariate summarizing the covariate space.

    - Evaluate model performance using the AnPIT plot and CRPS/SCRPS scores.

    - Reflect on which model performs better in this new setting. Do your conclusions align with what was observed in the Malawi case study? What might explain any differences in performance across countries?
    
4. The function `simulate_random_effects()` in @sec-sim-re samples random effects using a simple grid-based inverse CDF approach.  
While easy to understand, this method can be slow when the number of groups or simulations is large.  Rewrite the function using a more efficient sampling strategy such as slice sampling [@neal2003] or a simple Metropolis–Hastings sampler [@gelman2013bayesian]. After implementing your new function, compare the sampled random effect distributions to those obtained from `simulate_random_effects` and discuss any differences in accuracy and computational speed. 
